<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>cnvpytor.viewer API documentation</title>
<meta name="description" content="cnvpytor.viewer â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cnvpytor.viewer</code></h1>
</header>
<section id="section-intro">
<p>cnvpytor.viewer</p>
<p>Class Viewer: ploting CNVpytor data</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34; cnvpytor.viewer

Class Viewer: ploting CNVpytor data
&#34;&#34;&#34;
from __future__ import absolute_import, print_function, division

from .io import *
from .utils import *
from .genome import *
from .viewparams import ViewParams, HelpDescription
from .annotator import *
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.colors as colors
from scipy.cluster import hierarchy
from scipy.stats import beta

import numpy as np
import logging
import readline
import traceback
import os
import sys
import datetime

_logger = logging.getLogger(&#34;cnvpytor.viewer&#34;)


class Reader:
    def __init__(self, files):
        &#34;&#34;&#34; Class constructor opens cnvpytor files.

        Parameters
        ----------
        files : list of str
            List of cnvpytor filenames.

        &#34;&#34;&#34;
        self.io = [IO(f, ro=True) for f in files]


class Show(Reader):
    def ls(self):
        &#34;&#34;&#34; Prints to stdout content of all cnvpytor files.

        &#34;&#34;&#34;
        for i in self.io:
            i.ls()

    def meta(self):
        &#34;&#34;&#34; Prints to stdout meta tags of all cnvpytor files.

        &#34;&#34;&#34;
        for i in self.io:
            i.read_meta_attribute()

    def info(self, bin_sizes):
        &#34;&#34;&#34; Prints to stdout RD info for all cnvpytor files.
        Columns are following:
            filename
            mean read length, stdev of read length in %
            mean template length, stdev of template length in %
            for each bin_size (including 100 always):
                rd level and corresponding stdev for each chromosome type (autosomes, sex chromosomes and mitochondria)

        &#34;&#34;&#34;
        if 100 not in bin_sizes:
            bin_sizes = [100] + bin_sizes
        labels = [&#34;FILE&#34;, &#34;RL&#34;, &#34;dRL[%]&#34;, &#34;FL&#34;, &#34;dFL[%]&#34;]
        for bs in bin_sizes:
            labels.append(&#34;RD_AUTO_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_AUTO_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_GC_AUTO_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_GC_AUTO_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_XY_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_XY_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_GC_XY_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_GC_XY_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            if bs &lt;= 500:
                labels.append(&#34;RD_MT_&#34; + binsize_format(bs))
                labels.append(&#34;dRD_MT_&#34; + binsize_format(bs) + &#34;[%]&#34;)
                labels.append(&#34;RD_GC_MT_&#34; + binsize_format(bs))
                labels.append(&#34;dRD_CG_MT_&#34; + binsize_format(bs) + &#34;[%]&#34;)
        print((&#34;{:}\t{:}\t{:}\t{:}\t{:}\t&#34; + &#34;{:}\t&#34; * (len(labels) - 5)).format(*tuple(labels)))
        for i in self.io:
            rfd = i.get_signal(None, None, &#34;read frg dist&#34;)
            rd = np.sum(rfd, axis=1)
            fd = np.sum(rfd, axis=0)
            mrl = np.sum(rd * np.arange(rd.size)) / np.sum(rd)
            mfl = np.sum(fd * np.arange(fd.size)) / np.sum(fd)
            mrl2 = np.sum(rd * np.arange(rd.size) * np.arange(rd.size)) / np.sum(rd)
            mfl2 = np.sum(fd * np.arange(fd.size) * np.arange(fd.size)) / np.sum(fd)
            sdr = 100. * np.sqrt(mrl2 - mrl * mrl) / mrl
            sdf = 100. * np.sqrt(mfl2 - mfl * mfl) / mfl
            print(&#34;{:}\t{:.2f}\t{:.2f}\t{:.2f}\t{:.2f}\t&#34;.format(i.filename, mrl, sdr, mfl, sdf), end=&#34;&#34;)
            for bs in bin_sizes:
                for flag in [FLAG_AUTO, FLAG_SEX, FLAG_MT]:
                    if bs &lt;= 500 or not flag == FLAG_MT:
                        if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=flag):
                            stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=flag)
                            if stat[4] &gt; 0:
                                stat[5] /= stat[4] / 100.
                            print(&#34;{:.2f}\t{:.2f}\t&#34;.format(stat[4], stat[5]), end=&#34;&#34;)
                        else:
                            print(&#34;{:}\t{:}\t&#34;.format(&#34;-&#34;, &#34;-&#34;), end=&#34;&#34;)
                        if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=(flag | FLAG_GC_CORR)):
                            stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=(flag | FLAG_GC_CORR))
                            if stat[4] &gt; 0:
                                stat[5] /= stat[4] / 100.
                            print(&#34;{:.2f}\t{:.2f}\t&#34;.format(stat[4], stat[5]), end=&#34;&#34;)
                        else:
                            print(&#34;{:}\t{:}\t&#34;.format(&#34;-&#34;, &#34;-&#34;), end=&#34;&#34;)
            print()


class Figure(ViewParams):
    def __init__(self, params, force_agg=False):
        &#34;&#34;&#34; Class implements matplotlib frequently used figure manipulation and plot panels arrangement.

        Parameters
        ----------
        params : dict
            Params to be passed to ViewParam class

        &#34;&#34;&#34;
        if force_agg:
            import matplotlib
            matplotlib.use(&#34;Agg&#34;)
            import matplotlib.pyplot as plt
        ViewParams.__init__(self, params)
        self.fig = None
        self.fig_grid = None
        self.fig_sub_grid = None
        self.count = 0
        self.current = -1
        self.sg_current = -1

    def new_figure(self, panel_count, grid=&#34;auto&#34;, panel_size=None, title=None):
        &#34;&#34;&#34; Clear figure and create new plot layout.

        Parameters
        ----------
        panel_count : int
            Number of panels
        grid : str or (int, int)
            number of columns and rows (sx, sy) or &#34;auto&#34;
        panel_size : (float, float)
            size of a single panel (only when plots in file)

        &#34;&#34;&#34;
        if panel_size is None:
            panel_size = self.panel_size
        if grid == &#34;auto&#34;:
            grid = self.grid
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, dpi=self.dpi, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if title is not None:
            self.fig.suptitle(title, fontsize=16)
        sx, sy = self._get_grid(grid, panel_count)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(panel_size[1] * sy)
            self.fig.set_figwidth(panel_size[0] * sx)
        self.fig_grid = gridspec.GridSpec(sy, sx, hspace=self.margins[5], wspace=self.margins[4])
        self.current = -1
        self.sg_current = -1

    def new_subgrid(self, panel_count, grid=&#34;auto&#34;, hspace=0, wspace=0):
        if grid == &#34;auto&#34;:
            grid = self.subgrid
        sx, sy = self._get_grid(grid, panel_count)
        self.current += 1
        self.fig_sub_grid = gridspec.GridSpecFromSubplotSpec(sy, sx, subplot_spec=self.fig_grid[self.current],
                                                             wspace=wspace, hspace=hspace)
        self.sg_current = -1
        self.sg_current_ax = None

    def next_panel(self):
        &#34;&#34;&#34; Return axes of next panel

        Returns
        -------
        ax : matplotlib.axes.Axes
            Axes for a given panel
        &#34;&#34;&#34;
        self.current += 1
        return self.fig.add_subplot(self.fig_grid[self.current])

    def next_subpanel(self, sharex=False):
        &#34;&#34;&#34; Return axes of next sub panel

        Returns
        -------
        ax : matplotlib.axes.Axes
            Axes for a given panel
        &#34;&#34;&#34;
        self.sg_current += 1
        if self.sg_current == 0 or not sharex:
            self.sg_current_ax = self.fig.add_subplot(self.fig_sub_grid[self.sg_current])
        else:
            self.sg_current_ax = self.fig.add_subplot(self.fig_sub_grid[self.sg_current], sharex=self.sg_current_ax)
        return self.sg_current_ax

    def next_polar_panel(self):
        &#34;&#34;&#34; Return axes of next panel

        Returns
        -------
        ax : matplotlib.axes.Axes
            Axes for a given panel
        &#34;&#34;&#34;
        self.current += 1
        return self.fig.add_subplot(self.fig_grid[self.current], projection=&#34;polar&#34;)

    def get_panel(self, i):
        &#34;&#34;&#34; Returns axes of a i-th panel

        Parameters
        ----------
        i : int
            Panel number

        Returns
        -------
        ax : matplotlib.axes.Axes
            Axes for a given panel

        &#34;&#34;&#34;
        return self.fig.get_axes()[i]

    def _get_grid(self, grid, panel_count):
        if grid == &#34;auto&#34;:
            sx, sy = self._panels_shape(panel_count)
        elif grid == &#34;vertical&#34;:
            sx, sy = 1, panel_count
        elif grid == &#34;horizontal&#34;:
            sx, sy = panel_count, 1
        else:
            sx, sy = tuple(grid)
        return sx, sy

    def fig_show(self, add_sufix=True, suffix=&#34;&#34;):
        &#34;&#34;&#34; Plot figure. If output_filename is specified it will plot only into a file.

        Parameters
        ----------
        add_sufix : bool
            If true it will add sufix to output_filename in format prefix.sufix.count.extension
            where count is auto-incremented integer starting from 0 and
            prefix.extension is parsed from output_filename parameter.

        suffix : str
            Sufix used in filename.

        &#34;&#34;&#34;
        bottom, top, left, right, wspace, hspace = self.margins
        plt.subplots_adjust(bottom=bottom, top=top, wspace=wspace, hspace=hspace, left=left, right=right)
        if self.output_filename != &#34;&#34;:
            image_filename = self.output_filename
            if add_sufix:
                image_filename = self._image_filename(suffix)
            if image_filename is not None:
                try:
                    plt.savefig(image_filename, dpi=self.dpi)
                except:
                    _logger.warning(&#34;Figure is not saved due to an error!&#34;)
                plt.close(self.fig)
            else:
                _logger.warning(&#34;Figure is not saved!&#34;)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def _image_filename(self, suffix):
        parts = self.output_filename.split(&#34;.&#34;)
        if parts[-1] not in [&#34;png&#34;, &#34;pdf&#34;, &#34;jpg&#34;, &#34;eps&#34;, &#34;svg&#34;]:
            _logger.warning(&#34;File extension should be: .jpg, .png, .svg, .eps or .pdf&#34;)
            return None
        if suffix == &#34;&#34;:
            suffix = str(self.count).zfill(4)
        else:
            suffix += &#34;.&#34; + str(self.count).zfill(4)
        self.count += 1
        parts[-1] = suffix + &#34;.&#34; + parts[-1]
        return &#34;.&#34;.join(parts)

    @staticmethod
    def _panels_shape(n):
        sx, sy = 1, 1
        if n == 2:
            sy = 2
        elif n in [3, 4]:
            sx, sy = 2, 2
        elif n in [5, 6]:
            sx, sy = 2, 3
        elif n in [7, 8, 9]:
            sx, sy = 3, 3
        elif n in [10, 11, 12]:
            sx, sy = 3, 4
        elif n in [13, 14, 15, 16]:
            sx, sy = 4, 4
        elif n in [17, 18, 19, 20]:
            sx, sy = 4, 5
        elif n in [21, 22, 23, 24]:
            sx, sy = 4, 6
        else:
            while sx * sy &lt; n:
                sy += 1
                sx = int(2. * sy / 3 + 1.)
        return sx, sy


class Viewer(Show, Figure, HelpDescription):

    def __init__(self, files, params={}, force_agg=False, history_file_size=1000):
        &#34;&#34;&#34;

        Parameters
        ----------
        files : list of str
            List of cnvpytor filenames
        params : dict
            List of parameters different than default to be passed to ViewParams class.

        &#34;&#34;&#34;
        _logger.debug(&#34;Viewer class init: files [%s], params %s.&#34; % (&#34;, &#34;.join(files), str(params)))
        Figure.__init__(self, params, force_agg=force_agg)
        Show.__init__(self, files)
        self.history_file_size = history_file_size
        self.cnvpytor_dir = os.path.expanduser(&#39;~/.cnvpytor&#39;)
        self.save_history = False
        if os.path.exists(self.cnvpytor_dir):
            if os.access(self.cnvpytor_dir, os.W_OK):
                self.save_history = True
            if os.path.exists(self.cnvpytor_dir+&#34;/viewer.conf&#34;):
                conf = eval(open(self.cnvpytor_dir+&#34;/viewer.conf&#34;).read())
                for key in conf:
                    setattr(self,key,conf[key])

        self.io_gc = self.io[0]
        self.io_mask = self.io[0]
        self.reference_genome = None
        self.plot_files = list(range(len(files)))
        self.default[&#34;plot_files&#34;] = list(range(len(files)))
        if self.io[0].signal_exists(None, None, &#34;reference genome&#34;):
            rg_name = np.array(self.io[0].get_signal(None, None, &#34;reference genome&#34;)).astype(&#34;str&#34;)[0]
            self.reference_genome = Genome.reference_genomes[rg_name]
            if &#34;mask_file&#34; in Genome.reference_genomes[rg_name]:
                self.io_mask = IO(Genome.reference_genomes[rg_name][&#34;mask_file&#34;], ro=True, buffer=True)
            if &#34;gc_file&#34; in Genome.reference_genomes[rg_name]:
                self.io_gc = IO(Genome.reference_genomes[rg_name][&#34;gc_file&#34;], ro=True, buffer=True)

    def parse(self, command):
        current = &#34;regions&#34;
        regions = []

        for p in command:
            if p.isdigit() and (int(p) % 100) == 0:
                self.bin_size = int(p)
                if current == &#34;rd&#34;:
                    self.rd()
                if current == &#34;baf&#34;:
                    self.baf()
                if current == &#34;likelihood&#34;:
                    self.likelihood()
                elif current == &#34;manhattan&#34;:
                    self.global_plot()
                elif current == &#34;calls&#34;:
                    if len(self.callers) &gt; 0:
                        self.manhattan(plot_type=self.callers[0])
                elif current == &#34;stat&#34;:
                    self.stat(int(p))
                elif current == &#34;circular&#34;:
                    self.circular()
                elif current == &#34;regions&#34;:
                    self.multiple_regions(regions)
                    regions = []
            elif p == &#34;rdstat&#34;:
                self.stat()
            elif p == &#34;snp&#34;:
                self.snp()
            elif p in [&#34;rd&#34;, &#34;baf&#34;, &#34;manhattan&#34;, &#34;calls&#34;, &#34;stat&#34;, &#34;regions&#34;, &#34;likelihood&#34;, &#34;circular&#34;]:
                current = p
            elif current == &#34;regions&#34;:
                regions.append(p)
            else:
                current = p

    def plot_command(self, command):
        self.interactive = False
        self.parse(command)

    def prompt(self):
        self.interactive = True

        chromosomes = set({})
        for f in self.io:
            chromosomes = chromosomes.union(set(f.rd_chromosomes()))
            chromosomes = chromosomes.union(set(f.snp_chromosomes()))
        for c in chromosomes:
            self.command_tree[c] = None
        self.command_tree[&#34;set&#34;][&#34;style&#34;] = dict(zip(plt.style.available, [None] * len(plt.style.available)))
        if os.path.exists(self.cnvpytor_dir+&#34;/history&#34;):
            readline.read_history_file(self.cnvpytor_dir+&#34;/history&#34;)

        readline.parse_and_bind(&#34;tab: complete&#34;)
        completer = PromptCompleter(self.command_tree)
        readline.set_completer(completer.complete)
        quit = False
        try:
            while not quit:
                prompt_str = &#34;&#34;
                if os.isatty(sys.stdin.fileno()):
                    prompt_str = &#34;cnvpytor&gt; &#34;
                else:
                    self.interactive = False
                try:
                    line = raw_input(prompt_str)
                except NameError:
                    line = input(prompt_str)

                if line[0] == &#34;#&#34; or line[0] == &#34;&#34;:
                    continue

                if self.save_history and self.interactive:
                    readline.set_history_length(self.history_file_size)
                    readline.write_history_file(self.cnvpytor_dir+&#34;/history&#34;)

                pre = line.split(&#34;&gt;&#34;)
                f = pre[0].strip().split(&#34; &#34;)
                n = len(f)
                if len(line) == 0:
                    continue
                elif f[0] == &#34;quit&#34; or f[0] == &#34;exit&#34;:
                    quit = True
                elif line[0] == &#34;|&#34;:
                    try:
                        eval(compile(line[1:], &#39;&lt;string&gt;&#39;, &#39;single&#39;))
                    except Exception as e:
                        print(traceback.format_exc())
                elif f[0] == &#34;save&#34;:
                    if n &gt; 1:
                        try:
                            plt.savefig(f[1])
                        except ValueError:
                            _logger.warning(&#34;File extension should be: .jpg, .png, .svg, .eps or .pdf&#34;)
                        except:
                            _logger.warning(&#34;Figure is not saved due to an error!&#34;)

                elif f[0] in [&#34;draw&#34;, &#34;repaint&#34;, &#34;update&#34;]:
                    if n == 1:
                        self.fig.canvas.draw()
                elif f[0] == &#34;ls&#34;:
                    self.ls()
                elif f[0] == &#34;meta&#34;:
                    self.meta()
                elif f[0] == &#34;show&#34;:
                    if n == 1:
                        self.show()
                elif f[0] == &#34;set&#34;:
                    if n &gt; 1:
                        self.set(f[1], f[2:])
                elif f[0] == &#34;help&#34; and n &gt; 1:
                    self.help(f[1])
                elif f[0] == &#34;help&#34; and n == 1:
                    self.help(&#34;help&#34;)
                elif f[0] == &#34;unset&#34;:
                    if n &gt; 1:
                        self.unset(f[1])
                elif f[0] == &#34;genotype&#34;:
                    if n &gt; 1:
                        self.genotype_all([self.bin_size], f[1:], interactive=True)
                elif f[0] == &#34;snv&#34;:
                    if n == 2:
                        self.snp(callset=f[1])
                    elif n == 1:
                        self.snp(callset=&#34;default&#34;)
                elif f[0] == &#34;compare&#34;:
                    if n == 3:
                        self.compare(f[1], f[2], plot=self.plot)
                    elif n == 4:
                        self.compare(f[1], f[2], n_bins=int(f[3]), plot=self.plot)
                elif f[0] == &#34;info&#34;:
                    if n &gt; 1:
                        self.info(list(map(binsize_type, f[1:])))
                elif f[0] == &#34;print&#34;:
                    if f[1] == &#34;calls&#34;:
                        if self.print_filename == &#34;&#34;:
                            self.print_calls()
                        else:
                            self.print_calls_file()
                    elif f[1] == &#34;joint_calls&#34;:
                        self.print_simple_joint_calls()

                else:
                    try:
                        if f[0] not in [&#34;rdstat&#34;, &#34;snp&#34;]:
                            self.parse(f + [str(self.bin_size)])
                        else:
                            self.parse(f)
                        if len(pre) &gt; 1:
                            fns = pre[1].strip().split(&#34; &#34;)
                            if fns[0] != &#34;&#34;:
                                plt.savefig(fns[0], dpi=200)
                    except Exception as e:
                        print(traceback.format_exc())
        except (EOFError, KeyboardInterrupt):
            print()
            return

    def help(self, param):
        if param in self.param_help:
            print(self.param_help[param])
        else:
            print(&#34;\nUnknown parameter !\n&#34;)

    @staticmethod
    def set_style(style):
        if style in plt.style.available:
            plt.style.use(&#34;default&#34;)
            plt.style.use(style)

    def file_title(self, ix):
        if ix &lt; len(self.file_titles):
            return self.file_titles[ix]
        else:
            return self.io[ix].filename.split(&#34;/&#34;)[-1].replace(&#34;.pytor&#34;, &#34;&#34;)

    def show(self):
        print(&#34;\nParameters&#34;)
        for key in sorted(self.params.keys()):
            print(&#34;    * %s: %s&#34; % (key, str(self.params[key])))
            if key == &#34;plot_files&#34;:
                for i in range(len(self.io)):
                    print(&#34;            %d: %s&#34; % (i, self.io[i].filename))
        print()

    def stat(self, his_bin_size=100, return_image=False):
        plt.clf()
        auto = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_AUTO)
        sex = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_SEX)
        mt = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_MT) and (his_bin_size &lt; 1001)
        if not (auto or sex or mt):
            return
        cond = [auto, sex, mt]
        stat_list = []
        n_cols = sum(map(int, cond))
        ix = 1
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, figsize=(4 * n_cols, 8), dpi=90, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        for t, c, flag in zip([&#34;Autosomes&#34;, &#34;X/Y&#34;, &#34;Mitochondria&#34;], cond, [FLAG_AUTO, FLAG_SEX, FLAG_MT]):
            if c:
                stat = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD stat&#34;, flag)
                stat_list.append(stat)
                max_rd = int(stat[0])
                bin_size = int(stat[1])
                n_bins = int(stat[2])
                lim_rd = int(max(2 * stat[4], stat[4] + 3 * stat[5]))
                _logger.info(&#34;RD stat for %s: %.2f +- %.2f&#34; % (t, stat[4], stat[5]))
                if t == &#34;Mitochondria&#34; and auto:
                    _logger.info(&#34;RD stat for %s - number of mitochondria per cell: %.2f +- %.2f&#34; % (
                        t, 2 * stat[4] / stat_list[0][4],
                        2 * stat[5] / stat_list[0][4] + stat_list[0][5] * stat[4] / (
                                stat_list[0][4] * stat_list[0][4])))
                his_p = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD p dist&#34;, flag)
                his_u = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD u dist&#34;, flag)
                his_rd_gc = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD GC dist&#34;, flag)
                gc_corr = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;GC corr&#34;, flag)
                ax = plt.subplot(2, n_cols, ix)
                ax.set_xlabel(&#34;RD&#34;)
                ax.set_ylabel(&#34;GC [%]&#34;)
                ax.xaxis.set_ticklabels([])
                ax.set_title(t)
                his_rd_gc[0][0] = 0
                ax.imshow(his_rd_gc[:lim_rd // bin_size, :].T, aspect=&#34;auto&#34;, interpolation=&#39;nearest&#39;, origin=&#39;lower&#39;)
                ax.plot(gc_corr * stat[4] / bin_size, range(101), &#34;w-&#34;)

                ax = plt.subplot(2, n_cols, ix + n_cols)
                ax.set_ylabel(&#34;Normalised distribution&#34;)
                ax.set_xlabel(&#34;RD&#34;)
                ax.set_xlim([0, lim_rd])
                # ax.set_ylim([0, 1.1])
                bins = range(0, max_rd, bin_size)
                x = np.arange(0, max_rd // bin_size * bin_size, 0.1 * bin_size)
                plt.plot(x, normal(x, 1, stat[4], stat[5]), &#34;g-&#34;)
                x = np.array(bins)
                plt.plot(x[:len(his_u)], his_u / stat[3], &#34;y*&#34;)
                plt.plot(x[:len(his_p)], his_p / stat[3], &#34;b*&#34;)
                ix += 1
        plt.subplots_adjust(bottom=0.08, top=0.95, wspace=0.25, hspace=0, left=0.05 * 3 / n_cols, right=0.95)
        if return_image:
            self.fig.canvas.draw()
            import PIL
            pil_image = PIL.Image.frombytes(&#39;RGB&#39;, self.fig.canvas.get_width_height(),
                                            self.fig.canvas.tostring_rgb())
            return pil_image
        elif self.output_filename != &#34;&#34;:
            plt.savefig(self._image_filename(&#34;stat&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def rd(self):
        bin_size = self.bin_size
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            rd_chr = self.io[self.plot_file].rd_chromosome_name(c)
            if self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                    self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                    (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append((rd_chr, l))
        self.new_figure(panel_count=len(chroms))
        for c, l in chroms:
            flag_rd = FLAG_USEMASK if self.rd_use_mask else 0
            mean, stdev = self.io[self.plot_file].rd_normal_level(bin_size, flag_rd | FLAG_GC_CORR)
            his_p = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
            his_p_corr = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            his_p_seg = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD partition&#34;, flag_rd | FLAG_GC_CORR)
            his_p_call = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
            his_p_mosaic_seg = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                                  flag_rd | FLAG_GC_CORR)
            his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
            his_p_mosaic_call = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                                   flag_rd | FLAG_GC_CORR)
            his_p_mosaic_seg_2d = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic segments 2d&#34;,
                                                                     flag_rd | FLAG_GC_CORR)
            his_p_mosaic_seg_2d = segments_decode(his_p_mosaic_seg_2d)
            his_p_mosaic_call_2d = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic call 2d&#34;,
                                                                      flag_rd | FLAG_GC_CORR)
            his_p_mosaic = np.zeros_like(his_p) * np.nan
            if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call and (
                    &#34;rd_mosaic&#34; in self.callers):
                for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                    for segi in seg:
                        his_p_mosaic[segi] = lev
            his_p_mosaic_2d = np.zeros_like(his_p) * np.nan
            if his_p_mosaic_call_2d is not None and len(his_p_mosaic_call_2d) &gt; 0 and self.rd_call and (
                    &#34;combined_mosaic&#34; in self.callers):
                for seg, lev in zip(list(his_p_mosaic_seg_2d), list(his_p_mosaic_call_2d[0])):
                    for segi in seg:
                        his_p_mosaic_2d[segi] = lev
            ax = self.next_panel()
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // bin_size, 10e6 // bin_size), minor=[])
            if (self.rd_range[1] - self.rd_range[0]) &lt; 30:
                ax.yaxis.set_ticks(np.arange(int(self.rd_range[0]), int(self.rd_range[1] + 1), 1) * mean / 2,
                                   minor=[])
            ax.set_ylim([self.rd_range[0] * mean / 2, self.rd_range[1] * mean / 2])
            n_bins = l // bin_size
            ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
            ax.grid()
            if self.rd_raw:
                plt.step(his_p, self.rd_colors[0])
            if self.rd_corrected:
                plt.step(his_p_corr, self.rd_colors[1])
            if his_p_seg is not None and len(his_p_seg) &gt; 0 and self.rd_partition:
                plt.step(his_p_seg, self.rd_colors[2])
            if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call:
                plt.step(his_p_call, self.rd_colors[3])
            if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call and (
                    &#34;rd_mosaic&#34; in self.callers):
                plt.step(his_p_mosaic, self.rd_colors[4])
            if his_p_mosaic_call_2d is not None and len(his_p_mosaic_call_2d) &gt; 0 and self.rd_call and (
                    &#34;combined_mosaic&#34; in self.callers):
                plt.step(his_p_mosaic_2d, self.rd_colors[5])
        self.fig_show(suffix=&#34;rd&#34;)

    def rd_diff(self, file1, file2):
        bin_size = self.bin_size
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            rd_chr = self.io[self.plot_file].rd_chromosome_name(c)
            if self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                    self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                    (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append((rd_chr, l))
        self.new_figure(panel_count=len(chroms))
        for c, l in chroms:
            flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
            stat1 = self.io[file1].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
            stat2 = self.io[file2].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
            if stat1 is None:
                _logger.error(
                    &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[file1].filename))
                return
            if stat2 is None:
                _logger.error(
                    &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[file2].filename))
                return
            flag_rd = (FLAG_USEMASK if self.rd_use_mask else 0)
            his_p_corr1 = self.io[file1].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            his_p_corr2 = self.io[file2].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            ax = self.next_panel()
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            if (self.rd_range[1] - self.rd_range[0]) &lt; 30:
                ax.yaxis.set_ticks(np.arange(int(self.rd_range[0]), int(self.rd_range[1] + 1), 1) * mean / 2,
                                   minor=[])
            ax.yaxis.set_ticks(np.arange(0, 2, 0.25), minor=[])
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // bin_size, 10e6 // bin_size), minor=[])
            ax.set_ylim([0, 1])
            n_bins = l // bin_size
            ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
            ax.grid()

            plt.step(np.abs(his_p_corr1 / stat1[4] - his_p_corr2 / stat2[4]), &#34;k&#34;)
        self.fig_show(suffix=&#34;rd_diff&#34;)

    def likelihood(self):
        bin_size = self.bin_size
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0)
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        chroms = []
        if self.reference_genome is None:
            chroms = self.io[self.plot_file].snp_chromosomes()
        else:
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
                if self.io[self.plot_file].signal_exists(snp_chr, bin_size, &#34;SNP likelihood&#34;, snp_flag) and (
                        Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                    chroms.append(snp_chr)
        self.new_figure(panel_count=len(chroms))
        for c in chroms:
            likelihood = self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
            img = np.array(likelihood).transpose()
            ax = self.next_panel()
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.imshow(img, aspect=&#39;auto&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.xaxis.set_ticks(np.arange(0, likelihood.shape[0], 50), minor=[])
            ax.set_xlim([0, likelihood.shape[0]])
            if self.snp_call and (&#34;baf_mosaic&#34; in self.callers):
                likelihood = self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                segments = segments_decode(
                    self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
                call_pos = []
                call_i1 = []
                call_i2 = []
                call_c = []
                for s, lh in zip(segments, likelihood):
                    i1, i2, p = likelihood_pixels_pval(lh)
                    if i1 != i2 and len(s) &gt; self.min_segment_size:
                        alpha = -np.log(p + 1e-40) / self.contrast
                        if alpha &gt; 1:
                            alpha = 1
                        for pos in s:
                            call_pos.append(pos)
                            call_i1.append(min(i1, i2))
                            call_i2.append(max(i1, i2))
                            color = colors.to_rgb(self.lh_colors[0]) + (alpha,)
                            call_c.append(color)
                plt.scatter(call_pos, call_i1, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                            marker=self.lh_marker)
                plt.scatter(call_pos, call_i2, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                            marker=self.lh_marker)
            if self.snp_call and (&#34;combined_mosaic&#34; in self.callers):
                likelihood = self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood call 2d&#34;, snp_flag)
                segments = segments_decode(
                    self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood segments 2d&#34;, snp_flag))
                call_pos = []
                call_i1 = []
                call_i2 = []
                call_c = []
                for s, lh in zip(segments, likelihood):
                    i1, i2, p = likelihood_pixels_pval(lh)
                    if i1 != i2 and len(s) &gt; self.min_segment_size:
                        alpha = -np.log(p + 1e-40) / self.contrast
                        if alpha &gt; 1:
                            alpha = 1
                        for pos in s:
                            call_pos.append(pos)
                            call_i1.append(min(i1, i2))
                            call_i2.append(max(i1, i2))
                            color = colors.to_rgb(self.lh_colors[1]) + (alpha,)
                            call_c.append(color)
                plt.scatter(call_pos, call_i1, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                            marker=self.lh_marker)
                plt.scatter(call_pos, call_i2, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                            marker=self.lh_marker)
        self.fig_show(suffix=&#34;likelihood&#34;)

    def baf(self):
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0)
        chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
            if self.io[self.plot_file].signal_exists(snp_chr, self.bin_size, &#34;SNP baf&#34;, snp_flag) and \
                    self.io[self.plot_file].signal_exists(snp_chr, self.bin_size, &#34;SNP maf&#34;, snp_flag) and \
                    self.io[self.plot_file].signal_exists(snp_chr, self.bin_size, &#34;SNP i1&#34;, snp_flag) and \
                    self.io[self.plot_file].signal_exists(snp_chr, self.bin_size, &#34;SNP i2&#34;, snp_flag) and \
                    (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append((snp_chr, l))

        self.new_figure(panel_count=len(chroms))
        for c, l in chroms:
            baf = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP baf&#34;, snp_flag)
            maf = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP maf&#34;, snp_flag)
            i1 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP i1&#34;, snp_flag)
            i2 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP i2&#34;, snp_flag)

            ax = self.next_panel()
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // self.bin_size, 10e6 // self.bin_size), minor=[])
            ax.set_ylim([0, 1])
            n_bins = l // self.bin_size
            ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
            ax.grid()
            ax.step(baf, self.baf_colors[0])
            ax.step(maf, self.baf_colors[1])
            ax.step(i1, self.baf_colors[2])
        self.fig_show(suffix=&#34;baf&#34;)

    def snp(self, plot_gt=None, plot_pmask=None, callset=None):
        if plot_pmask is None:
            plot_pmask = [0, 1]
        if plot_gt is None:
            plot_gt = [0, 1, 2, 3]
        chroms = []
        if self.reference_genome is None:
            chroms = self.io[self.plot_file].snp_chromosomes()
        else:
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
                if callset is None:
                    if self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP pos&#34;, 0) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP desc&#34;, 0) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP counts&#34;, 0) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP qual&#34;, 0) and \
                            (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append(snp_chr)
                else:
                    if self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP pos&#34;, 0, name=callset) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP desc&#34;, 0,
                                                                  name=callset) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP counts&#34;, 0,
                                                                  name=callset) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP qual&#34;, 0,
                                                                  name=callset) and \
                            (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append(snp_chr)
        self.new_figure(panel_count=len(chroms))
        for c in chroms:
            pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_file].read_snp(c, callset=callset)
            hpos = []
            baf = []
            color = []
            qlpha = 0.7
            for i in range(len(pos)):
                if (nref[i] + nalt[i]) != 0:
                    if (gt[i] % 4 in plot_gt) and ((flag[i] &gt;&gt; 1) in plot_pmask):
                        hpos.append(pos[i])
                        if gt[i] % 4 != 2:
                            baf.append(1.0 * nalt[i] / (nref[i] + nalt[i]))
                        else:
                            baf.append(1.0 * nref[i] / (nref[i] + nalt[i]))
                        if self.snp_alpha_P:
                            alpha = None
                            color.append(colors.to_rgba(self.snp_colors[(gt[i] % 4) * 2 + 1], (flag[i] &gt;&gt; 1) * 0.4))
                        else:
                            color.append(self.snp_colors[(gt[i] % 4) * 2 + (flag[i] &gt;&gt; 1)])

            ax = self.next_panel()
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
            l = max(pos)
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6), 10e6), minor=[])
            ax.set_ylim([0., 1.])
            ax.set_xlim([-0.05 * l, 1.05 * l])
            ax.grid()
            if self.markersize == &#34;auto&#34;:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=0.7)
            else:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=0.7)
        self.fig_show(suffix=&#34;snp&#34;)

    def get_calls(self):
        bin_size = self.bin_size
        n = len(self.plot_files)
        ix = self.plot_files
        if self.annotate:
            annotator = Annotator(self.reference_genome)
        ret = []
        for caller in self.callers:
            if caller == &#34;rd_mean_shift&#34;:
                for i in range(n):
                    io = self.io[ix[i]]
                    chroms = io.rd_chromosomes()
                    for c in chroms:
                        if (c in self.chrom) or len(self.chrom) == 0:
                            flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                            if io.signal_exists(c, bin_size, &#34;calls&#34;, flag):
                                calls = io.read_calls(c, bin_size, &#34;calls&#34;, flag)
                                for call in calls:
                                    if in_interval(call[&#34;size&#34;], self.size_range) \
                                            and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                            and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                            and in_interval(call[&#34;Q0&#34;], self.Q0_range) \
                                            and in_interval(call[&#34;dG&#34;], self.dG_range):
                                        type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;

                                        row = [self.file_title(ix[i]), caller, type, c, call[&#34;start&#34;], call[&#34;end&#34;],
                                               call[&#34;size&#34;], call[&#34;cnv&#34;], call[&#34;p_val&#34;], call[&#34;p_val_2&#34;],
                                               call[&#34;p_val_3&#34;], call[&#34;p_val_4&#34;], call[&#34;Q0&#34;], call[&#34;pN&#34;], call[&#34;dG&#34;]]
                                        if self.annotate:
                                            row.append(annotator.get_info(&#34;%s:%d-%d&#34; % (c, call[&#34;start&#34;], call[&#34;end&#34;])))
                                        ret.append(row)
            elif caller == &#34;combined_mosaic&#34;:
                for i in range(n):
                    io = self.io[ix[i]]
                    chroms = io.rd_chromosomes()
                    for c in chroms:
                        if (c in self.chrom) or len(self.chrom) == 0:
                            flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR | \
                                   (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
                            if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                                calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)
                                for call in calls:
                                    if in_interval(call[&#34;size&#34;], self.size_range) \
                                            and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                            and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                            and in_interval(call[&#34;Q0&#34;], self.Q0_range):

                                        if n &gt; 1:
                                            print(&#34;%s\t&#34; % self.file_title(ix[i]), end=&#34;&#34;)
                                        if len(self.callers) &gt; 1:
                                            print(&#34;%s\t&#34; % caller, end=&#34;&#34;)
                                        keys = [&#34;start&#34;, &#34;end&#34;, &#34;size&#34;, &#34;cnv&#34;, &#34;p_val&#34;, &#34;lh_del&#34;, &#34;lh_loh&#34;,
                                                &#34;lh_dup&#34;, &#34;Q0&#34;, &#34;pN&#34;, &#34;pNS&#34;, &#34;pP&#34;, &#34;bins&#34;, &#34;baf&#34;,
                                                &#34;rd_p_val&#34;, &#34;baf_p_val&#34;, &#34;segment&#34;, &#34;hets&#34;, &#34;homs&#34;]
                                        type = {-1: &#34;deletion&#34;, 0: &#34;cnnloh&#34;, 1: &#34;duplication&#34;}[call[&#34;type&#34;]]
                                        row = [self.file_title(i), caller, type, c] + [call[k] for k in keys]
                                        for m in range(2):
                                            row += call[&#34;models&#34;][m]

                                        if self.annotate:
                                            row.append(annotator.get_info(&#34;%s:%d-%d&#34; % (data[3], data[4], data[5])))
                                        ret.append(row)
        return ret

    def print_calls_file(self):
        format = self.print_filename.split(&#34;.&#34;)[-1]
        calls = self.get_calls()
        if self.print_filename == &#34;&#34;:
            for call in calls:
                print(*call, sep=&#34;\t&#34;)
        elif format == &#34;tsv&#34;:
            with open(self.print_filename, &#39;w&#39;) as f:
                for call in calls:
                    print(*call, sep=&#34;\t&#34;, file=f)
        elif format == &#34;xlsx&#34;:
            import xlsxwriter
            workbook = xlsxwriter.Workbook(self.print_filename)
            files_callers = []
            sheets = {}
            rix = {}
            for call in calls:
                caller = call[1]
                fc = call[0] + &#34; (&#34; + caller + &#34;)&#34;
                sfc = call[0][:25] + &#34; &#34; + ({&#34;rd_mean_shift&#34;: &#34;ms&#34;, &#34;combined_mosaic&#34;: &#34;2d&#34;}[caller])
                if fc not in files_callers:
                    sheets[fc] = workbook.add_worksheet(sfc)
                    rix[fc] = 0
                    files_callers.append(fc)
            for call in calls:
                caller = call[1]
                fc = call[0] + &#34; (&#34; + caller + &#34;)&#34;
                cix = 0
                for f in call[2:]:
                    sheets[fc].write(rix[fc], cix, f)
                    cix += 1
                rix[fc] += 1
            workbook.close()
        elif format == &#34;vcf&#34;:
            samples = []
            for call in calls:
                sample = call[0]
                if sample not in samples:
                    samples.append(sample)
            header = &#34;&#34;&#34;##fileformat=VCFv4.1
##fileDate={date}
##reference={rg}
##source=CNVpytor
##INFO=&lt;ID=END,Number=1,Type=Integer,Description=&#34;End position of the variant described in this record&#34;&gt;
##INFO=&lt;ID=IMPRECISE,Number=0,Type=Flag,Description=&#34;Imprecise structural variation&#34;&gt;
##INFO=&lt;ID=SVLEN,Number=1,Type=Integer,Description=&#34;Difference in length between REF and ALT alleles&#34;&gt;
##INFO=&lt;ID=SVTYPE,Number=1,Type=String,Description=&#34;Type of structural variant&#34;&gt;
##INFO=&lt;ID=pytorRD,Number=1,Type=Float,Description=&#34;Normalized RD&#34;&gt;
##INFO=&lt;ID=pytorP1,Number=1,Type=Float,Description=&#34;e-val by t-test&#34;&gt;
##INFO=&lt;ID=pytorP2,Number=1,Type=Float,Description=&#34;e-val by Gaussian tail&#34;&gt;
##INFO=&lt;ID=pytorP3,Number=1,Type=Float,Description=&#34;e-val by t-test (middle)&#34;&gt;
##INFO=&lt;ID=pytorP4,Number=1,Type=Float,Description=&#34;e-val by Gaussian tail (middle)&#34;&gt;
##INFO=&lt;ID=pytorQ0,Number=1,Type=Float,Description=&#34;Fraction of reads with 0 mapping quality&#34;&gt;
##INFO=&lt;ID=pytorPN,Number=1,Type=Integer,Description=&#34;Fraction of N bases&#34;&gt;
##INFO=&lt;ID=pytorDG,Number=1,Type=Integer,Description=&#34;Distance to nearest gap in reference genome&#34;&gt;
##INFO=&lt;ID=pytorCL,Number=1,Type=Integer,Description=&#34;Caller method&#34;&gt;
##INFO=&lt;ID=SAMPLES,Number=.,Type=String,Description=&#34;Sample genotyped to have the variant&#34;&gt;
##ALT=&lt;ID=DEL,Description=&#34;Deletion&#34;&gt;
##ALT=&lt;ID=DUP,Description=&#34;Duplication&#34;&gt;
##ALT=&lt;ID=LOH,Description=&#34;Copy number neutral loss of heterozygosity&#34;&gt;
##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=&#34;Genotype&#34;&gt;;
##FORMAT=&lt;ID=CN,Number=1,Type=Integer,Description=&#34;Copy number genotype for imprecise events&#34;&gt;
#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\t{samples}&#34;&#34;&#34;
            if self.reference_genome:
                rg = self.reference_genome[&#34;name&#34;]
            else:
                rg = &#34;unknown&#34;
            header = header.format(date=datetime.date.today().strftime(&#34;%Y-%m-%d&#34;), rg=rg, samples=&#34;\t&#34;.join(samples))
            ii = 0
            with open(self.print_filename, &#39;w&#39;) as f:
                print(header, file=f)
                for call in calls:
                    ii += 1
                    id = &#34;CNVpytor_&#34; + {&#34;deletion&#34;: &#34;del&#34;, &#34;duplication&#34;: &#34;dup&#34;, &#34;cnnloh&#34;: &#34;loh&#34;}[call[2]] + str(ii)
                    alt = {&#34;deletion&#34;: &#34;&lt;DEL&gt;&#34;, &#34;duplication&#34;: &#34;&lt;DUP&gt;&#34;, &#34;cnnloh&#34;: &#34;&lt;LOH&gt;&#34;}[call[2]]
                    info = &#34;END=&#34; + str(int(call[5])) + &#34;;IMPRECISE;SVLEN=&#34; + str(int(call[6])) + &#34;;SVTYPE=&#34; + alt[1:4]
                    info += &#34;;pytorRD=&#34; + str(call[7])
                    info += &#34;;pytorP1=&#34; + str(call[8])
                    info += &#34;;pytorP2=&#34; + str(call[9])
                    info += &#34;;pytorP3=&#34; + str(call[10])
                    info += &#34;;pytorP4=&#34; + str(call[11])
                    info += &#34;;pytorQ0=&#34; + str(call[12])
                    info += &#34;;pytorPN=&#34; + str(call[13])
                    info += &#34;;pytorDG=&#34; + str(call[14])
                    info += &#34;;pytorCL=&#34; + call[1]
                    format = &#34;GT:CN&#34;
                    row = [call[3], int(call[4]), id, &#34;.&#34;, alt, &#34;.&#34;, &#34;PASS&#34;, info, format]
                    for sample in samples:
                        if sample == call[0]:
                            if call[2] == &#34;deletion&#34; and call[7] &lt; 0.25:
                                row.append(&#34;1/1:0&#34;)
                            elif call[2] == &#34;deletion&#34; and call[7] &gt; 0.25:
                                row.append(&#34;0/1:0&#34;)
                            elif call[2] == &#34;duplication&#34; and call[7] &lt;= 1.75:
                                row.append(&#34;0/1:2&#34;)
                            elif call[2] == &#34;duplication&#34; and call[7] &gt; 1.75 and call[7] &lt;= 2.25:
                                row.append(&#34;1/1:2&#34;)
                            elif call[2] == &#34;duplication&#34; and call[7] &gt; 2.25:
                                row.append(&#34;./1:%.2f&#34; % call[7])
                            else:
                                row.append(&#34;./.:.&#34;)
                        else:
                            row.append(&#34;./.:.&#34;)
                    print(*row, sep=&#34;\t&#34;, file=f)
        if self.plot:
            for call in calls:
                plot_start = call[4] - call[6]
                if plot_start &lt; 0:
                    plot_start = 0
                plot_end = call[5] + call[6]
                self.multiple_regions([&#34;%s:%d-%d&#34; % (c, plot_start, plot_end)])

    def print_calls(self):
        bin_size = self.bin_size
        n = len(self.plot_files)
        ix = self.plot_files
        if self.annotate:
            annotator = Annotator(self.reference_genome)
        for caller in self.callers:
            if caller == &#34;rd_mean_shift&#34;:
                for i in range(n):
                    io = self.io[ix[i]]
                    chroms = io.rd_chromosomes()
                    for c in chroms:
                        if (c in self.chrom) or len(self.chrom) == 0:
                            flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                            if io.signal_exists(c, bin_size, &#34;calls&#34;, flag):
                                calls = io.read_calls(c, bin_size, &#34;calls&#34;, flag)
                                for call in calls:
                                    if in_interval(call[&#34;size&#34;], self.size_range) \
                                            and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                            and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                            and in_interval(call[&#34;Q0&#34;], self.Q0_range) \
                                            and in_interval(call[&#34;dG&#34;], self.dG_range):
                                        type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;
                                        if n &gt; 1:
                                            print(&#34;%s\t&#34; % self.file_title(i), end=&#34;&#34;)
                                        if len(self.callers) &gt; 1:
                                            print(&#34;%s\t&#34; % caller, end=&#34;&#34;)
                                        print(&#34;%s\t%s:%d-%d\t%d\t%.4f\t%e\t%e\t%e\t%e\t%.4f\t%.4f\t%d\t&#34; % (
                                            type, c, call[&#34;start&#34;], call[&#34;end&#34;], call[&#34;size&#34;], call[&#34;cnv&#34;],
                                            call[&#34;p_val&#34;],
                                            call[&#34;p_val_2&#34;], call[&#34;p_val_3&#34;], call[&#34;p_val_4&#34;], call[&#34;Q0&#34;], call[&#34;pN&#34;],
                                            call[&#34;dG&#34;]), end=&#34;&#34;)
                                        if self.annotate:
                                            print(&#34;\t%s&#34; % annotator.get_info(
                                                &#34;%s:%d-%d&#34; % (c, call[&#34;start&#34;], call[&#34;end&#34;])))
                                        else:
                                            print()
                                        if self.plot:
                                            plot_start = call[&#34;start&#34;] - call[&#34;size&#34;]
                                            if plot_start &lt; 0:
                                                plot_start = 0
                                            plot_end = call[&#34;end&#34;] + call[&#34;size&#34;]
                                            self.multiple_regions([&#34;%s:%d-%d&#34; % (c, plot_start, plot_end)])
            elif caller == &#34;combined_mosaic&#34;:
                for i in range(n):
                    io = self.io[ix[i]]
                    chroms = io.rd_chromosomes()
                    for c in chroms:
                        if (c in self.chrom) or len(self.chrom) == 0:
                            flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR | \
                                   (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
                            if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                                calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)
                                for call in calls:
                                    if in_interval(call[&#34;size&#34;], self.size_range) \
                                            and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                            and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                            and in_interval(call[&#34;Q0&#34;], self.Q0_range):
                                        type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;
                                        if n &gt; 1:
                                            print(&#34;%s\t&#34; % self.file_title(i), end=&#34;&#34;)
                                        if len(self.callers) &gt; 1:
                                            print(&#34;%s\t&#34; % caller, end=&#34;&#34;)
                                        keys = [&#34;start&#34;, &#34;end&#34;, &#34;size&#34;, &#34;cnv&#34;, &#34;p_val&#34;, &#34;lh_del&#34;, &#34;lh_loh&#34;,
                                                &#34;lh_dup&#34;, &#34;Q0&#34;, &#34;pN&#34;, &#34;pNS&#34;, &#34;pP&#34;, &#34;bins&#34;, &#34;baf&#34;,
                                                &#34;rd_p_val&#34;, &#34;baf_p_val&#34;, &#34;segment&#34;, &#34;hets&#34;, &#34;homs&#34;]
                                        type = {-1: &#34;deletion&#34;, 0: &#34;cnnloh&#34;, 1: &#34;duplication&#34;}[call[&#34;type&#34;]]
                                        data = [type, c] + [call[k] for k in keys]
                                        for m in range(2):
                                            data += call[&#34;models&#34;][m]

                                        print((&#34;%s\t%s:%d-%d\t%d\t%.4f\t%e\t%e\t%e\t%e&#34; + \
                                               &#34;\t%.4f\t%.4f\t%.4f\t%.4f\t&#34; + &#34;%d\t%d\t%.4f\t%e\t%e\t%d\t%d\t%d\t&#34; + \
                                               &#34;CN%d/CN%d\t%e\t%.4f\t%d\tCN%d/CN%d\t%e\t%.4f&#34;) % tuple(data), end=&#34;&#34;)
                                        if self.annotate:
                                            print(&#34;\t%s&#34; % annotator.get_info(&#34;%s:%d-%d&#34; % (data[1], data[2], data[3])))
                                        else:
                                            print()
                                        if self.plot:
                                            plot_start = call[&#34;start&#34;] - call[&#34;size&#34;]
                                            if plot_start &lt; 0:
                                                plot_start = 0
                                            plot_end = call[&#34;end&#34;] + call[&#34;size&#34;]
                                            self.multiple_regions([&#34;%s:%d-%d&#34; % (c, plot_start, plot_end)])

    def print_simple_joint_calls(self):

        bin_size = self.bin_size
        n = len(self.plot_files)
        if n == 0:
            return
        ix = self.plot_files
        format = self.print_filename.split(&#34;.&#34;)[-1]
        if format == &#34;tsv&#34;:
            f = open(self.print_filename, &#39;w&#39;)
        elif format == &#34;xlsx&#34;:
            import xlsxwriter
            if os.path.exists(self.print_filename):
                os.remove(self.print_filename)
            workbook = xlsxwriter.Workbook(self.print_filename)
            sheet = workbook.add_worksheet(&#34;merged_calls&#34;)
            header = [&#34;TYPE&#34;, &#34;REGION&#34;, &#34;SIZE&#34;]
            for i in range(n):
                header.append(self.file_title(ix[i]))
            if self.annotate:
                header.append(&#34;GENES&#34;)
            styleh = workbook.add_format({&#39;bold&#39;: True, &#39;font_color&#39;: &#39;white&#39;})
            styleh.set_pattern(1)  # This is optional when using a solid fill.
            styleh.set_bg_color(&#39;#555555&#39;)
            styleh2 = workbook.add_format({&#39;bold&#39;: True, &#39;font_color&#39;: &#39;white&#39;})
            styleh2.set_pattern(1)  # This is optional when using a solid fill.
            styleh2.set_bg_color(&#39;#555555&#39;)
            styleh2.set_rotation(75)
            style_r = workbook.add_format()
            style_r.set_pattern(1)  # This is optional when using a solid fill.
            style_r.set_bg_color(&#39;red&#39;)
            style_g = workbook.add_format()
            style_g.set_pattern(1)  # This is optional when using a solid fill.
            style_g.set_bg_color(&#39;green&#39;)
            style_size = workbook.add_format({&#39;num_format&#39;: &#39;#,##0&#39;})
            style_cn = workbook.add_format({&#39;num_format&#39;: &#39;0&#39;})
            style_cn_b = workbook.add_format({&#39;num_format&#39;: &#39;0&#39;, &#39;bold&#39;: True})
            sheet.set_column(0, 0, 10)
            sheet.set_column(1, 1, 22)
            sheet.set_column(2, 2, 10)
            if self.annotate:
                sheet.set_column(len(header) - 1, len(header) - 1, 100)

            for col, val in enumerate(header):
                if col &gt; 2 and col &lt; len(header) - int(self.annotate):
                    sheet.write(0, col, val, styleh2)
                else:
                    sheet.write(0, col, val, styleh)
            ri = 0
        if self.annotate:
            annotator = Annotator(self.reference_genome)
        chroms = self.io[ix[0]].rd_chromosomes()
        for c in chroms:
            if (c in self.chrom) or len(self.chrom) == 0:
                flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                calls = [list(filter(lambda call: in_interval(call[&#34;size&#34;], self.size_range) \
                                                  and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                                  and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                                  and in_interval(call[&#34;Q0&#34;], self.Q0_range) \
                                                  and in_interval(call[&#34;dG&#34;], self.dG_range),
                                     self.io[ix[i]].read_calls(c, bin_size, &#34;calls&#34;, flag))) for i in range(n)]
                pointers = [0] * n
                while any([pointers[i] &lt; len(calls[i]) for i in range(n)]):
                    starts = [calls[i][pointers[i]][&#34;start&#34;] if pointers[i] &lt; len(calls[i]) else np.inf for i in
                              range(n)]
                    mini = starts.index(min(starts))
                    maxend = 0
                    toupdate = []
                    minend = calls[mini][pointers[mini]][&#34;end&#34;]
                    maxstart = 0
                    files = []
                    types = []
                    cns = []
                    for i in range(n):
                        if (pointers[i] &lt; len(calls[i])) and ((min(calls[i][pointers[i]][&#34;end&#34;],
                                                                   calls[mini][pointers[mini]][&#34;end&#34;]) -
                                                               calls[i][pointers[i]][&#34;start&#34;]) &gt; (
                                                                      0.5 * calls[mini][pointers[mini]][&#34;size&#34;])) \
                                and ((min(calls[i][pointers[i]][&#34;end&#34;],
                                          calls[mini][pointers[mini]][&#34;end&#34;]) -
                                      calls[i][pointers[i]][&#34;start&#34;]) &gt; (
                                             0.5 * (calls[i][pointers[i]][&#34;end&#34;] - calls[i][pointers[i]][&#34;start&#34;]))):
                            toupdate.append(i)
                            call = calls[i][pointers[i]]
                            if call[&#34;end&#34;] &gt; maxend:
                                maxend = call[&#34;end&#34;]
                            if call[&#34;end&#34;] &lt; minend:
                                minend = call[&#34;end&#34;]
                            if call[&#34;start&#34;] &gt; maxstart:
                                maxstart = call[&#34;start&#34;]
                            type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;
                            types.append(type)
                            files.append(i)
                            cns.append(int(call[&#34;cnv&#34;] * 2))
                    type = max(set(types), key=types.count)
                    data = [type, c, maxstart, minend, minend - maxstart + 1]
                    genotypes = [
                        self.genotype([bin_size], &#34;%s:%d-%d&#34; % (c, maxstart, minend), file_index=ix[i], p_val=True)[0]
                        for i
                        in range(n)]
                    copynumbers = [c[3] for c in genotypes]
                    if np.all([np.abs(c - np.round(c)) &lt; 0.25 for c in copynumbers]) or True:
                        if self.print_filename == &#34;&#34;:
                            print((&#34;%s\t%s:%d-%d\t%d&#34; + n * &#34;\t%.2f&#34;) % tuple(data + copynumbers), end=&#34;&#34;)
                            print(&#34;\t%s&#34; % str(files), end=&#34;&#34;)
                            if self.annotate:
                                print(&#34;\t%s&#34; % annotator.get_info(&#34;%s:%d-%d&#34; % (c, maxstart, minend)))
                            else:
                                print()
                        elif format == &#34;tsv&#34;:
                            print((&#34;%s\t%s:%d-%d\t%d&#34; + n * &#34;\t%.2f&#34;) % tuple(data + copynumbers), end=&#34;&#34;, file=f)
                            print(&#34;\t%s&#34; % str(files), end=&#34;&#34;, file=f)
                            if self.annotate:
                                print(&#34;\t%s&#34; % annotator.get_info(&#34;%s:%d-%d&#34; % (c, maxstart, minend)), file=f)
                            else:
                                print(file=f)
                        elif format == &#34;xlsx&#34;:
                            ri += 1
                            if type == &#34;deletion&#34;:
                                sheet.write(ri, 0, data[0], style_r)
                            else:
                                sheet.write(ri, 0, data[0], style_g)
                            sheet.write(ri, 1, &#34;%s:%d-%d&#34; % (c, maxstart, minend))
                            sheet.write(ri, 2, data[4], style_size)
                            for col, val in enumerate(copynumbers):
                                if col in files:
                                    sheet.write(ri, 3 + col, val, style_cn_b)
                                else:
                                    sheet.write(ri, 3 + col, val, style_cn)
                            if self.annotate:
                                sheet.write(ri, 3 + len(copynumbers),
                                            annotator.get_info(&#34;%s:%d-%d&#34; % (c, maxstart, minend)))

                        if self.plot:
                            plot_start = maxstart - (minend - maxstart)
                            if plot_start &lt; 0:
                                plot_start = 0
                            plot_end = minend + (minend - maxstart)
                            self.multiple_regions([&#34;%s:%d-%d&#34; % (c, plot_start, plot_end)])
                    for i in toupdate:
                        pointers[i] += 1
        if format == &#34;tsv&#34;:
            f.close()
        elif format == &#34;xlsx&#34;:
            sheet.conditional_format(1, 3, ri, len(header) - int(self.annotate), {&#39;type&#39;: &#39;3_color_scale&#39;,
                                                                                  &#39;min_color&#39;: &#34;#FF0000&#34;,
                                                                                  &#39;mid_color&#39;: &#34;#FFFFFF&#34;,
                                                                                  &#39;max_color&#39;: &#34;#00FF00&#34;,
                                                                                  &#39;min_type&#39;: &#39;num&#39;,
                                                                                  &#39;min_value&#39;: 0,
                                                                                  &#39;mid_type&#39;: &#39;num&#39;,
                                                                                  &#39;mid_value&#39;: 2,
                                                                                  &#39;max_type&#39;: &#39;num&#39;,
                                                                                  &#39;max_value&#39;: 4
                                                                                  })
            workbook.close()

    def manhattan(self, plot_type=&#34;rd&#34;):
        bin_size = self.bin_size
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for manhattan.&#34;)
            return
        n = len(self.plot_files)
        ix = self.plot_files

        self.new_figure(panel_count=n, grid=(1, n), panel_size=(24, 2))
        for i in range(n):
            ax = self.next_panel()
            io = self.io[ix[i]]
            ax.set_title(self.file_title(ix[i]), position=(0.01, 1.01),
                         fontdict={&#39;verticalalignment&#39;: &#39;bottom&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})

            if plot_type == &#34;rd&#34;:
                chroms = []
                for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                    rd_chr = io.rd_chromosome_name(c)
                    if len(self.chrom) == 0 or (rd_chr in self.chrom) or (c in self.chrom):
                        if io.signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                                io.signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                            chroms.append((rd_chr, l))

                apos = 0
                xticks = [0]

                max_m, stdev = io.rd_normal_level(bin_size, FLAG_GC_CORR)
                for c, l in chroms:
                    flag_rd = (FLAG_USEMASK if self.rd_use_mask else 0)
                    his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                    his_p_corr = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
                    if self.rd_manhattan_call:
                        his_p_call = io.get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
                        his_p_mosaic_seg = io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                         flag_rd | FLAG_GC_CORR)
                        his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
                        his_p_mosaic_call = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                          flag_rd | FLAG_GC_CORR)
                        his_p_mosaic_seg_2d = io.get_signal(c, bin_size, &#34;RD mosaic segments 2d&#34;,
                                                            flag_rd | FLAG_GC_CORR)
                        his_p_mosaic_seg_2d = segments_decode(his_p_mosaic_seg_2d)
                        his_p_mosaic_call_2d = io.get_signal(c, bin_size, &#34;RD mosaic call 2d&#34;,
                                                             flag_rd | FLAG_GC_CORR)
                        his_p_mosaic = np.zeros_like(his_p) * np.nan
                        if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and (
                                &#34;rd_mosaic&#34; in self.callers):
                            for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                                for segi in seg:
                                    his_p_mosaic[segi] = lev
                        his_p_mosaic_2d = np.zeros_like(his_p) * np.nan
                        if his_p_mosaic_call_2d is not None and len(
                                his_p_mosaic_call_2d) &gt; 0 and (&#34;combined_mosaic&#34; in self.callers):
                            for seg, lev in zip(list(his_p_mosaic_seg_2d), list(his_p_mosaic_call_2d[0])):
                                for segi in seg:
                                    his_p_mosaic_2d[segi] = lev
                    pos = range(apos, apos + len(his_p))
                    ax.text(apos + len(his_p) // 2, max_m // 10, Genome.canonical_chrom_name(c),
                            fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                    if self.markersize == &#34;auto&#34;:
                        plt.plot(pos, his_p_corr, ls=&#39;&#39;, marker=&#39;.&#39;)
                    else:
                        plt.plot(pos, his_p_corr, ls=&#39;&#39;, marker=&#39;.&#39;, markersize=self.markersize)
                    if self.rd_manhattan_call:
                        if his_p_call is not None and len(his_p_call) &gt; 0 and (&#34;rd_mean_shift&#34; in self.callers):
                            plt.step(pos, his_p_call, &#34;r&#34;)
                        if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and (
                                &#34;rd_mosaic&#34; in self.callers):
                            plt.plot(pos, his_p_mosaic, &#34;k&#34;)
                        if his_p_mosaic_call_2d is not None and len(
                                his_p_mosaic_call_2d) &gt; 0 and (&#34;combined_mosaic&#34; in self.callers):
                            plt.plot(pos, his_p_mosaic_2d, &#34;k&#34;)
                    apos += len(his_p)
                    xticks.append(apos)
                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks(np.arange(0, 15, 0.5) * max_m, minor=[])
                ax.xaxis.set_ticks(xticks, minor=[])
                ax.set_ylim([self.rd_manhattan_range[0] * max_m, self.rd_manhattan_range[1] * max_m])
                n_bins = apos
                ax.set_xlim([0, n_bins])
                ax.grid()

            elif plot_type == &#34;baf_mosaic&#34;:
                chroms = []
                snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                    FLAG_USEHAP if self.snp_use_phase else 0)
                for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                    snp_chr = io.snp_chromosome_name(c)
                    if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                        if io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood call&#34;, snp_flag) and \
                                io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood segments&#34;, snp_flag) and \
                                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                            chroms.append((snp_chr, l))

                apos = 0
                xticks = [0]

                cix = 0
                cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
                for c, l in chroms:
                    likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                    segments = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
                    call_pos = []
                    call_baf = []
                    call_c = []
                    for s, lh in zip(segments, likelihood):
                        b, p = likelihood_baf_pval(lh)
                        if b &gt; 0 and len(s) &gt; self.min_segment_size:
                            alpha = -np.log(p + 1e-40) / self.contrast
                            if alpha &gt; 1:
                                alpha = 1
                            for pos in s:
                                call_pos.append(apos + pos)
                                call_baf.append(b)
                                color = cmap[cix % len(cmap)]
                                color = (color[0], color[1], color[2], alpha)
                                call_c.append(color)

                    ax.text(apos + l // bin_size // 2, 0.4, Genome.canonical_chrom_name(c),
                            fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                    plt.scatter(call_pos, call_baf, s=20, color=np.array(call_c), edgecolors=&#39;face&#39;, marker=&#39;|&#39;)
                    apos += l // bin_size
                    xticks.append(apos)
                    cix += 1

                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks(np.arange(0, 0.5, 0.1), minor=[])
                ax.xaxis.set_ticks(xticks, minor=[])
                ax.set_ylim([0, 0.5])
                n_bins = apos
                ax.set_xlim([0, n_bins])
                ax.grid()

            elif plot_type == &#34;rd_mean_shift&#34;:
                chroms = []
                flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR

                for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                    rd_chr = io.rd_chromosome_name(c)
                    if rd_chr is not None and len(self.chrom) == 0 or (rd_chr in self.chrom) or (c in self.chrom):
                        if (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                            chroms.append((rd_chr, l))

                apos = 0
                xticks = [0]

                cix = 0
                cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
                for c, l in chroms:
                    call_pos = []
                    call_conc = []
                    call_c = []
                    if io.signal_exists(c, bin_size, &#34;calls&#34;, flag):
                        calls = io.read_calls(c, bin_size, &#34;calls&#34;, flag)

                        for call in calls:
                            if in_interval(call[&#34;size&#34;], self.size_range) and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                    and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                    and in_interval(call[&#34;Q0&#34;], self.Q0_range):
                                alpha = - np.log(call[&#34;p_val&#34;] + 1e-40) / self.contrast
                                if alpha &gt; 1:
                                    alpha = 1
                                if alpha &lt; 0:
                                    alpha = 0
                                for pos in range(int(call[&#34;start&#34;]) // bin_size, int(call[&#34;end&#34;]) // bin_size + 1):
                                    call_pos.append(apos + pos)
                                    level = call[&#34;cnv&#34;] * 2
                                    if level &gt; 4:
                                        level = 4
                                    call_conc.append(level)
                                    if call[&#34;type&#34;] == 1:
                                        call_c.append((0, 1, 0, alpha))
                                    elif call[&#34;type&#34;] == -1:
                                        call_c.append((1, 0, 0, alpha))
                                    else:
                                        call_c.append((0, 0, 1, alpha))
                        ax.text(apos + l // bin_size // 2, 0.4, Genome.canonical_chrom_name(c),
                                fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                        plt.scatter(call_pos, call_conc, s=20, color=np.array(call_c), edgecolors=&#39;face&#39;, marker=&#39;|&#39;)
                        apos += l // bin_size
                        xticks.append(apos)
                        cix += 1

                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks(np.arange(0, 4.0, 1.0), minor=[])
                ax.xaxis.set_ticks(xticks, minor=[])
                ax.set_ylim([0, 4.0])
                n_bins = apos
                ax.set_xlim([0, n_bins])
                ax.grid()

            elif plot_type == &#34;combined_mosaic&#34;:
                chroms = []
                flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                    FLAG_USEHAP if self.snp_use_phase else 0) | (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR

                for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                    snp_chr = io.snp_chromosome_name(c)
                    if snp_chr is not None and len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                        if (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                            chroms.append((snp_chr, l))

                apos = 0
                xticks = [0]

                cix = 0
                cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
                for c, l in chroms:
                    call_pos = []
                    call_conc = []
                    call_c = []
                    if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                        calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)

                        for call in calls:
                            if call[&#34;bins&#34;] &gt; self.min_segment_size:
                                alpha = -np.log(call[&#34;p_val&#34;] + 1e-40) / self.contrast
                                if alpha &gt; 1:
                                    alpha = 1
                                for pos in range(int(call[&#34;start&#34;]) // bin_size, int(call[&#34;end&#34;]) // bin_size + 1):
                                    call_pos.append(apos + pos)
                                    call_conc.append(call[&#34;models&#34;][0][4])
                                    if call[&#34;type&#34;] == 1:
                                        call_c.append((0, 1, 0, alpha))
                                    elif call[&#34;type&#34;] == -1:
                                        call_c.append((1, 0, 0, alpha))
                                    else:
                                        call_c.append((0, 0, 1, alpha))

                        ax.text(apos + l // bin_size // 2, 0.4, Genome.canonical_chrom_name(c),
                                fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                        plt.scatter(call_pos, call_conc, s=20, color=np.array(call_c), edgecolors=&#39;face&#39;, marker=&#39;|&#39;)
                        apos += l // bin_size
                        xticks.append(apos)
                        cix += 1

                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks(np.arange(0, 1.0, 0.1), minor=[])
                ax.xaxis.set_ticks(xticks, minor=[])
                ax.set_ylim([0, 1.0])

                n_bins = apos
                ax.set_xlim([0, n_bins])
                ax.grid()

        self.fig_show(suffix=&#34;manhattan&#34; if plot_type == &#34;rd&#34; else &#34;snp_calls&#34;)

    def callmap(self, color=&#34;frequency&#34;, background=&#34;white&#34;, pixel_size=1700000, max_p_val=1e-20, min_freq=0.01,
                plot=&#34;cmap&#34;):
        bin_size = self.bin_size
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for callmap.&#34;)
            return
        n = len(self.plot_files)
        ix = self.plot_files

        if plot:
            self.new_figure(panel_count=n, grid=(1, 1), panel_size=(24, 0.24 * n))

        chroms = []
        starts = []
        ends = []
        pixels = 0
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            if l &gt; 10 * bin_size:
                if len(self.chrom) == 0 or (c in self.chrom) or (self.io[0].snp_chromosome_name(c) in self.chrom):
                    chroms.append(c)
                    starts.append(pixels)
                    pixels += l // pixel_size + 1
                    ends.append(pixels - 1)

        cmap = np.zeros((n, pixels, 3))
        cmap[:, ends, :] = 1

        for i in range(n):
            io = self.io[ix[i]]
            print(io.filename)
            flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                FLAG_USEHAP if self.snp_use_phase else 0) | (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
            flag_rd = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
            for c, start in zip(chroms, starts):
                snp_chr = io.snp_chromosome_name(c)
                if io.signal_exists(snp_chr, bin_size, &#34;calls combined&#34;, flag):

                    calls = io.read_calls(snp_chr, bin_size, &#34;calls combined&#34;, flag)
                    segments = io.get_signal(snp_chr, bin_size, &#34;RD mosaic segments 2d&#34;, flag_rd)
                    segments = segments_decode(segments)

                    for call in calls:
                        if call[&#34;bins&#34;] &gt; self.min_segment_size and call[&#34;p_val&#34;] &lt; max_p_val and &#34;segment&#34; in call and \
                                call[&#34;models&#34;][0][4] &gt; min_freq:
                            cix = int(call[&#34;type&#34;]) + 1
                            for b in segments[int(call[&#34;segment&#34;])]:
                                if color == &#34;frequency&#34;:
                                    cmap[i, start + b * bin_size // pixel_size, cix] = max(
                                        cmap[i, start + b * bin_size // pixel_size, cix], call[&#34;models&#34;][0][4])
                                elif color == &#34;coverage&#34;:
                                    cmap[i, start + b * bin_size // pixel_size, cix] += bin_size / pixel_size
                                else:  # model copy number
                                    if call[&#34;models&#34;][0][0] == 0:
                                        cmap[i, start + b * bin_size // pixel_size, 0] = 1
                                    elif call[&#34;models&#34;][0][0] == 1:
                                        cmap[i, start + b * bin_size // pixel_size, 0] = 1
                                        cmap[i, start + b * bin_size // pixel_size, 1] = 1
                                    elif call[&#34;models&#34;][0][0] == 2:
                                        cmap[i, start + b * bin_size // pixel_size, 2] = 1
                                    else:
                                        cn = call[&#34;models&#34;][0][0]
                                        if cn &gt; 6:
                                            cn = 6
                                        cmap[i, start + b * bin_size // pixel_size, 1] = (2 + cn) / 8

        def b2w(pixel):
            if np.all(pixel == 1):
                pixel[:] = 0
            elif pixel[0] &gt; pixel[1] and pixel[0] &gt; pixel[2]:
                pixel[1] = pixel[2] = 1 - pixel[0]
                pixel[0] = 1
            elif pixel[1] &gt; pixel[2]:
                pixel[0] = pixel[2] = 1 - pixel[1]
                pixel[1] = 1
            else:
                pixel[0] = pixel[1] = 1 - pixel[2]
                pixel[2] = 1
            return pixel

        if background == &#34;white&#34;:
            cmap = cmap.reshape(n * pixels, 3)
            np.apply_along_axis(b2w, 1, cmap)
            cmap = cmap.reshape(n, pixels, 3)

        cmap = (255 * cmap).astype(&#34;int&#34;)
        if plot == &#34;cmap&#34;:
            self.new_figure(panel_count=1, grid=(1, 1), panel_size=(24, 0.24 * n))
            ax = self.next_panel()
            plt.imshow(cmap, aspect=&#39;auto&#39;)
            for i in ends[:-1]:
                plt.axvline(x=i - 0.5, color=&#39;red&#39;, linewidth=0.5)
            ax.set_yticks([])
            ax.set_yticklabels([])
            ax.set_xticks((np.array(starts) + np.array(ends)) / 2)
            chroms = list(map(Genome.canonical_chrom_name, chroms))
            ax.set_xticklabels(chroms)
            self.fig_show(suffix=&#34;callmap&#34;)
        elif plot == &#34;regions&#34;:
            self.new_figure(panel_count=1, grid=(1, 1), panel_size=(24, 24))
            ax = self.next_panel()
            corr = np.corrcoef(
                np.concatenate((cmap[:, :, 0].transpose(), cmap[:, :, 1].transpose(), cmap[:, :, 2].transpose()),
                               axis=0))
            plt.imshow(corr, aspect=&#39;auto&#39;, vmin=-1, vmax=1)
            plt.colorbar()
            starts3 = np.concatenate((np.array(starts), np.array(starts) + ends[-1], np.array(starts) + 2 * ends[-1]))
            ends3 = np.concatenate((np.array(ends), np.array(ends) + ends[-1], np.array(ends) + 2 * ends[-1]))
            for i in ends3[:-1]:
                plt.axvline(x=i - 0.5, color=&#39;red&#39;, linewidth=0.5)
                plt.axhline(y=i - 0.5, color=&#39;red&#39;, linewidth=0.5)

            ax.set_xticks((starts3 + ends3) / 2)
            ax.set_yticks((starts3 + ends3) / 2)
            chroms = list(map(Genome.canonical_chrom_name, chroms))
            ax.set_xticklabels(chroms + chroms + chroms)
            ax.set_yticklabels(chroms + chroms + chroms)
            self.fig_show(suffix=&#34;callmap&#34;)
        else:
            self.new_figure(panel_count=2, panel_size=(12, 12))
            ax = self.next_panel()
            x = np.concatenate((cmap[:, :, 0], cmap[:, :, 1], cmap[:, :, 2]),
                               axis=1)
            corr = np.corrcoef(x)
            plt.imshow(corr, aspect=&#39;auto&#39;, vmin=-1, vmax=1)
            plt.colorbar()
            ax = plt.gca()

            ax.set_xticks(range(n))
            ax.set_yticks(range(n))
            ax = self.next_panel()
            Z = hierarchy.linkage(x, &#39;average&#39;, &#39;correlation&#39;)
            dn = hierarchy.dendrogram(Z)

            self.fig_show(suffix=&#34;callmap&#34;)
        return cmap

    def multiple_regions(self, regions):
        n = len(self.plot_files) * len(regions)
        self.new_figure(panel_count=n)
        j = 0
        for i in range(len(self.plot_files)):
            for r in regions:
                self.regions(self.plot_files[i], r)
                j += 1
        self.fig_show(suffix=&#34;regions&#34;)

    def regions(self, ix, region):
        panels = self.panels
        bin_size = self.bin_size
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0)
        self.new_subgrid(len(panels), hspace=0.05, wspace=0.1)
        r = decode_region(region, max_size=1000000000)
        io = self.io[ix]
        for i in range(len(panels)):
            ax = self.next_subpanel(sharex=True)
            if i == 0 and self.title:
                ax.set_title(self.file_title(ix) + &#34;: &#34; + region, position=(0.01, 0.9),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                             color=&#39;C0&#39;)

            if panels[i] == &#34;rd&#34;:
                g_p = [0]
                g_p_corr = [0]
                g_p_seg = [0]
                g_p_call = [0]
                g_p_call_mosaic = [0]
                g_p_call_mosaic_2d = [0]
                mean, stdev = 0, 0
                borders = []
                pos_x = []
                for c, (pos1, pos2) in r:
                    if pos2 == 1000000000:
                        pos2 = io.get_chromosome_length(c)
                        if pos2 is None:
                            pos2 = 1000000000
                    flag_rd = 0
                    if self.rd_use_mask:
                        flag_rd = FLAG_USEMASK
                    mean, stdev = io.rd_normal_level(bin_size, flag_rd | FLAG_GC_CORR)
                    his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                    his_p_corr = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_seg = io.get_signal(c, bin_size, &#34;RD partition&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_call = io.get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg = io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                     flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
                    his_p_mosaic_call = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                      flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg_2d = io.get_signal(c, bin_size, &#34;RD mosaic segments 2d&#34;,
                                                        flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg_2d = segments_decode(his_p_mosaic_seg_2d)
                    his_p_mosaic_call_2d = io.get_signal(c, bin_size, &#34;RD mosaic call 2d&#34;,
                                                         flag_rd | FLAG_GC_CORR)
                    his_p_mosaic = np.zeros_like(his_p) * np.nan
                    if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and (&#34;rd_mosaic&#34; in self.callers):
                        for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                            for segi in seg:
                                his_p_mosaic[segi] = lev
                    his_p_mosaic_2d = np.zeros_like(his_p) * np.nan
                    if his_p_mosaic_call_2d is not None and len(his_p_mosaic_call_2d) &gt; 0 and (
                            &#34;combined_mosaic&#34; in self.callers):
                        for seg, lev in zip(list(his_p_mosaic_seg_2d), list(his_p_mosaic_call_2d[0])):
                            for segi in seg:
                                his_p_mosaic_2d[segi] = lev
                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    bins = len(list(his_p[start_bin:end_bin]))
                    pos_x.extend(range(pos1, pos2 + bin_size, bin_size)[0:bins])

                    g_p.extend(list(his_p[start_bin:end_bin]))
                    g_p_corr.extend(list(his_p_corr[start_bin:end_bin]))
                    if his_p_seg is not None and len(his_p_seg) &gt; 0 and self.rd_partition:
                        g_p_seg.extend(list(his_p_seg[start_bin:end_bin]))
                    if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call and (
                            &#34;rd_mean_shift&#34; in self.callers):
                        g_p_call.extend(list(his_p_call[start_bin:end_bin]))
                    if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call and (
                            &#34;rd_mosaic&#34; in self.callers):
                        g_p_call_mosaic.extend(list(his_p_mosaic[start_bin:end_bin]))
                    if his_p_mosaic_call_2d is not None and len(his_p_mosaic_call_2d) &gt; 0 and self.rd_call and (
                            &#34;combined_mosaic&#34; in self.callers):
                        g_p_call_mosaic_2d.extend(list(his_p_mosaic_2d[start_bin:end_bin]))
                    borders.append(len(g_p) - 1)

                def format_func(value, tick_number):
                    ix = int(value)
                    if ix + 1 &lt; len(pos_x):
                        p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    elif ix &lt; len(pos_x):
                        p = pos_x[ix]
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    else:
                        return &#34;&#34;

                l = len(g_p)
                if i == len(panels) - 1:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                    ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                    ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                    ax.xaxis.grid()
                else:
                    plt.setp(ax.get_xticklabels(), visible=False)

                if (self.rd_range[1] - self.rd_range[0]) &lt; 30:
                    ax.yaxis.set_ticks(np.arange(int(self.rd_range[0]), int(self.rd_range[1] + 1), 1) * mean / 2,
                                       minor=[])
                    ax.yaxis.set_ticklabels([str(i) for i in range(int(self.rd_range[0]), int(self.rd_range[1] + 1))])
                ax.set_ylim([self.rd_range[0] * mean / 2, self.rd_range[1] * mean / 2])
                ax.set_ylabel(&#34;Read depth&#34;)
                ax.yaxis.grid()

                if self.rd_raw:
                    ax.step(g_p, self.rd_colors[0], label=&#34;raw&#34;)
                if self.rd_corrected:
                    ax.step(g_p_corr, self.rd_colors[1], label=&#34;GC corrected&#34;)
                if len(g_p_seg) &gt; 1:
                    plt.step(g_p_seg, self.rd_colors[2], label=&#34;partitioning&#34;)
                if len(g_p_call) &gt; 1:
                    plt.step(g_p_call, self.rd_colors[3], label=&#34;cnv calls&#34;)
                if len(g_p_call_mosaic) &gt; 1:
                    plt.step(g_p_call_mosaic, self.rd_colors[4], label=&#34;mosaic cnv calls&#34;)
                if len(g_p_call_mosaic_2d) &gt; 1:
                    plt.step(g_p_call_mosaic_2d, self.rd_colors[5], label=&#34;combined cnv calls&#34;)
                for i in borders[:-1]:
                    ax.axvline(i, color=&#34;g&#34;, lw=1)
                if self.legend:
                    ax.legend(loc=&#39;upper center&#39;, bbox_to_anchor=(0.5, -0.05), shadow=True, ncol=2)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;snp&#34;:
                borders = []
                hpos = []
                baf = []
                color = []
                alpha = 0.7
                start_pos = 0
                pos_x = []
                for c, (pos1, pos2) in r:
                    if pos2 == 1000000000:
                        pos2 = io.get_chromosome_length(c)
                        if pos2 is None:
                            pos2 = 1000000000
                    pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c)
                    ix = 0
                    mdp = 0
                    while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                        if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0 and ((not self.snp_use_id) or (flag[ix] &amp; 1)):
                            hpos.append((start_pos + pos[ix] - pos1) / bin_size)
                            if pos[ix] - pos1 &gt; mdp:
                                mdp = pos[ix] - pos1
                            if gt[ix] % 4 != 2:
                                baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            else:
                                baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                            if self.snp_alpha_P:
                                alpha = None
                                color.append(
                                    colors.to_rgba(self.snp_colors[(gt[ix] % 4) * 2 + 1], (flag[ix] &gt;&gt; 1) * 0.4))
                            else:
                                color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                        ix += 1
                    start_pos += pos2 - pos1
                    pos_x.extend(range(pos1, pos2 + bin_size, bin_size))
                    borders.append(start_pos / bin_size)

                def format_func(value, tick_number):
                    ix = int(value)
                    if ix + 1 &lt; len(pos_x):
                        p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    elif ix &lt; len(pos_x):
                        p = pos_x[ix]
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    else:
                        return &#34;&#34;

                l = len(pos_x)
                if i == len(panels) - 1:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                    ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                    ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                    ax.xaxis.grid()
                else:
                    plt.setp(ax.get_xticklabels(), visible=False)

                # ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
                ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
                ax.set_ylabel(&#34;Allele frequency&#34;)
                l = max(hpos)
                ax.set_ylim([-0.05, 1.05])
                # ax.set_xlim([0, borders[-1]])
                ax.yaxis.grid()
                if self.markersize == &#34;auto&#34;:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=alpha)
                else:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=alpha)

                for i in borders[:-1]:
                    ax.axvline(i, color=&#34;g&#34;, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;snv&#34; or panels[i][:4] == &#34;snv:&#34;:
                callset = &#34;default&#34;
                if panels[i][:4] == &#34;snv:&#34;:
                    callset = panels[i].split(&#34;:&#34;)[1]
                borders = []
                hpos = []
                baf = []
                color = []
                alpha = 0.7
                start_pos = 0
                pos_x = []
                for c, (pos1, pos2) in r:
                    if pos2 == 1000000000:
                        pos2 = io.get_chromosome_length(c)
                        if pos2 is None:
                            pos2 = 1000000000
                    pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c, callset=callset)
                    ix = 0
                    mdp = 0
                    while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                        if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0:
                            hpos.append((start_pos + pos[ix] - pos1) / bin_size)
                            if pos[ix] - pos1 &gt; mdp:
                                mdp = pos[ix] - pos1
                            if gt[ix] % 4 != 2:
                                baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            else:
                                baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                            if self.snp_alpha_P:
                                alpha = None
                                color.append(
                                    colors.to_rgba(self.snp_colors[(gt[ix] % 4) * 2 + 1], (flag[ix] &gt;&gt; 1) * 0.4))
                            else:
                                color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                        ix += 1
                    start_pos += pos2 - pos1
                    pos_x.extend(range(pos1, pos2 + bin_size, bin_size))
                    borders.append(start_pos / bin_size)

                def format_func(value, tick_number):
                    ix = int(value)
                    if ix + 1 &lt; len(pos_x):
                        p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    elif ix &lt; len(pos_x):
                        p = pos_x[ix]
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    else:
                        return &#34;&#34;

                l = len(pos_x)
                if i == len(panels) - 1:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                    ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                    ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                else:
                    plt.setp(ax.get_xticklabels(), visible=False)
                ax.xaxis.grid()
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
                ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
                ax.set_ylabel(&#34;Allele frequency&#34;)
                ax.set_ylim([0., 1.])
                ax.yaxis.grid()
                if self.markersize == &#34;auto&#34;:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=alpha)
                else:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=alpha)

                for i in borders[:-1]:
                    ax.axvline(i, color=&#34;g&#34;, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;baf&#34;:
                g_baf, g_maf, g_i1, g_i2 = [0], [0], [0], [0]
                borders = []
                pos_x = []

                for c, (pos1, pos2) in r:
                    if pos2 == 1000000000:
                        pos2 = io.get_chromosome_length(c)
                        if pos2 is None:
                            pos2 = 1000000000

                    flag_snp = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                        FLAG_USEHAP if self.snp_use_phase else 0)
                    baf = io.get_signal(c, bin_size, &#34;SNP baf&#34;, flag_snp)
                    maf = io.get_signal(c, bin_size, &#34;SNP maf&#34;, flag_snp)
                    i1 = io.get_signal(c, bin_size, &#34;SNP i1&#34;, flag_snp)
                    i2 = io.get_signal(c, bin_size, &#34;SNP i2&#34;, flag_snp)

                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    bins = len(list(baf[start_bin:end_bin]))
                    pos_x.extend(range(pos1, pos2 + bin_size, bin_size)[0:bins])

                    g_baf.extend(list(baf[start_bin:end_bin]))
                    g_maf.extend(list(maf[start_bin:end_bin]))
                    g_i1.extend(list(i1[start_bin:end_bin]))
                    g_i2.extend(list(i2[start_bin:end_bin]))
                    borders.append(len(g_baf) - 1)

                def format_func(value, tick_number):
                    ix = int(value)
                    if ix + 1 &lt; len(pos_x):
                        p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    elif ix &lt; len(pos_x):
                        p = pos_x[ix]
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    else:
                        return &#34;&#34;

                l = len(g_baf)
                if i == len(panels) - 1:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                    ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                    ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                    ax.xaxis.grid()

                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
                ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
                ax.set_ylabel(&#34;Allele frequency&#34;)

                ax.set_ylim([0, 1])
                # ax.set_xlim([-l * 0.0, l * 1.0])

                ax.yaxis.grid()
                # ax.xaxis.grid()
                ax.step(g_baf, self.baf_colors[0], label=&#34;BAF&#34;)
                ax.step(g_maf, self.baf_colors[1], label=&#34;MAF&#34;)
                ax.step(g_i1, self.baf_colors[2], label=&#34;I1&#34;)
                if self.legend:
                    ax.legend()
                for i in borders[:-1]:
                    ax.axvline(i, color=&#34;g&#34;, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;likelihood&#34;:
                borders = []
                gl = []
                call_pos = []
                call_i1 = []
                call_i2 = []
                call_c = []
                call_pos_2d = []
                call_i1_2d = []
                call_i2_2d = []
                call_c_2d = []
                tlen = 0
                tlen_2d = 0
                pos_x = []
                for c, (pos1, pos2) in r:
                    if pos2 == 1000000000:
                        pos2 = io.get_chromosome_length(c)
                        if pos2 is None:
                            pos2 = 1000000000
                    likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    bins = len(list(likelihood[start_bin:end_bin]))
                    pos_x.extend(range(pos1, pos2 + bin_size, bin_size)[0:bins])
                    gl.extend(list(likelihood[start_bin:end_bin]))
                    borders.append(len(gl) - 1)
                    if self.snp_call and (&#34;baf_mosaic&#34; in self.callers):
                        likelihood_call = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                        segments = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))

                        for s, lh in zip(segments, likelihood_call):
                            i1, i2, p = likelihood_pixels_pval(lh)
                            if i1 != i2 and len(s) &gt; self.min_segment_size:
                                alpha = -np.log(p + 1e-40) / self.contrast
                                if alpha &gt; 1:
                                    alpha = 1
                                for pos in s:
                                    if pos &gt;= start_bin and pos &lt; end_bin:
                                        call_pos.append(pos - start_bin + tlen)
                                        call_i1.append(min(i1, i2))
                                        call_i2.append(max(i1, i2))
                                        color = colors.to_rgb(self.lh_colors[0]) + (alpha,)
                                        call_c.append(color)
                        tlen += end_bin - start_bin
                    if self.snp_call and (&#34;combined_mosaic&#34; in self.callers):
                        likelihood_call = io.get_signal(c, bin_size, &#34;SNP likelihood call 2d&#34;, snp_flag)
                        segments = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments 2d&#34;, snp_flag))

                        for s, lh in zip(segments, likelihood_call):
                            i1, i2, p = likelihood_pixels_pval(lh)
                            if i1 != i2 and len(s) &gt; self.min_segment_size:
                                alpha = -np.log(p + 1e-40) / self.contrast
                                if alpha &gt; 1:
                                    alpha = 1
                                for pos in s:
                                    if pos &gt;= start_bin and pos &lt; end_bin:
                                        call_pos_2d.append(pos - start_bin + tlen_2d)
                                        call_i1_2d.append(min(i1, i2))
                                        call_i2_2d.append(max(i1, i2))
                                        color = colors.to_rgb(self.lh_colors[1]) + (alpha,)
                                        call_c_2d.append(color)
                        tlen_2d += end_bin - start_bin

                def format_func(value, tick_number):
                    ix = int(value)
                    if ix + 1 &lt; len(pos_x):
                        p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    elif ix &lt; len(pos_x):
                        p = pos_x[ix]
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    else:
                        return &#34;&#34;

                img = np.array(gl).transpose()
                l = img.shape[1]
                if i == len(panels) - 1:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                    ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                    ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                    # ax.xaxis.grid()
                else:
                    plt.setp(ax.get_xticklabels(), visible=False)

                ax.imshow(img, aspect=&#39;auto&#39;)
                # ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticks([0, img.shape[0] / 4, img.shape[0] / 2, 3 * img.shape[0] / 4, img.shape[0] - 1],
                                   minor=[])
                ax.yaxis.set_ticklabels([&#34;1&#34;, &#34;3/4&#34;, &#34;1/2&#34;, &#34;1/4&#34;, &#34;0&#34;])
                ax.set_ylabel(&#34;Allele frequency&#34;)
                # ax.xaxis.set_ticks(np.arange(0, len(gl), 50), minor=[])
                # ax.set_xlim([-0.5, img.shape[1] - 0.5])
                if self.snp_call and (&#34;baf_mosaic&#34; in self.callers):
                    plt.scatter(call_pos, call_i1, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                                marker=self.lh_marker)
                    plt.scatter(call_pos, call_i2, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                                marker=self.lh_marker)
                if self.snp_call and (&#34;combined_mosaic&#34; in self.callers):
                    plt.scatter(call_pos_2d, call_i1_2d, s=self.lh_markersize, color=np.array(call_c_2d),
                                edgecolors=&#39;face&#39;, marker=self.lh_marker)
                    plt.scatter(call_pos_2d, call_i2_2d, s=self.lh_markersize, color=np.array(call_c_2d),
                                edgecolors=&#39;face&#39;, marker=self.lh_marker)

                for i in borders[:-1]:
                    ax.axvline(i + 0.5, color=&#34;g&#34;, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;CN&#34;:
                borders = []
                gh1 = []
                gh2 = []
                tlen = 0
                tlen_2d = 0
                for c, (pos1, pos2) in r:
                    if pos2 == 1000000000:
                        pos2 = io.get_chromosome_length(c)
                        if pos2 is None:
                            pos2 = 1000000000

                    his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    if end_bin &gt; len(his_p):
                        end_bin = len(his_p)
                    h1 = np.array([0] * (end_bin - start_bin))
                    h2 = np.array([0] * (end_bin - start_bin))
                    h1[his_p != 0] = 1
                    h2[his_p != 0] = 1

                    flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                        FLAG_USEHAP if self.snp_use_phase else 0) | (
                               FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                    flag_rd = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
                    if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                        calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)
                        segments = io.get_signal(c, bin_size, &#34;RD mosaic segments 2d&#34;, flag_rd)
                        segments = segments_decode(segments)

                        for call in calls:
                            for b in segments[int(call[&#34;segment&#34;])]:
                                if b &lt; end_bin and b &gt;= start_bin:
                                    h1[b - start_bin] = call[&#34;models&#34;][0][1]
                                    h2[b - start_bin] = call[&#34;models&#34;][0][2]
                    gh1.extend(list(h1))
                    gh2.extend(list(h2))
                    borders.append(len(gh1) - 1)
                x = range(len(gh1))
                plt.gca().get_xaxis().get_major_formatter().set_useOffset(False)
                plt.stackplot(x, gh1, gh2, baseline=&#39;sym&#39;)

                def format_func(value, tick_number):
                    ix = int(value)
                    if ix + 1 &lt; len(pos_x):
                        p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    elif ix &lt; len(pos_x):
                        p = pos_x[ix]
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    else:
                        return &#34;&#34;

                l = len(gh1)
                if i == len(panels) - 1:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                    ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                    ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                    ax.xaxis.grid()

                for i in borders[:-1]:
                    ax.axvline(i + 0.5, color=&#34;g&#34;, lw=1)
                self.fig.add_subplot(ax)

    def global_plot(self):
        chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            rd_chr = self.io[self.plot_files[0]].rd_chromosome_name(c)
            if (len(self.chrom) == 0 or (rd_chr in self.chrom) or (c in self.chrom)) and rd_chr is not None:
                if (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                    chroms.append((rd_chr, l))
        panels = self.panels
        bin_size = self.bin_size
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0)
        rd_flag = (FLAG_USEMASK if self.rd_use_mask else 0) | (FLAG_GC_CORR if self.rd_use_gc_corr else 0)
        n = len(self.plot_files)
        self.new_figure(panel_count=n)
        for ii in range(len(self.plot_files)):
            ix = self.plot_files[ii]
            self.new_subgrid(len(panels), hspace=0.05, wspace=0.05)
            io = self.io[ix]
            for i in range(len(panels)):
                ax = self.next_subpanel(sharex=True)
                if i == 0:
                    ax.set_title(self.file_title(ix), position=(0.01, 0.9),
                                 fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                                 color=&#39;C0&#39;)

                if panels[i] == &#34;rd&#34;:
                    start = 0
                    xticks = [0]
                    xticks_minor = []
                    xticks_labels = []
                    for c, l in chroms:
                        mean, stdev = io.rd_normal_level(bin_size, rd_flag | FLAG_GC_CORR)
                        his_p = io.get_signal(c, bin_size, &#34;RD&#34;, rd_flag)
                        pos = range(start, start + len(his_p))
                        if self.markersize == &#34;auto&#34;:
                            plt.plot(pos, his_p, ls=&#39;&#39;, marker=&#39;.&#39;, markersize=1)
                        else:
                            plt.plot(pos, his_p, ls=&#39;&#39;, marker=&#39;.&#39;, markersize=self.markersize)
                        xticks_minor.append(start + len(his_p) // 2)
                        xticks_labels.append(Genome.canonical_chrom_name(c))
                        start += l // bin_size + 1
                        xticks.append(start)

                    ax.set_xlim([0, start])
                    ax.xaxis.set_ticks(xticks)
                    ax.xaxis.set_ticklabels([&#34;&#34;] * len(xticks))
                    if i == (len(panels) - 1):
                        ax.xaxis.set_ticks(xticks_minor, minor=True)
                        ax.xaxis.set_ticklabels(xticks_labels, minor=True)
                    else:
                        plt.setp(ax.get_xticklabels(which=&#34;both&#34;), visible=False)
                    yticks = np.arange(self.rd_manhattan_range[0], self.rd_manhattan_range[1], 0.5)
                    ax.yaxis.set_ticklabels([str(int(2 * t)) for t in yticks])
                    ax.yaxis.set_ticks(yticks * mean)
                    ax.set_ylabel(&#34;RD [CN]&#34;)
                    ax.set_ylim([self.rd_manhattan_range[0] * mean, self.rd_manhattan_range[1] * mean])
                    ax.grid()
                    self.fig.add_subplot(ax)

                elif panels[i] == &#34;snp&#34;:
                    start = 0
                    xticks = []
                    xticks_minor = []
                    xticks_labels = []
                    pos_x = []
                    for c, l in chroms:
                        pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c)
                        ix = 0
                        hpos = []
                        color = []
                        alpha = 0.7
                        baf = []
                        while ix &lt; len(pos):
                            if (nref[ix] + nalt[ix]) != 0 and ((not self.snp_use_id) or (flag[ix] &amp; 1)):
                                hpos.append(start + (pos[ix] / bin_size))
                                if gt[ix] % 4 != 2:
                                    baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                                else:
                                    baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                                if self.snp_alpha_P:
                                    alpha = None
                                    color.append(
                                        colors.to_rgba(self.snp_colors[(gt[ix] % 4) * 2 + 1], (flag[ix] &gt;&gt; 1) * 0.4))
                                else:
                                    color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                            ix += 1
                        if self.markersize == &#34;auto&#34;:
                            ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=0.1, alpha=alpha)
                        else:
                            ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=alpha)
                        xticks_minor.append(start + l // bin_size // 2)
                        xticks_labels.append(Genome.canonical_chrom_name(c))
                        start += l // bin_size + 1
                        xticks.append(start)
                    ax.set_xlim([0, start])
                    ax.xaxis.set_ticks(xticks)
                    ax.xaxis.set_ticklabels([&#34;&#34;] * len(xticks))
                    if i == (len(panels) - 1):
                        ax.xaxis.set_ticks(xticks_minor, minor=True)
                        ax.xaxis.set_ticklabels(xticks_labels, minor=True)
                    else:
                        plt.setp(ax.get_xticklabels(minor=True), visible=False)
                    ax.grid()
                    ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0])
                    ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
                    ax.set_ylabel(&#34;BAF&#34;)
                    ax.set_ylim([-0.05, 1.05])
                    ax.yaxis.grid()
                    self.fig.add_subplot(ax)

                elif panels[i] == &#34;snv&#34; or panels[i][:4] == &#34;snv:&#34;:
                    callset = &#34;default&#34;
                    if panels[i][:4] == &#34;snv:&#34;:
                        callset = panels[i].split(&#34;:&#34;)[1]
                    start = 0
                    xticks = []
                    xticks_minor = []
                    xticks_labels = []
                    pos_x = []
                    for c, l in chroms:
                        pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c, callset=callset)
                        ix = 0
                        hpos = []
                        color = []
                        alpha = 0.7
                        baf = []
                        while ix &lt; len(pos):
                            if (nref[ix] + nalt[ix]) != 0 and ((not self.snp_use_id) or (flag[ix] &amp; 1)):
                                hpos.append(start + (pos[ix] / bin_size))
                                if gt[ix] % 4 != 2:
                                    baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                                else:
                                    baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                                if self.snp_alpha_P:
                                    alpha = None
                                    color.append(
                                        colors.to_rgba(self.snp_colors[(gt[ix] % 4) * 2 + 1], (flag[ix] &gt;&gt; 1) * 0.4))
                                else:
                                    color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                            ix += 1
                        if self.markersize == &#34;auto&#34;:
                            ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=0.1, alpha=alpha)
                        else:
                            ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=alpha)
                        xticks_minor.append(start + l // bin_size // 2)
                        xticks_labels.append(Genome.canonical_chrom_name(c))
                        start += l // bin_size + 1
                        xticks.append(start)
                    ax.set_xlim([0, start])
                    ax.xaxis.set_ticks(xticks)
                    ax.xaxis.set_ticklabels([&#34;&#34;] * len(xticks))
                    if i == (len(panels) - 1):
                        ax.xaxis.set_ticks(xticks_minor, minor=True)
                        ax.xaxis.set_ticklabels(xticks_labels, minor=True)
                    else:
                        plt.setp(ax.get_xticklabels(minor=True), visible=False)
                    ax.grid()
                    ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0])
                    ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
                    ax.set_ylabel(&#34;BAF&#34;)
                    ax.set_ylim([-0.05, 1.05])
                    ax.yaxis.grid()
                    self.fig.add_subplot(ax)


                elif panels[i] == &#34;likelihood&#34;:
                    start = 0
                    xticks = [0]
                    xticks_minor = []
                    xticks_labels = []
                    gl = []
                    for c, l in chroms:
                        likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
                        lh = list(likelihood)
                        size = l // bin_size + 1
                        if len(lh) &lt; size:
                            if len(lh)&gt;0:
                                lh.extend([lh[-1] for jj in range(size - len(lh))])
                            elif len(gl)&gt;0:
                                lh.extend([gl[-1] for jj in range(size - len(lh))])

                        gl.extend(lh)
                        xticks_minor.append(start + l // bin_size // 2)
                        xticks_labels.append(Genome.canonical_chrom_name(c))
                        start += l // bin_size + 1
                        xticks.append(start)

                    img = np.array(gl).transpose()
                    img[0, :] = 0
                    img[-1, :] = 0
                    ax.imshow(img, aspect=&#39;auto&#39;)
                    ax.yaxis.set_ticks([0, img.shape[0] / 4, img.shape[0] / 2, 3 * img.shape[0] / 4, img.shape[0] - 1],
                                       minor=[])
                    ax.yaxis.set_ticklabels([&#34;1&#34;, &#34;3/4&#34;, &#34;1/2&#34;, &#34;1/4&#34;, &#34;0&#34;])
                    ax.set_ylabel(&#34;BAF&#34;)
                    ax.set_xlim([0, start])
                    ax.xaxis.set_ticks(xticks)
                    ax.xaxis.set_ticklabels([&#34;&#34;] * len(xticks))
                    if i == (len(panels) - 1):
                        ax.xaxis.set_ticks(xticks_minor, minor=True)
                        ax.xaxis.set_ticklabels(xticks_labels, minor=True)
                    else:
                        plt.setp(ax.get_xticklabels(minor=True), visible=False)
                    ax.xaxis.grid()
                    self.fig.add_subplot(ax)

        self.fig_show(suffix=&#34;global&#34;)

    def circular(self):
        chroms = self.chrom
        bin_size = self.bin_size
        n = len(self.plot_files)
        ix = self.plot_files
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0)
        rd_flag = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
        self.new_figure(panel_count=n)
        for i in range(n):
            ax = self.next_polar_panel()
            ax.set_theta_zero_location(&#34;N&#34;)
            ax.set_theta_direction(-1)
            rainbow = ax._get_lines
            io = self.io[ix[i]]
            plot_len = 0
            plot_chroms = []
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                rd_chr = io.rd_chromosome_name(c)
                if rd_chr is not None and (len(chroms) == 0 or (rd_chr in chroms) or (c in chroms)) and (
                        Genome.is_autosome(c) or Genome.is_sex_chrom(c)
                ) and io.signal_exists(rd_chr, bin_size, &#34;SNP maf&#34;, snp_flag) and io.signal_exists(
                    rd_chr, bin_size, &#34;RD&#34;, rd_flag):
                    plot_chroms.append((rd_chr, l))
                    plot_len += l // bin_size + 1
            rd_mean, stdev = io.rd_normal_level(bin_size, rd_flag)
            tl = 0
            dt = 2.0 * np.pi / plot_len
            theta = np.arange(0, 2.0 * np.pi, dt)
            angles = []
            labels = []
            for j in range(len(plot_chroms)):
                c, l = plot_chroms[j]
                next_color = rainbow.get_next_color()
                rd_color = self.rd_circular_colors[j % len(self.rd_circular_colors)]
                snp_color = self.snp_circular_colors[j % len(self.snp_circular_colors)]
                rd = io.get_signal(c, bin_size, &#34;RD&#34;, rd_flag)
                maf = io.get_signal(c, bin_size, &#34;SNP maf&#34;, snp_flag)
                c01 = io.get_signal(c, bin_size, &#34;SNP bin count 0|1&#34;, snp_flag)
                c10 = io.get_signal(c, bin_size, &#34;SNP bin count 1|0&#34;, snp_flag)
                hets = c01 + c10
                np.warnings.filterwarnings(&#39;ignore&#39;)
                maf[hets &lt; (bin_size / 10000)] = 0
                # plt.polar(theta[tl:tl + maf.size], 1 - maf / 2, color=snp_color, linewidth=0.3)
                # plt.fill_between(theta[tl:tl + maf.size], 1 - maf / 2, np.ones_like(maf), color=snp_color, alpha=0.8)
                plt.polar(theta[tl:tl + maf.size], 1 - maf / 2, linewidth=0.3, color=next_color)
                plt.fill_between(theta[tl:tl + maf.size], 1 - maf / 2, np.ones_like(maf), alpha=1, color=next_color)
                markersize = 5
                if self.markersize != &#34;auto&#34;:
                    markersize = self.markersize
                ax.scatter(theta[tl:tl + rd.size], np.ones_like(rd) / 10. + 0.7 * rd / (self.rd_range[1] * rd_mean / 2),
                           s=markersize, alpha=0.7, color=next_color)

                # plt.polar(theta[tl:tl + rd.size], np.ones_like(rd) / 10. + 0.7 * rd / (self.rd_range[1] * rd_mean / 2),
                #          color=rd_color, linewidth=0.3)
                # plt.fill_between(theta[tl:tl + rd.size], np.ones_like(rd) / 10.,
                #                 np.ones_like(rd) / 10. + 0.7 * rd / (self.rd_range[1] * rd_mean / 2),
                #                 color=rd_color,
                #                 alpha=0.8)

                # ax.text(theta[tl + maf.size // 3], 0.8, c, fontsize=8)
                labels.append(Genome.canonical_chrom_name(c))
                angles.append(180 * theta[tl + rd.size // 2] / np.pi)
                tl += l // bin_size + 1
            for cn in range(int(self.rd_range[1])):
                plt.polar(theta, np.ones_like(theta) * (0.1 + 0.7 * (cn / self.rd_range[1])), color=&#34;k&#34;, linewidth=0.1)
            ax.set_rmax(1.0)
            ax.set_rticks([])
            ax.set_thetagrids(angles, labels=labels, fontsize=10, weight=&#34;bold&#34;, color=&#34;black&#34;)
            ax.set_title(self.file_title(ix[i]), loc=&#34;left&#34;, fontsize=10, weight=&#34;bold&#34;, color=&#34;black&#34;)
            ax.grid(False)
        self.fig_show(suffix=&#34;circular&#34;)

    def rd_baf(self, hist=True):
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, figsize=(12, 8), facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        n = len(self.plot_files)
        ix = self.plot_files
        if self.grid == &#34;auto&#34;:
            sx, sy = self._panels_shape(n)
        else:
            sx, sy = tuple(self.grid)
        grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        bin_size = self.bin_size
        for i in range(n):
            ax = self.fig.add_subplot(grid[i])
            io = self.io[ix[i]]

            chroms = []
            snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                FLAG_USEHAP if self.snp_use_phase else 0)
            rd_flag = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = io.snp_chromosome_name(c)
                if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                    if io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood call&#34;, snp_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood segments&#34;, snp_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;RD mosaic call&#34;, rd_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;RD mosaic segments&#34;, rd_flag) and \
                            Genome.is_autosome(c):
                        chroms.append((snp_chr, l))
            x = []
            y = []
            for c, l in chroms:
                flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO

                likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                segments_baf = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
                rd = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;, rd_flag)
                segments_rd = segments_decode(io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;, rd_flag))

                mbaf = {}
                mrd = {}
                for s, lh in zip(segments_baf, likelihood):
                    b, p = likelihood_baf_pval(lh)
                    for pos in s:
                        mbaf[pos] = 0.5 - b
                for s, r in zip(segments_rd, rd[0]):
                    for pos in s:
                        mrd[pos] = r
                for p in mbaf:
                    if p in mrd:
                        x.append(mbaf[p])
                        y.append(mrd[p])

            if hist:
                from matplotlib.colors import LogNorm
                ax.hist2d(x, y, bins=[np.arange(0, 0.51, 0.01), np.arange(0, max(y), max(y) / 100.)], norm=LogNorm())
            else:
                ax.scatter(x, y, marker=&#34;.&#34;, alpha=0.5)

        if self.output_filename != &#34;&#34;:
            plt.savefig(self._image_filename(&#34;rd_baf&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def dispersion(self, legend=True):
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(8)
            self.fig.set_figwidth(12)
        grid = gridspec.GridSpec(1, 2, wspace=0.2, hspace=0.2)

        ax = self.fig.add_subplot(grid[0])
        for i in self.io:
            bin_sizes = sorted(set([int(x[1]) for x in i.chromosomes_bin_sizes_with_signal(&#34;RD&#34;)]))
            rd = []
            drd = []
            for bs in bin_sizes:
                if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO):
                    stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO)
                    rd.append(stat[4])
                    drd.append(stat[5])
            ax.set_yscale(&#34;log&#34;)
            ax.set_xscale(&#34;log&#34;)
            ax.grid(True)
            ax.set_xlabel(&#34;mean RD&#34;)
            ax.set_ylabel(&#34;stdev RD&#34;)
            if legend:
                ax.legend(loc=&#34;upper left&#34;)
            ax.plot(rd, drd, &#34;*-&#34;, label=i.filename)

        ax = self.fig.add_subplot(grid[1])
        for i in self.io:
            bin_sizes = sorted(set([int(x[1]) for x in i.chromosomes_bin_sizes_with_signal(&#34;RD&#34;)]))
            rd = []
            drd = []
            for bs in bin_sizes:
                if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO | FLAG_GC_CORR):
                    stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO | FLAG_GC_CORR)
                    rd.append(stat[4])
                    drd.append(stat[5])
            ax.set_yscale(&#34;log&#34;)
            ax.set_xscale(&#34;log&#34;)
            ax.grid(True)
            ax.set_xlabel(&#34;mean RD (GC corr)&#34;)
            ax.set_ylabel(&#34;stdev RD (GC corr)&#34;)
            if legend:
                ax.legend(loc=&#34;upper left&#34;)
            ax.plot(rd, drd, &#34;*-&#34;, label=i.filename)

        if self.output_filename != &#34;&#34;:
            plt.savefig(self._image_filename(&#34;dispersion&#34;), dpi=200)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def region_rd_stat(self, region, n_bins=21, plot=False, legend=True):
        n = len(self.plot_files)
        ix = self.plot_files
        if plot:
            plt.clf()
            plt.rcParams[&#34;font.size&#34;] = 8
            if self.grid == &#34;auto&#34;:
                sx, sy = self._panels_shape(n)
            else:
                sx, sy = tuple(self.grid)
            self.fig = plt.figure(1, dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
            if self.output_filename != &#34;&#34;:
                self.fig.set_figheight(3 * sy)
                self.fig.set_figwidth(4 * sx)
            grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        for i in range(n):
            io = self.io[ix[i]]
            if plot:
                ax = self.fig.add_subplot(grid[i])
                ax.set_title(self.file_title(ix[i]), position=(0.01, 1.07),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            regs = decode_region(region)
            data = []
            for c, (pos1, pos2) in regs:
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size
                data += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])

            data = np.array(data)
            dmin = np.min(data)
            dmax = np.max(data)
            p1 = np.percentile(data, 1)
            p99 = np.percentile(data, 99)
            data = data[data &gt; p1]
            data = data[data &lt; p99]
            mean = np.mean(data)
            std = np.std(data)

            rd_min = mean - 5 * std
            rd_max = mean + 5 * std
            bins = np.linspace(rd_min, rd_max, n_bins)

            hist, binsr = np.histogram(data, bins=bins)

            fitn, fitm, fits = fit_normal(bins[:-1], hist)[0]

            print(&#34;%s\t%s\t%.4f\t%.4f\t%e\t%e\t%.4f\t%.4f\t%.4f\t%.4f&#34; % (
                io.filename, region, fitm, fits, dmin, dmax, p1, p99, mean, std))

            if plot:
                x = np.linspace(bins[0], bins[-1], 1001)
                plt.plot(x, normal(x, fitn, fitm, fits), &#34;g-&#34;, label=region)
                plt.plot(bins[:-1], hist, &#34;b*&#34;)
                if legend:
                    plt.legend()

        if plot:
            if self.output_filename != &#34;&#34;:
                plt.savefig(self._image_filename(&#34;comp&#34;), dpi=200)
                plt.close(self.fig)
            elif self.interactive:
                plt.show(block=False)
                plt.draw()
            else:
                plt.show()

    def compare(self, region1, region2, n_bins=21, plot=False, stdout=True, legend=True):
        n = len(self.plot_files)
        ix = self.plot_files
        ret = []

        if plot:
            plt.clf()
            plt.rcParams[&#34;font.size&#34;] = 8
            if self.grid == &#34;auto&#34;:
                sx, sy = self._panels_shape(n)
            else:
                sx, sy = tuple(self.grid)
            self.fig = plt.figure(1, dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
            if self.output_filename != &#34;&#34;:
                self.fig.set_figheight(3 * sy)
                self.fig.set_figwidth(4 * sx)
            grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        for i in range(n):
            io = self.io[ix[i]]
            if plot:
                ax = self.fig.add_subplot(grid[i])
                ax.set_title(self.file_title(ix[i]), position=(0.01, 1.07),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            regs1 = decode_region(region1)
            regs2 = decode_region(region2)
            data1 = []
            data2 = []
            for c, (pos1, pos2) in regs1:
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size
                data1 += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])
            for c, (pos1, pos2) in regs2:
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size
                data2 += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])

            data1 = np.array(data1)
            p1_1 = np.percentile(data1, 1)
            p99_1 = np.percentile(data1, 99)
            data1 = data1[data1 &gt; p1_1]
            data1 = data1[data1 &lt; p99_1]
            mean1 = np.mean(data1)
            std1 = np.std(data1)

            data2 = np.array(data2)
            p1_2 = np.percentile(data2, 1)
            p99_2 = np.percentile(data2, 99)
            data2 = data2[data2 &gt; p1_2]
            data2 = data2[data2 &lt; p99_2]
            mean2 = np.mean(data2)
            std2 = np.std(data2)

            rd_min = min(mean1 - 5 * std1, mean2 - 5 * std2)
            rd_max = max(mean1 + 5 * std1, mean2 + 5 * std2)
            bins = np.linspace(rd_min, rd_max, n_bins)

            hist1, binsr = np.histogram(data1, bins=bins)
            hist2, binsr = np.histogram(data2, bins=bins)

            fitn1, fitm1, fits1 = fit_normal(bins[:-1], hist1)[0]
            fitn2, fitm2, fits2 = fit_normal(bins[:-1], hist2)[0]

            pval = t_test_2_samples(fitm1, fits1, sum(hist1), fitm2, fits2, sum(hist2))

            if stdout:
                print(&#34;%s\t%s\t%s\t%.4f\t%.4f\t%.4f\t%.4f\t%e\t%.4f\t%.4f&#34; % (
                    io.filename, region1, region2, fitm1, fits1, fitm2, fits2, pval, fitm1 / fitm2,
                    fitm1 / fitm2 * (fits1 / fitm1 / np.sqrt(sum(hist1)) + fits2 / fitm2 / np.sqrt(sum(hist2)))))
            ret.append([io.filename, region1, region2, fitm1, fits1, fitm2, fits2, pval, fitm1 / fitm2,
                        fitm1 / fitm2 * (fits1 / fitm1 / np.sqrt(sum(hist1)) + fits2 / fitm2 / np.sqrt(sum(hist2)))])

            if plot:
                x = np.linspace(bins[0], bins[-1], 1001)
                plt.plot(x, normal(x, fitn1, fitm1, fits1), &#34;g-&#34;, label=region1)
                plt.plot(x, normal(x, fitn2, fitm2, fits2), &#34;b-&#34;, label=region2)
                plt.plot(bins[:-1], hist1, &#34;g*&#34;)
                plt.plot(bins[:-1], hist2, &#34;b*&#34;)
                if legend:
                    plt.legend()

        if plot:
            if self.output_filename != &#34;&#34;:
                plt.savefig(self._image_filename(&#34;comp&#34;), dpi=200)
                plt.close(self.fig)
            elif self.interactive:
                plt.show(block=False)
                plt.draw()
            else:
                plt.show()

        return ret

    def compare_baf(self, region1, region2, plot=False, stdout=True, legend=True):
        n = len(self.plot_files)
        ix = self.plot_files
        ret = []

        if plot:
            plt.clf()
            plt.rcParams[&#34;font.size&#34;] = 8
            if self.grid == &#34;auto&#34;:
                sx, sy = self._panels_shape(n)
            else:
                sx, sy = tuple(self.grid)
            self.fig = plt.figure(1, dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
            if self.output_filename != &#34;&#34;:
                self.fig.set_figheight(3 * sy)
                self.fig.set_figwidth(4 * sx)
            grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        for i in range(n):
            io = self.io[ix[i]]
            if plot:
                ax = self.fig.add_subplot(grid[i])
                ax.set_title(self.file_title(ix[i]), position=(0.01, 1.07),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            regs1 = decode_region(region1)
            regs2 = decode_region(region2)
            data1 = []
            data2 = []
            for c, (pos1, pos2) in regs1:
                flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;SNP likelihood&#34;, flag)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size
                data1 += list(his_p[bin1:bin2 + 1])
            for c, (pos1, pos2) in regs2:
                flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;SNP likelihood&#34;, flag)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size

                data2 += list(his_p[bin1:bin2 + 1])

            d1 = np.array(data1)
            d2 = np.array(data2)
            h1 = np.ones_like(d1[0])
            h2 = np.ones_like(d2[0])
            for i in range(len(d1)):
                if sum(d1[i]) != 0:
                    h1 *= d1[i]
                h1 /= sum(h1)
            for i in range(len(d2)):
                if sum(d2[i]) != 0:
                    h2 *= d2[i]
                h2 /= sum(h2)

            b1, p1 = likelihood_baf_pval(h1)
            b2, p2 = likelihood_baf_pval(h2)

            if stdout:
                print(&#34;%s\t%s\t%s\t%.4f\t%e\t%.4f\t%e&#34; % (
                    io.filename, region1, region2, b1, p1, b2, p2))
            ret.append([io.filename, region1, region2, b1, p1, b2, p2])

            if plot:
                plt.plot(h1, &#34;g&#34;)
                plt.plot(h2, &#34;b&#34;)

        if plot:
            if self.output_filename != &#34;&#34;:
                plt.savefig(self._image_filename(&#34;comp_baf&#34;), dpi=200)
                plt.close(self.fig)
            elif self.interactive:
                plt.show(block=False)
                plt.draw()
            else:
                plt.show()

        return ret

    def single_cell_allelic_dropout(self, callset=None, res=1000, n_bins=100, threshold=0.1, snp_threshold=0.01,
                                    neigh=False, plot=False, stdout=True, title=None):
        &#34;&#34;&#34;
        Function used to identify regions without allelic dropout in the case of single cell amplification.
        It requires baf data for bin size. It will filter out all bins with at least one SNP bellow snp_threshold and
        all bins with collective maximum baf likelihood bellow threshold parameter.

        Parameters
        ----------
        callset : str or None
            Name of callset if not default.
        res : int
            Resolution in bins used to calculate percentage of dropouts in region.
        n_bins : int
            Number of bins in histograms.
        threshold : float
            Collective threshold of AF for allelic dropout
        snp_threshold : float
            Single SNP threshold of AF for allelic dropout
        neigh : bool
            Remove neighbouring bins also.
        plot : bool
            Make plots.
        stdout : bool
            Print out good regions

        &#34;&#34;&#34;

        if plot:
            self.new_figure(panel_count=2, panel_size=(16, 6), title=title)
            ax = self.next_panel()
            bafG = []
            baf = []
            cpos = 0
            sizeG = []
            sizeB = []
        for c in self.io[self.plot_file].snp_chromosomes():
            if len(self.chrom) == 0 or (c in self.chrom):
                snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                    FLAG_USEHAP if self.snp_use_phase else 0)
                i1 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP i1&#34;, snp_flag)
                pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_file].read_snp(c, callset=callset)
                c00 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP bin count 0|0&#34;, snp_flag)
                c11 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP bin count 1|1&#34;, snp_flag)
                homs = c00 + c11
                c01 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP bin count 0|1&#34;, snp_flag)
                c10 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP bin count 1|0&#34;, snp_flag)
                hets = c01 + c10
                count = c01 + c10 + c00 + c11
                mask = np.zeros_like(i1)
                density = np.zeros(len(mask) // res)
                # mask[hets == 0] = 1
                mask[hets == 0] = 2
                mask[i1 &gt; (0.5 - threshold)] = 1
                for ix in range(len(pos)):
                    if (nref[ix] + nalt[ix]) != 0 and ((gt[ix] % 4) in [1, 2]):
                        b = 1.0 * nalt[ix] / (nref[ix] + nalt[ix])
                        if (b &lt; snp_threshold) or (b &gt; (1 - snp_threshold)):
                            mask[(pos[ix] - 1) // self.bin_size] = 1

                if neigh:
                    ada = mask == 1
                    ada1 = np.roll(ada, 1)
                    ada2 = np.roll(ada, -1)
                    ada1[0] = False
                    ada2[-1] = False
                    mask[ada1] = 1
                    mask[ada2] = 1
                ix = 0
                while ix &lt; len(mask):
                    if mask[ix] == 2:
                        adan = 0
                        if ix &gt; 0 and mask[ix - 1] == 1:
                            adan = 1
                        jx = ix
                        while jx &lt; len(mask) and mask[jx] == 2:
                            jx += 1
                        if jx &lt; len(mask) and mask[jx] == 1:
                            adan = 1
                        mask[ix:jx] = adan
                        ix = jx
                    else:
                        ix += 1
                ix = 0
                ojx = 0
                while ix &lt; len(mask):
                    if mask[ix] == 0:
                        jx = ix
                        while jx &lt; len(mask) and mask[jx] == 0:
                            jx += 1
                        if stdout:
                            print(&#34;%s\t%d\t%d&#34; % (c, ix * self.bin_size + 1, jx * self.bin_size))
                        sizeG.append((jx - ix) * self.bin_size)
                        if ix &gt; ojx:
                            sizeB.append((ix - ojx) * self.bin_size)
                        ojx = jx
                        ix = jx
                    else:
                        ix += 1
                if plot:
                    for ix in range(len(density)):
                        density[ix] = np.mean(mask[res * ix:res * (ix + 1)])
                    ax.plot(np.arange(cpos, cpos + len(density)) * res, density)
                    cpos += len(density)
                    for ix in range(len(pos)):
                        if (nref[ix] + nalt[ix]) != 0 and ((gt[ix] % 4) in [1, 2]):
                            baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            if mask[(pos[ix] - 1) // self.bin_size] == 0:
                                bafG.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
        ax.set_xlabel(&#34;Position in genome [bins]&#34;)
        ax.set_ylabel(&#34;Percentage of allelic dropout&#34;)
        ax.grid(True)
        if plot:
            self.new_subgrid(2, grid=&#34;horizontal&#34;, hspace=0.05, wspace=0.2)
            ax = self.next_subpanel()
            ms = 5 * max(np.mean(sizeG), np.mean(sizeB))
            ax.hist(sizeB, bins=np.arange(1, ms, self.bin_size), histtype=&#34;step&#34;, log=True,
                    label=&#34;Allelic dropout regions&#34;, linewidth=3)
            ax.hist(sizeG, bins=np.arange(1, ms, self.bin_size), histtype=&#34;step&#34;, log=True,
                    label=&#34;Region with both alleles&#34;, linewidth=3)
            ax.legend()
            ax.grid(True)
            ax.set_xlabel(&#34;Size [bp]&#34;)
            ax.set_ylabel(&#34;Number of regions&#34;)
            self.fig.add_subplot(ax)

            ax = self.next_subpanel()
            ax.hist(baf, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)),
                    label=&#34;All heterozygous variants&#34;)
            ax.hist(bafG, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)),
                    label=&#34;Region with both alleles&#34;)
            ax.legend()
            ax.grid(True)
            ax.set_xlabel(&#34;VAF&#34;)
            ax.set_ylabel(&#34;Distribution&#34;)
            self.fig.add_subplot(ax)

            self.fig_show(suffix=&#34;allelic_dropout&#34;)

    def compare_rd_dist(self, regions):
        self.new_figure(panel_count=1)
        ax = self.next_panel()
        ax.set_ylabel(&#34;Normalised distribution&#34;)
        ax.set_xlabel(&#34;Difference in copy number&#34;)
        regs = decode_region(regions)
        io1 = self.io[self.plot_files[0]]
        io2 = self.io[self.plot_files[1]]
        bin_size = self.bin_size
        drd = []
        for c, (pos1, pos2) in regs:
            flag_rd = 0
            if self.rd_use_mask:
                flag_rd = FLAG_USEMASK
            mean1, stdev = io1.rd_normal_level(bin_size, flag_rd | FLAG_GC_CORR)
            mean2, stdev = io2.rd_normal_level(bin_size, flag_rd | FLAG_GC_CORR)
            his_p_corr1 = io1.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            his_p_corr2 = io2.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            for i in range(len(his_p_corr1)):
                drd.append(his_p_corr1[i] * 2 / mean1 - his_p_corr2[i] * 2 / mean2)

        # for i in range(n):
        #     io = self.io[ix[i]]
        #     stat = self.io[self.plot_file].get_signal(None, self.bin_size, &#34;RD stat&#34;, FLAG_AUTO)
        #     his_p = io.get_signal(None, self.bin_size, &#34;RD p dist&#34;, FLAG_AUTO)
        #     bin_size = int(stat[1])
        #     max_rd = int(stat[0])
        #     lim_rd = int(max(2 * stat[4], stat[4] + 3 * stat[5]))
        #     ax.set_xlim([0, lim_rd])
        #     bins = range(0, 2*max_rd + 5*bin_size, bin_size)
        #     x = np.arange(0, max_rd // bin_size * bin_size, 0.1 * bin_size)
        #     #plt.plot(x, normal(x, 1, stat[4], stat[5]), &#34;g-&#34;)
        #     x = np.array(bins)
        #     plt.plot(x[1:len(his_p)], his_p[1:] / stat[3],label = io.filename)
        ax.hist(drd, bins=np.linspace(-0.5, 0.5, 100))
        # ax.legend()
        ax.set_yticklabels([])
        ax.grid()
        self.fig_show(suffix=&#34;compare_rd&#34;)

    def snp_dist(self, regions, callset=None, n_bins=100, gt_plot=[0, 1, 2, 3], titles=None, beta_distribution=False,
                 log_scale=False):
        nf = len(self.plot_files)
        regions = regions.split(&#34; &#34;)
        nr = len(regions)
        n = nf * nr
        self.new_figure(panel_count=n)
        for ii in range(nf):
            for i in range(nr):
                ax = self.next_panel()
                if titles is None:
                    ax.set_title(self.file_title(self.plot_files[ii]) + &#34;: &#34; + regions[i], position=(0.01, 1.10),
                                 fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
                else:
                    ax.set_title(titles[i], position=(0.01, 1.10),
                                 fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
                regs = decode_region(regions[i])
                baf = []
                bafP = []
                bafNP = []
                mean_rd = 0
                for c, (pos1, pos2) in regs:
                    pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_files[ii]].read_snp(c,
                                                                                                      callset=callset)
                    ix = 0
                    while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                        if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0 and ((gt[ix] % 4) in gt_plot):
                            if gt[ix] % 4 != 2:
                                baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                                if flag[ix] &amp; 2:
                                    bafP.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                                    mean_rd += nref[ix] + nalt[ix]
                                else:
                                    bafNP.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            else:
                                baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                                if flag[ix] &amp; 2:
                                    bafP.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                                    mean_rd += nref[ix] + nalt[ix]
                                else:
                                    bafNP.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                        ix += 1
                mean_rd /= len(bafP)
                x_bins = np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1))
                ax.hist(baf, bins=x_bins, label=&#34;All heterozygous variants&#34;)
                ax.hist(bafP, bins=x_bins, label=&#34;P bases only&#34;)
                # ax.hist(bafNP, bins=x_bins, label=&#34;non-P bases only&#34;, histtype=u&#39;step&#39;)
                if log_scale:
                    plt.yscale(&#39;log&#39;, nonposy=&#39;clip&#39;)

                if beta_distribution:
                    xx = np.linspace(0.2, 0.8, 200)
                    ax.plot(xx, beta.pdf(xx, mean_rd / 2, mean_rd / 2) * len(bafP) / n_bins, c=&#34;black&#34;,
                            label=&#34;Beta distribution&#34;)
                ax.legend(bbox_to_anchor=(0, 1.02, 1, 0.2), loc=&#34;lower left&#34;, mode=&#34;expand&#34;, borderaxespad=0, ncol=3)
                ax.set_xlabel(&#34;VAF&#34;)
                ax.set_ylabel(&#34;Distribution&#34;)

        self.fig_show(suffix=&#34;snp_dist&#34;)

    def phased_baf(self, regions, callset=None, print=False):
        regions = regions.split(&#34; &#34;)
        n = len(regions)
        ret = []
        for i in range(n):
            regs = decode_region(regions[i])
            talt = 0
            tref = 0
            taltP = 0
            trefP = 0
            for c, (pos1, pos2) in regs:
                pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_file].read_snp(c, callset=callset)
                ix = 0
                while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                    if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0:
                        if gt[ix] == 5:
                            talt += nalt[ix]
                            tref += nref[ix]
                            if flag[ix] &amp; 2:
                                taltP += nalt[ix]
                                trefP += nref[ix]
                        elif gt[ix] == 6:
                            tref += nalt[ix]
                            talt += nref[ix]
                            if flag[ix] &amp; 2:
                                trefP += nalt[ix]
                                taltP += nref[ix]
                    ix += 1
            baf = talt / (tref + talt)
            bafP = taltP / (trefP + taltP)
            ret.append([baf, bafP])
            if print:
                print(&#34;%s\t%f\t%f&#34; % (regions[i], baf, bafP))
        return ret

    def snp_compare(self, regions, ix1, ix2, callset=None, n_bins=100, titles=None, test_loh=False):
        regions = regions.split(&#34; &#34;)
        n = len(regions)
        self.new_figure(panel_count=n)
        for i in range(n):
            ax = self.next_panel()
            if titles is None:
                ax.set_title(regions[i], position=(0.01, 1.07),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            else:
                ax.set_title(titles[i], position=(0.01, 1.07),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            regs = decode_region(regions[i])
            oval = []
            for c, (pos_start, pos_end) in regs:
                pos1, ref1, alt1, nref1, nalt1, gt1, flag1, qual1 = self.io[ix1].read_snp(c, callset=callset)
                pos2, ref2, alt2, nref2, nalt2, gt2, flag2, qual2 = self.io[ix2].read_snp(c, callset=callset)

                counts1 = {}
                counts2 = {}
                ix = 0
                while ix &lt; len(pos1) and pos1[ix] &lt;= pos_end:
                    if pos1[ix] &gt;= pos_start and (nref1[ix] + nalt1[ix]) != 0:
                        counts1[pos1[ix]] = (nref1[ix] / np.sqrt(nref1[ix] ** 2 + nalt1[ix] ** 2),
                                             nalt1[ix] / np.sqrt(nref1[ix] ** 2 + nalt1[ix] ** 2))
                    ix += 1
                ix = 0
                xx = []
                yy = []
                cc = []
                hist1 = []
                hist2 = []
                while ix &lt; len(pos2) and pos2[ix] &lt;= pos_end:
                    if pos2[ix] &gt;= pos_start and (nref2[ix] + nalt2[ix]) != 0:
                        counts2[pos2[ix]] = (nref2[ix], nalt2[ix])
                    ix += 1
                for p in counts1:
                    if p in counts2:
                        xx.append(p)
                        yy.append(counts1[p][1] / (counts1[p][0] + counts1[p][1]))
                        cc.append(&#34;green&#34;)
                        xx.append(p)
                        yy.append(counts2[p][1] / (counts2[p][0] + counts2[p][1]))
                        cc.append(&#34;blue&#34;)
                        if counts2[p][1] / (counts2[p][0] + counts2[p][1]) &gt; 0.8:
                            t = counts1[p][1] / (counts1[p][0] + counts1[p][1])
                            if t &gt; 0.2 and t &lt; 0.8:
                                hist1.append(t)
                        else:
                            t = counts1[p][1] / (counts1[p][0] + counts1[p][1])
                            if t &gt; 0.2 and t &lt; 0.8:
                                hist2.append(t)
                    else:
                        xx.append(p)
                        yy.append(counts1[p][1] / (counts1[p][0] + counts1[p][1]))
                        cc.append(&#34;red&#34;)
                        t = counts1[p][1] / (counts1[p][0] + counts1[p][1])
                        if t &gt; 0.2 and t &lt; 0.8:
                            hist2.append(t)
                for p in counts2:
                    if not (p in counts1):
                        xx.append(p)
                        yy.append(counts2[p][1] / (counts2[p][0] + counts2[p][1]))
                        cc.append(&#34;orange&#34;)

            if test_loh:
                ax.hist(hist1, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)), histtype=&#39;step&#39;)
                ax.hist(hist2, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)), histtype=&#39;step&#39;)
                print(&#34;H1:&#34;, np.mean(hist1), np.std(hist1), len(hist1))
                print(&#34;H2:&#34;, np.mean(hist2), np.std(hist2), len(hist2))
                ax.set_xlabel(&#34;baf&#34;)
                ax.set_ylabel(&#34;distribnution&#34;)
            else:
                ax.scatter(xx, yy, marker=&#34;.&#34;, s=0.1, c=cc)
                # ax.hist(oval, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)))
                ax.set_xlabel(&#34;position&#34;)
                ax.set_ylabel(&#34;baf&#34;)

        self.fig_show(suffix=&#34;snp_dist&#34;)

    def denovo_calls(self, sample, reference, call_type=&#34;mosaic&#34;):
        bin_size = self.bin_size
        io = self.io[sample]
        if call_type == &#34;mosaic&#34;:
            chroms = io.rd_chromosomes()
            for c in chroms:
                if (c in self.chrom) or len(self.chrom) == 0:
                    flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                    if io.signal_exists(c, bin_size, &#34;calls&#34;, flag):
                        calls = io.read_calls(c, bin_size, &#34;calls&#34;, flag)
                        for call in calls:
                            if in_interval(call[&#34;size&#34;], self.size_range) \
                                    and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                    and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                    and in_interval(call[&#34;Q0&#34;], self.Q0_range):
                                type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;
                                region = &#34;%s:%d-%d&#34; % (c, call[&#34;start&#34;], call[&#34;end&#34;])

                                cn0 = self.genotype([bin_size], region, file_index=sample)[0][3]
                                cref = list(
                                    map(lambda x: self.genotype([bin_size], region, file_index=x)[0][3], reference))
                                if (((sum(map(lambda x: 0 if (cn0 - x) &gt; 0.5 else 1, cref)) == 0) and cn0 &gt; 2.5) \
                                    or ((sum(map(lambda x: 0 if (x - cn0) &gt; 0.5 else 1, cref)) == 0) and cn0 &lt; 1.5)) \
                                        and (sum(map(lambda x: 0 if np.abs(x - 2.) &lt; 0.5 else 1, cref)) == 0):
                                    print(type, region, call[&#34;cnv&#34;], cn0, cref)

                                # if n &gt; 1:
                                #     print(&#34;%s\t&#34; % self.file_title(i), end=&#34;&#34;)
                                # print(&#34;%s\t%s:%d-%d\t%d\t%.4f\t%e\t%e\t%e\t%e\t%.4f\t%.4f\t&#34; % (
                                #     type, c, call[&#34;start&#34;], call[&#34;end&#34;], call[&#34;size&#34;], call[&#34;cnv&#34;], call[&#34;p_val&#34;],
                                #     call[&#34;p_val_2&#34;], call[&#34;p_val_3&#34;], call[&#34;p_val_4&#34;], call[&#34;Q0&#34;], call[&#34;pN&#34;]))

    def genotype(self, bin_sizes, region, p_val=False, interactive=False, file_index=None):
        if file_index is None:
            file_index = self.plot_file
        ret = []
        regs = decode_region(region, max_size=1000000000)
        for c, (pos1, pos2) in regs:
            chr_len = self.io[file_index].get_chromosome_length(c)
            if chr_len is not None and pos2 == 1000000000:
                pos2 = chr_len
            if interactive:
                print(c + &#34;:&#34; + str(pos1) + &#34;-&#34; + str(pos2), end=&#34;&#34;)
            ret.append([c, pos1, pos2])
            for bs in bin_sizes:
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                stat = self.io[file_index].get_signal(c, bs, &#34;RD stat&#34;, flag_rd | FLAG_AUTO)
                if stat is None or len(stat) == 0:
                    stat = self.io[file_index].get_signal(c, bs, &#34;RD stat&#34;, flag_rd | FLAG_SEX)
                his_p = self.io[file_index].get_signal(c, bs, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // bs
                bin2 = (pos2 - 1) // bs
                rc = 0
                rc2 = 0
                if bin1 == bin2:
                    try:
                        rc = (pos2 - pos1 + 1) * his_p[bin1] / bs
                        rc2 = (pos2 - pos1 + 1) * his_p[bin1] * his_p[bin1] / bs
                    except IndexError:
                        pass
                else:
                    try:
                        rc += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] / bs
                        rc += (pos2 - bin2 * bs) * his_p[bin2] / bs
                        rc2 += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] * his_p[bin1] / bs
                        rc2 += (pos2 - bin2 * bs) * his_p[bin2] * his_p[bin2] / bs
                    except IndexError:
                        pass
                    for ix in range(bin1 + 1, bin2):
                        try:
                            rc += his_p[ix]
                            rc2 += his_p[ix] * his_p[ix]
                        except IndexError:
                            pass
                e2 = 0
                if p_val:
                    e1 = getEValue(stat[4], stat[5], his_p, bin1, bin2 + 1) * 2.9e9 / bs
                    e2 = gaussianEValue(stat[4], stat[5], his_p, bin1, bin2 + 1) * 2.9e9
                if interactive:
                    print(&#34;\t%f&#34; % (2. * rc / (stat[4] * (pos2 - pos1 + 1) / bs)), end=&#34;&#34;)
                    if p_val:
                        print(&#34;\t%e\t%e&#34; % (e1, e2), end=&#34;&#34;)

                ret[-1].append(2. * rc / (stat[4] * (pos2 - pos1 + 1) / bs))
                if p_val:
                    ret[-1].append(e2)
            if interactive:
                print()

        return ret

    def genotype_all(self, bin_sizes, regions, interactive=False, file_index=None):
        if file_index is None:
            file_index = self.plot_file
        rd_gc_chromosomes = {}
        for c in self.io_gc.gc_chromosomes():
            rd_name = self.io[file_index].rd_chromosome_name(c)
            if not rd_name is None:
                rd_gc_chromosomes[rd_name] = c
        ret = {}
        for bs in bin_sizes:
            oc = &#34;&#34;
            ret[bs] = []
            for region in regions:
                regs = decode_region(region, max_size=1000000000)
                c, (pos1, pos2) = regs[0]
                if oc != c:
                    chr_len = self.io[file_index].get_chromosome_length(c)
                    if chr_len is not None and pos2 == 1000000000:
                        pos2 = chr_len
                    flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                    stat = self.io[file_index].get_signal(c, bs, &#34;RD stat&#34;, flag_rd | FLAG_AUTO)
                    if stat is None or len(stat) == 0:
                        stat = self.io[file_index].get_signal(c, bs, &#34;RD stat&#34;, flag_rd | FLAG_SEX)
                    his_p = self.io[file_index].get_signal(c, bs, &#34;RD&#34;, flag_rd)
                    qrd_p = self.io[file_index].get_signal(c, bs, &#34;RD&#34;)
                    qrd_u = self.io[file_index].get_signal(c, bs, &#34;RD unique&#34;)
                    gc, at, distN = False, False, False
                    if c in rd_gc_chromosomes and self.io_gc.signal_exists(rd_gc_chromosomes[c], None, &#34;GC/AT&#34;):
                        gcat = self.io_gc.get_signal(rd_gc_chromosomes[c], None, &#34;GC/AT&#34;)
                        gc, at = gc_at_decompress(gcat)
                        NN = 100 - np.array(gc) - np.array(at)
                        distN = np.zeros_like(NN, dtype=&#34;long&#34;) - 1
                        distN[NN == 100] = 0
                        prev = 0
                        for Ni in range(0, distN.size):
                            if distN[Ni] == -1:
                                prev += 100
                                distN[Ni] = prev
                            else:
                                prev = 0
                        prev = 0
                        for Ni in range(distN.size - 1, -1, -1):
                            if distN[Ni] &gt; 0:
                                prev += 100
                                if prev &lt; distN[Ni]:
                                    distN[Ni] = prev
                            else:
                                prev = 0
                    snp = c in self.io[file_index].snp_chromosomes()
                    snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                        FLAG_USEHAP if self.snp_use_phase else 0)
                    if snp:
                        snp_likelihood = list(
                            self.io[file_index].get_signal(c, bs, &#34;SNP likelihood&#34;, snp_flag).astype(&#34;float64&#34;))
                        snp_hets = self.io[file_index].get_signal(c, bs, &#34;SNP bin count 0|1&#34;, snp_flag)
                        snp_hets += self.io[file_index].get_signal(c, bs, &#34;SNP bin count 1|0&#34;, snp_flag)
                        snp_homs = self.io[file_index].get_signal(c, bs, &#34;SNP bin count 1|1&#34;, snp_flag)
                else:
                    if chr_len is not None and pos2 == 1000000000:
                        pos2 = chr_len
                oc = c
                ret[bs].append([c, pos1, pos2])

                bin1 = (pos1 - 1) // bs
                bin2 = (pos2 - 1) // bs
                rc = 0
                rc2 = 0
                sp = 0
                su = 0
                nansize = 0
                if bin1 == bin2:
                    try:
                        if not np.isnan(his_p[bin1]):
                            rc = (pos2 - pos1 + 1) * his_p[bin1] / bs
                            rc2 = (pos2 - pos1 + 1) * his_p[bin1] * his_p[bin1] / bs
                            sp = (pos2 - pos1 + 1) * qrd_p[bin1] / bs
                            su = (pos2 - pos1 + 1) * qrd_u[bin1] / bs
                            nansize = (pos2 - pos1 + 1)
                    except IndexError:
                        pass
                else:
                    try:
                        if not np.isnan(his_p[bin1]):
                            rc += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] / bs
                            rc2 += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] * his_p[bin1] / bs
                            sp += (bin1 * bs - pos1 + 1 + bs) * qrd_p[bin1] / bs
                            su += (bin1 * bs - pos1 + 1 + bs) * qrd_u[bin1] / bs
                            nansize += (bin1 * bs - pos1 + 1 + bs)
                        if not np.isnan(his_p[bin2]):
                            rc += (pos2 - bin2 * bs) * his_p[bin2] / bs
                            rc2 += (pos2 - bin2 * bs) * his_p[bin2] * his_p[bin2] / bs
                            sp += (pos2 - bin2 * bs) * qrd_p[bin2] / bs
                            su += (pos2 - bin2 * bs) * qrd_u[bin2] / bs
                            nansize += (pos2 - bin2 * bs)

                    except IndexError:
                        pass
                    for ix in range(bin1 + 1, bin2):
                        try:
                            if not np.isnan(his_p[ix]):
                                rc += his_p[ix]
                                rc2 += his_p[ix] * his_p[ix]
                                sp += qrd_p[ix]
                                su += qrd_u[ix]
                                nansize += bs
                        except IndexError:
                            pass
                if gc:
                    sbin1 = (pos1 - 1) // 100
                    sbin2 = (pos2 - 1) // 100
                    pN = 0
                    if bin1 == bin2:
                        try:
                            pN = (pos2 - pos1 + 1) * (gc[sbin1] + at[sbin1]) / 100
                        except IndexError:
                            pass
                    else:
                        try:
                            pN += (sbin1 * 100 - pos1 + 101) * (gc[sbin1] + at[sbin1]) / 100
                            pN += (pos2 - sbin2 * 100) * (gc[sbin2] + at[sbin2]) / 100

                        except IndexError:
                            pass
                        for ix in range(sbin1 + 1, sbin2):
                            try:
                                pN += gc[ix] + at[ix]
                            except IndexError:
                                pass

                e1 = getEValue(stat[4], stat[5], his_p, bin1, bin2 + 1) * 2.9e9 / bs
                e2 = gaussianEValue(stat[4], stat[5], his_p, bin1, bin2 + 1) * 2.9e9
                dG = -1
                if gc:
                    pN = 1 - pN / (pos2 - pos1 + 1)
                    dG = np.min(distN[sbin1:sbin2])
                else:
                    pN = -1
                    dG = -1
                if nansize == 0:
                    rc = np.nan
                else:
                    rc = 2 * rc / (stat[4] * nansize / bs)
                ret[bs][-1].append(rc)
                ret[bs][-1].append(e1)
                ret[bs][-1].append(e2)
                q0 = 0
                if sp != 0:
                    q0 = (sp - su) / sp
                ret[bs][-1].append(q0)
                ret[bs][-1].append(pN)
                ret[bs][-1].append(dG)
                ret[bs][-1].append(nansize / (pos2 - pos1 + 1))
                if snp:
                    homs = np.sum(snp_homs[bin1:bin2 + 1])
                    hets = np.sum(snp_hets[bin1:bin2 + 1])
                    lh = np.ones_like(snp_likelihood[0])
                    for ix in range(bin1, min(bin2 + 1, len(snp_likelihood))):
                        lh *= snp_likelihood[ix]
                        lh /= np.sum(lh)
                    baf, baf_p = likelihood_baf_pval(lh)
                    ret[bs][-1] += [homs, hets, baf, baf_p]
                else:
                    ret[bs][-1] += [0, 0, 0, 1]
        if interactive:
            plist = []
            for bs in bin_sizes:
                if len(plist) == 0:
                    plist = ret[bs]
                else:
                    for ix in range(len(ret[bs])):
                        plist[ix] += ret[bs][ix][3:]
            for r in plist:
                print(
                    (&#34;%s:%d-%d&#34; + (len(bin_sizes) * &#34;\t%.4f\t%e\t%e\t%.4f\t%.4f\t%d\t%.4f\t%d\t%d\t%.4f\t%e&#34;)) % tuple(
                        r))
        return ret

    def genotype_prompt(self, bin_sizes=[], all=False):
        done = False
        while not done:
            try:
                try:
                    line = raw_input(&#34;&#34;)
                except NameError:
                    line = input(&#34;&#34;)
            except EOFError:
                return
            if line is None or line == &#34;&#34;:
                done = True
            else:
                if all:
                    self.genotype_all(bin_sizes, [line], interactive=True)
                else:
                    self.genotype(bin_sizes, line, interactive=True)

    def rd_baf_call_models(self, maxcn=10):
        bin_size = self.bin_size
        n = len(self.plot_files)
        ix = self.plot_files
        self.new_figure(panel_count=n)

        for i in range(n):
            ax = self.next_panel()
            io = self.io[ix[i]]
            ax.set_title(self.file_title(ix[i]), position=(0.1, 0.1),
                         fontdict={&#39;verticalalignment&#39;: &#39;bottom&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})

            chroms = []
            flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                FLAG_USEHAP if self.snp_use_phase else 0) | (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR

            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = io.snp_chromosome_name(c)
                if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                    if (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append((snp_chr, l))

            x = np.linspace(0, 1, 1000)
            master_lh = {}
            for cn in range(maxcn, -1, -1):
                for h1 in range(cn // 2 + 1):
                    h2 = cn - h1
                    mrd = 2 - 2 * x + x * cn
                    np.seterr(divide=&#39;ignore&#39;)
                    mbaf = 0.5 - (1 - x + x * h1) / (2 - 2 * x + (h1 + h2) * x)
                    plt.plot(mbaf, mrd, &#34;-&#34;, label=&#34;%d: %d/%d&#34; % (cn, h1, h2), zorder=6 - cn)

            cix = 0
            cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
            for c, l in chroms:
                call_rd = []
                call_baf = []
                call_label = []
                if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                    calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)

                    for call in calls:
                        if call[&#34;bins&#34;] &gt; self.min_segment_size:
                            call_rd.append(call[&#34;cnv&#34;] * 2)
                            call_baf.append(call[&#34;baf&#34;])
                            call_label.append(c + &#34;:&#34; + str(call[&#34;start&#34;]) + &#34;-&#34; + str(call[&#34;end&#34;]))

                plt.scatter(call_baf, call_rd, s=20, edgecolors=&#39;face&#39;, marker=&#39;.&#39;)
                cix += 1

            ax.set_xlabel(&#34;|Î”BAF|&#34;)
            ax.set_ylabel(&#34;Relative RD level&#34;)

            ax.legend()

            ax.set_ylim([0, maxcn])
            ax.set_xlim([-0.02, 0.5])
            ax.grid()

        self.fig_show(suffix=&#34;models&#34;)


def anim_plot_likelihood(likelihood, segments, n, res, iter, prefix, maxp, minp):
    mm = [[0] * res] * n
    for i in range(len(segments)):
        for b in segments[i]:
            mm[b] = list(likelihood[i])
    fig = plt.figure(1, figsize=(16, 9), dpi=120, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    fig.suptitle(
        &#34;Iter: &#34; + str(iter) + &#34;   /   Segments: &#34; + str(len(segments)) + &#34;   /   Overlap interval: (&#34; + (
                &#39;%.4f&#39; % minp) + &#34;,&#34; + (
                &#39;%.4f&#39; % maxp) + &#34;)&#34;, fontsize=&#39;large&#39;)
    plt.subplot(211)
    plt.ylabel(&#34;BAF&#34;)
    plt.imshow(np.transpose(np.array(mm)), aspect=&#39;auto&#39;)
    plt.tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    plt.yticks([0, 50.5, 101, 151.5, 201], (&#34;1.00&#34;, &#34;0.75&#34;, &#34;0.50&#34;, &#34;0.25&#34;, &#34;0.00&#34;))
    # plt.grid(True,color=&#34;w&#34;)
    plt.subplot(212)
    plt.xlabel(&#34;BAF&#34;)
    plt.ylabel(&#34;Likelihood&#34;)
    plt.xticks([0, 0.25, 0.50, 0.75, 1.0])
    plt.grid(True, color=&#34;b&#34;)
    for i in range(len(likelihood)):
        plt.plot(np.linspace(1. / (res + 1), 1. - 1. / (res + 1), res), likelihood[i])
    plt.savefig(prefix + &#34;_&#34; + str(iter).zfill(4), dpi=150)
    plt.close(fig)


def anim_plot_rd(level, error, segments, n, iter, prefix, maxp, minp, mean):
    rd = [np.nan] * n
    for i in range(len(segments)):
        for b in segments[i]:
            rd[b] = level[i]

    fig = plt.figure(1, figsize=(16, 9), dpi=120, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    fig.suptitle(
        &#34;Iter: &#34; + str(iter) + &#34;   /   Segments: &#34; + str(len(segments)) + &#34;   /   Overlap interval: (&#34; + (
                &#39;%.4f&#39; % minp) + &#34;,&#34; + (
                &#39;%.4f&#39; % maxp) + &#34;)&#34;, fontsize=&#39;large&#39;)
    plt.subplot(211)
    plt.ylabel(&#34;RD&#34;)
    plt.step(range(n), rd, &#34;k&#34;)
    plt.tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    plt.yticks(np.arange(0, 3, 0.5) * mean, [])
    plt.ylim([0, 3 * mean])
    plt.grid(True, color=&#34;grey&#34;)

    plt.subplot(212)
    plt.xlabel(&#34;RD&#34;)
    plt.ylabel(&#34;Likelihood&#34;)
    plt.xticks(np.arange(0, 3, 0.5) * mean, [])
    plt.xlim([0, 3 * mean])
    plt.grid(True, color=&#34;grey&#34;)
    for i in range(len(level)):
        xx = np.linspace(0, 3 * mean, 300)
        yy = normal(xx, 1, level[i], error[i])
        plt.plot(xx, yy)
    plt.savefig(prefix + &#34;_&#34; + str(iter).zfill(4), dpi=150)
    plt.close(fig)


def anim_plot_rd_likelihood(level, error, likelihood, segments, n, res, iter, prefix, maxp, mean):
    rd = [np.nan] * n
    for i in range(len(segments)):
        for b in segments[i]:
            rd[b] = level[i]

    mm = [[0] * res] * n
    for i in range(len(segments)):
        for b in segments[i]:
            mm[b] = list(likelihood[i])

    fig, ax = plt.subplots(2, 2, figsize=(16, 9), dpi=120, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;,
                           gridspec_kw={
                               &#39;width_ratios&#39;: [2, 1],
                               &#39;height_ratios&#39;: [1, 1]})
    fig.suptitle(
        &#34;Iter: &#34; + str(iter) + &#34;   /   Segments: &#34; + str(len(segments)) + &#34;   /   Maximal overlap: &#34; + (
                &#39;%.4f&#39; % maxp), fontsize=&#39;large&#39;)
    ax[0][0].set_ylabel(&#34;RD&#34;)
    ax[0][0].step(range(n), rd, &#34;k&#34;)
    ax[0][0].set_xlim([0, n])
    ax[0][0].tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    ax[0][0].set_yticks(np.arange(0, 3, 0.5) * mean)
    ax[0][0].set_yticklabels([])

    ax[0][0].set_ylim([0, 3 * mean])
    ax[0][0].grid(True, color=&#34;grey&#34;)

    ax[0][1].set_ylabel(&#34;&#34;)
    ax[0][1].set_xlabel(&#34;&#34;)
    ax[0][1].set_yticks(np.arange(0, 3, 0.5) * mean)
    ax[0][1].set_yticklabels([])
    ax[0][1].set_xticklabels([])

    ax[0][1].set_ylim([0, 3 * mean])
    ax[0][1].grid(True, color=&#34;grey&#34;)
    for i in range(len(level)):
        xx = np.linspace(0, 3 * mean, 300)
        yy = normal(xx, 1, level[i], error[i])
        ax[0][1].plot(yy, xx)

    ax[1][0].set_ylabel(&#34;BAF&#34;)
    ax[1][0].imshow(np.transpose(np.array(mm)), aspect=&#39;auto&#39;)
    ax[1][0].tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    ax[1][0].set_yticks([0, 50.5, 101, 151.5, 201])
    ax[1][0].set_yticklabels([&#34;1.00&#34;, &#34;0.75&#34;, &#34;0.50&#34;, &#34;0.25&#34;, &#34;0.00&#34;])

    # plt.grid(True,color=&#34;w&#34;)

    ax[1][1].set_ylabel(&#34;&#34;)
    ax[1][1].set_xlabel(&#34;Likelihood&#34;)
    ax[1][1].set_yticks([0, 0.25, 0.50, 0.75, 1.0])
    ax[1][1].set_yticklabels([])
    ax[1][1].set_xticklabels([])

    ax[1][1].grid(True, color=&#34;b&#34;)
    for i in range(len(likelihood)):
        ax[1][1].plot(likelihood[i], np.linspace(1. / (res + 1), 1. - 1. / (res + 1), res))

    plt.subplots_adjust(bottom=0.1, left=0.1, wspace=0., hspace=0.)

    plt.savefig(prefix + &#34;_&#34; + str(iter).zfill(4), dpi=150)
    plt.close(fig)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cnvpytor.viewer.anim_plot_likelihood"><code class="name flex">
<span>def <span class="ident">anim_plot_likelihood</span></span>(<span>likelihood, segments, n, res, iter, prefix, maxp, minp)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def anim_plot_likelihood(likelihood, segments, n, res, iter, prefix, maxp, minp):
    mm = [[0] * res] * n
    for i in range(len(segments)):
        for b in segments[i]:
            mm[b] = list(likelihood[i])
    fig = plt.figure(1, figsize=(16, 9), dpi=120, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    fig.suptitle(
        &#34;Iter: &#34; + str(iter) + &#34;   /   Segments: &#34; + str(len(segments)) + &#34;   /   Overlap interval: (&#34; + (
                &#39;%.4f&#39; % minp) + &#34;,&#34; + (
                &#39;%.4f&#39; % maxp) + &#34;)&#34;, fontsize=&#39;large&#39;)
    plt.subplot(211)
    plt.ylabel(&#34;BAF&#34;)
    plt.imshow(np.transpose(np.array(mm)), aspect=&#39;auto&#39;)
    plt.tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    plt.yticks([0, 50.5, 101, 151.5, 201], (&#34;1.00&#34;, &#34;0.75&#34;, &#34;0.50&#34;, &#34;0.25&#34;, &#34;0.00&#34;))
    # plt.grid(True,color=&#34;w&#34;)
    plt.subplot(212)
    plt.xlabel(&#34;BAF&#34;)
    plt.ylabel(&#34;Likelihood&#34;)
    plt.xticks([0, 0.25, 0.50, 0.75, 1.0])
    plt.grid(True, color=&#34;b&#34;)
    for i in range(len(likelihood)):
        plt.plot(np.linspace(1. / (res + 1), 1. - 1. / (res + 1), res), likelihood[i])
    plt.savefig(prefix + &#34;_&#34; + str(iter).zfill(4), dpi=150)
    plt.close(fig)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.anim_plot_rd"><code class="name flex">
<span>def <span class="ident">anim_plot_rd</span></span>(<span>level, error, segments, n, iter, prefix, maxp, minp, mean)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def anim_plot_rd(level, error, segments, n, iter, prefix, maxp, minp, mean):
    rd = [np.nan] * n
    for i in range(len(segments)):
        for b in segments[i]:
            rd[b] = level[i]

    fig = plt.figure(1, figsize=(16, 9), dpi=120, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    fig.suptitle(
        &#34;Iter: &#34; + str(iter) + &#34;   /   Segments: &#34; + str(len(segments)) + &#34;   /   Overlap interval: (&#34; + (
                &#39;%.4f&#39; % minp) + &#34;,&#34; + (
                &#39;%.4f&#39; % maxp) + &#34;)&#34;, fontsize=&#39;large&#39;)
    plt.subplot(211)
    plt.ylabel(&#34;RD&#34;)
    plt.step(range(n), rd, &#34;k&#34;)
    plt.tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    plt.yticks(np.arange(0, 3, 0.5) * mean, [])
    plt.ylim([0, 3 * mean])
    plt.grid(True, color=&#34;grey&#34;)

    plt.subplot(212)
    plt.xlabel(&#34;RD&#34;)
    plt.ylabel(&#34;Likelihood&#34;)
    plt.xticks(np.arange(0, 3, 0.5) * mean, [])
    plt.xlim([0, 3 * mean])
    plt.grid(True, color=&#34;grey&#34;)
    for i in range(len(level)):
        xx = np.linspace(0, 3 * mean, 300)
        yy = normal(xx, 1, level[i], error[i])
        plt.plot(xx, yy)
    plt.savefig(prefix + &#34;_&#34; + str(iter).zfill(4), dpi=150)
    plt.close(fig)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.anim_plot_rd_likelihood"><code class="name flex">
<span>def <span class="ident">anim_plot_rd_likelihood</span></span>(<span>level, error, likelihood, segments, n, res, iter, prefix, maxp, mean)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def anim_plot_rd_likelihood(level, error, likelihood, segments, n, res, iter, prefix, maxp, mean):
    rd = [np.nan] * n
    for i in range(len(segments)):
        for b in segments[i]:
            rd[b] = level[i]

    mm = [[0] * res] * n
    for i in range(len(segments)):
        for b in segments[i]:
            mm[b] = list(likelihood[i])

    fig, ax = plt.subplots(2, 2, figsize=(16, 9), dpi=120, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;,
                           gridspec_kw={
                               &#39;width_ratios&#39;: [2, 1],
                               &#39;height_ratios&#39;: [1, 1]})
    fig.suptitle(
        &#34;Iter: &#34; + str(iter) + &#34;   /   Segments: &#34; + str(len(segments)) + &#34;   /   Maximal overlap: &#34; + (
                &#39;%.4f&#39; % maxp), fontsize=&#39;large&#39;)
    ax[0][0].set_ylabel(&#34;RD&#34;)
    ax[0][0].step(range(n), rd, &#34;k&#34;)
    ax[0][0].set_xlim([0, n])
    ax[0][0].tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    ax[0][0].set_yticks(np.arange(0, 3, 0.5) * mean)
    ax[0][0].set_yticklabels([])

    ax[0][0].set_ylim([0, 3 * mean])
    ax[0][0].grid(True, color=&#34;grey&#34;)

    ax[0][1].set_ylabel(&#34;&#34;)
    ax[0][1].set_xlabel(&#34;&#34;)
    ax[0][1].set_yticks(np.arange(0, 3, 0.5) * mean)
    ax[0][1].set_yticklabels([])
    ax[0][1].set_xticklabels([])

    ax[0][1].set_ylim([0, 3 * mean])
    ax[0][1].grid(True, color=&#34;grey&#34;)
    for i in range(len(level)):
        xx = np.linspace(0, 3 * mean, 300)
        yy = normal(xx, 1, level[i], error[i])
        ax[0][1].plot(yy, xx)

    ax[1][0].set_ylabel(&#34;BAF&#34;)
    ax[1][0].imshow(np.transpose(np.array(mm)), aspect=&#39;auto&#39;)
    ax[1][0].tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    ax[1][0].set_yticks([0, 50.5, 101, 151.5, 201])
    ax[1][0].set_yticklabels([&#34;1.00&#34;, &#34;0.75&#34;, &#34;0.50&#34;, &#34;0.25&#34;, &#34;0.00&#34;])

    # plt.grid(True,color=&#34;w&#34;)

    ax[1][1].set_ylabel(&#34;&#34;)
    ax[1][1].set_xlabel(&#34;Likelihood&#34;)
    ax[1][1].set_yticks([0, 0.25, 0.50, 0.75, 1.0])
    ax[1][1].set_yticklabels([])
    ax[1][1].set_xticklabels([])

    ax[1][1].grid(True, color=&#34;b&#34;)
    for i in range(len(likelihood)):
        ax[1][1].plot(likelihood[i], np.linspace(1. / (res + 1), 1. - 1. / (res + 1), res))

    plt.subplots_adjust(bottom=0.1, left=0.1, wspace=0., hspace=0.)

    plt.savefig(prefix + &#34;_&#34; + str(iter).zfill(4), dpi=150)
    plt.close(fig)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cnvpytor.viewer.Figure"><code class="flex name class">
<span>class <span class="ident">Figure</span></span>
<span>(</span><span>params, force_agg=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Class implements matplotlib frequently used figure manipulation and plot panels arrangement.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Params to be passed to ViewParam class</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Figure(ViewParams):
    def __init__(self, params, force_agg=False):
        &#34;&#34;&#34; Class implements matplotlib frequently used figure manipulation and plot panels arrangement.

        Parameters
        ----------
        params : dict
            Params to be passed to ViewParam class

        &#34;&#34;&#34;
        if force_agg:
            import matplotlib
            matplotlib.use(&#34;Agg&#34;)
            import matplotlib.pyplot as plt
        ViewParams.__init__(self, params)
        self.fig = None
        self.fig_grid = None
        self.fig_sub_grid = None
        self.count = 0
        self.current = -1
        self.sg_current = -1

    def new_figure(self, panel_count, grid=&#34;auto&#34;, panel_size=None, title=None):
        &#34;&#34;&#34; Clear figure and create new plot layout.

        Parameters
        ----------
        panel_count : int
            Number of panels
        grid : str or (int, int)
            number of columns and rows (sx, sy) or &#34;auto&#34;
        panel_size : (float, float)
            size of a single panel (only when plots in file)

        &#34;&#34;&#34;
        if panel_size is None:
            panel_size = self.panel_size
        if grid == &#34;auto&#34;:
            grid = self.grid
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, dpi=self.dpi, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if title is not None:
            self.fig.suptitle(title, fontsize=16)
        sx, sy = self._get_grid(grid, panel_count)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(panel_size[1] * sy)
            self.fig.set_figwidth(panel_size[0] * sx)
        self.fig_grid = gridspec.GridSpec(sy, sx, hspace=self.margins[5], wspace=self.margins[4])
        self.current = -1
        self.sg_current = -1

    def new_subgrid(self, panel_count, grid=&#34;auto&#34;, hspace=0, wspace=0):
        if grid == &#34;auto&#34;:
            grid = self.subgrid
        sx, sy = self._get_grid(grid, panel_count)
        self.current += 1
        self.fig_sub_grid = gridspec.GridSpecFromSubplotSpec(sy, sx, subplot_spec=self.fig_grid[self.current],
                                                             wspace=wspace, hspace=hspace)
        self.sg_current = -1
        self.sg_current_ax = None

    def next_panel(self):
        &#34;&#34;&#34; Return axes of next panel

        Returns
        -------
        ax : matplotlib.axes.Axes
            Axes for a given panel
        &#34;&#34;&#34;
        self.current += 1
        return self.fig.add_subplot(self.fig_grid[self.current])

    def next_subpanel(self, sharex=False):
        &#34;&#34;&#34; Return axes of next sub panel

        Returns
        -------
        ax : matplotlib.axes.Axes
            Axes for a given panel
        &#34;&#34;&#34;
        self.sg_current += 1
        if self.sg_current == 0 or not sharex:
            self.sg_current_ax = self.fig.add_subplot(self.fig_sub_grid[self.sg_current])
        else:
            self.sg_current_ax = self.fig.add_subplot(self.fig_sub_grid[self.sg_current], sharex=self.sg_current_ax)
        return self.sg_current_ax

    def next_polar_panel(self):
        &#34;&#34;&#34; Return axes of next panel

        Returns
        -------
        ax : matplotlib.axes.Axes
            Axes for a given panel
        &#34;&#34;&#34;
        self.current += 1
        return self.fig.add_subplot(self.fig_grid[self.current], projection=&#34;polar&#34;)

    def get_panel(self, i):
        &#34;&#34;&#34; Returns axes of a i-th panel

        Parameters
        ----------
        i : int
            Panel number

        Returns
        -------
        ax : matplotlib.axes.Axes
            Axes for a given panel

        &#34;&#34;&#34;
        return self.fig.get_axes()[i]

    def _get_grid(self, grid, panel_count):
        if grid == &#34;auto&#34;:
            sx, sy = self._panels_shape(panel_count)
        elif grid == &#34;vertical&#34;:
            sx, sy = 1, panel_count
        elif grid == &#34;horizontal&#34;:
            sx, sy = panel_count, 1
        else:
            sx, sy = tuple(grid)
        return sx, sy

    def fig_show(self, add_sufix=True, suffix=&#34;&#34;):
        &#34;&#34;&#34; Plot figure. If output_filename is specified it will plot only into a file.

        Parameters
        ----------
        add_sufix : bool
            If true it will add sufix to output_filename in format prefix.sufix.count.extension
            where count is auto-incremented integer starting from 0 and
            prefix.extension is parsed from output_filename parameter.

        suffix : str
            Sufix used in filename.

        &#34;&#34;&#34;
        bottom, top, left, right, wspace, hspace = self.margins
        plt.subplots_adjust(bottom=bottom, top=top, wspace=wspace, hspace=hspace, left=left, right=right)
        if self.output_filename != &#34;&#34;:
            image_filename = self.output_filename
            if add_sufix:
                image_filename = self._image_filename(suffix)
            if image_filename is not None:
                try:
                    plt.savefig(image_filename, dpi=self.dpi)
                except:
                    _logger.warning(&#34;Figure is not saved due to an error!&#34;)
                plt.close(self.fig)
            else:
                _logger.warning(&#34;Figure is not saved!&#34;)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def _image_filename(self, suffix):
        parts = self.output_filename.split(&#34;.&#34;)
        if parts[-1] not in [&#34;png&#34;, &#34;pdf&#34;, &#34;jpg&#34;, &#34;eps&#34;, &#34;svg&#34;]:
            _logger.warning(&#34;File extension should be: .jpg, .png, .svg, .eps or .pdf&#34;)
            return None
        if suffix == &#34;&#34;:
            suffix = str(self.count).zfill(4)
        else:
            suffix += &#34;.&#34; + str(self.count).zfill(4)
        self.count += 1
        parts[-1] = suffix + &#34;.&#34; + parts[-1]
        return &#34;.&#34;.join(parts)

    @staticmethod
    def _panels_shape(n):
        sx, sy = 1, 1
        if n == 2:
            sy = 2
        elif n in [3, 4]:
            sx, sy = 2, 2
        elif n in [5, 6]:
            sx, sy = 2, 3
        elif n in [7, 8, 9]:
            sx, sy = 3, 3
        elif n in [10, 11, 12]:
            sx, sy = 3, 4
        elif n in [13, 14, 15, 16]:
            sx, sy = 4, 4
        elif n in [17, 18, 19, 20]:
            sx, sy = 4, 5
        elif n in [21, 22, 23, 24]:
            sx, sy = 4, 6
        else:
            while sx * sy &lt; n:
                sy += 1
                sx = int(2. * sy / 3 + 1.)
        return sx, sy</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cnvpytor.viewparams.ViewParams" href="viewparams.html#cnvpytor.viewparams.ViewParams">ViewParams</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cnvpytor.viewer.Viewer" href="#cnvpytor.viewer.Viewer">Viewer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cnvpytor.viewer.Figure.fig_show"><code class="name flex">
<span>def <span class="ident">fig_show</span></span>(<span>self, add_sufix=True, suffix='')</span>
</code></dt>
<dd>
<section class="desc"><p>Plot figure. If output_filename is specified it will plot only into a file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>add_sufix</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true it will add sufix to output_filename in format prefix.sufix.count.extension
where count is auto-incremented integer starting from 0 and
prefix.extension is parsed from output_filename parameter.</dd>
<dt><strong><code>suffix</code></strong> :&ensp;<code>str</code></dt>
<dd>Sufix used in filename.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fig_show(self, add_sufix=True, suffix=&#34;&#34;):
    &#34;&#34;&#34; Plot figure. If output_filename is specified it will plot only into a file.

    Parameters
    ----------
    add_sufix : bool
        If true it will add sufix to output_filename in format prefix.sufix.count.extension
        where count is auto-incremented integer starting from 0 and
        prefix.extension is parsed from output_filename parameter.

    suffix : str
        Sufix used in filename.

    &#34;&#34;&#34;
    bottom, top, left, right, wspace, hspace = self.margins
    plt.subplots_adjust(bottom=bottom, top=top, wspace=wspace, hspace=hspace, left=left, right=right)
    if self.output_filename != &#34;&#34;:
        image_filename = self.output_filename
        if add_sufix:
            image_filename = self._image_filename(suffix)
        if image_filename is not None:
            try:
                plt.savefig(image_filename, dpi=self.dpi)
            except:
                _logger.warning(&#34;Figure is not saved due to an error!&#34;)
            plt.close(self.fig)
        else:
            _logger.warning(&#34;Figure is not saved!&#34;)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Figure.get_panel"><code class="name flex">
<span>def <span class="ident">get_panel</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns axes of a i-th panel</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>Panel number</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Axes for a given panel</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_panel(self, i):
    &#34;&#34;&#34; Returns axes of a i-th panel

    Parameters
    ----------
    i : int
        Panel number

    Returns
    -------
    ax : matplotlib.axes.Axes
        Axes for a given panel

    &#34;&#34;&#34;
    return self.fig.get_axes()[i]</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Figure.new_figure"><code class="name flex">
<span>def <span class="ident">new_figure</span></span>(<span>self, panel_count, grid='auto', panel_size=None, title=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Clear figure and create new plot layout.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>panel_count</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of panels</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>str</code> or (<code>int</code>, <code>int</code>)</dt>
<dd>number of columns and rows (sx, sy) or "auto"</dd>
<dt><strong><code>panel_size</code></strong> :&ensp;(<code>float</code>, <code>float</code>)</dt>
<dd>size of a single panel (only when plots in file)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def new_figure(self, panel_count, grid=&#34;auto&#34;, panel_size=None, title=None):
    &#34;&#34;&#34; Clear figure and create new plot layout.

    Parameters
    ----------
    panel_count : int
        Number of panels
    grid : str or (int, int)
        number of columns and rows (sx, sy) or &#34;auto&#34;
    panel_size : (float, float)
        size of a single panel (only when plots in file)

    &#34;&#34;&#34;
    if panel_size is None:
        panel_size = self.panel_size
    if grid == &#34;auto&#34;:
        grid = self.grid
    plt.clf()
    plt.rcParams[&#34;font.size&#34;] = 8
    self.fig = plt.figure(1, dpi=self.dpi, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    if title is not None:
        self.fig.suptitle(title, fontsize=16)
    sx, sy = self._get_grid(grid, panel_count)
    if self.output_filename != &#34;&#34;:
        self.fig.set_figheight(panel_size[1] * sy)
        self.fig.set_figwidth(panel_size[0] * sx)
    self.fig_grid = gridspec.GridSpec(sy, sx, hspace=self.margins[5], wspace=self.margins[4])
    self.current = -1
    self.sg_current = -1</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Figure.new_subgrid"><code class="name flex">
<span>def <span class="ident">new_subgrid</span></span>(<span>self, panel_count, grid='auto', hspace=0, wspace=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def new_subgrid(self, panel_count, grid=&#34;auto&#34;, hspace=0, wspace=0):
    if grid == &#34;auto&#34;:
        grid = self.subgrid
    sx, sy = self._get_grid(grid, panel_count)
    self.current += 1
    self.fig_sub_grid = gridspec.GridSpecFromSubplotSpec(sy, sx, subplot_spec=self.fig_grid[self.current],
                                                         wspace=wspace, hspace=hspace)
    self.sg_current = -1
    self.sg_current_ax = None</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Figure.next_panel"><code class="name flex">
<span>def <span class="ident">next_panel</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return axes of next panel</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Axes for a given panel</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def next_panel(self):
    &#34;&#34;&#34; Return axes of next panel

    Returns
    -------
    ax : matplotlib.axes.Axes
        Axes for a given panel
    &#34;&#34;&#34;
    self.current += 1
    return self.fig.add_subplot(self.fig_grid[self.current])</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Figure.next_polar_panel"><code class="name flex">
<span>def <span class="ident">next_polar_panel</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return axes of next panel</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Axes for a given panel</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def next_polar_panel(self):
    &#34;&#34;&#34; Return axes of next panel

    Returns
    -------
    ax : matplotlib.axes.Axes
        Axes for a given panel
    &#34;&#34;&#34;
    self.current += 1
    return self.fig.add_subplot(self.fig_grid[self.current], projection=&#34;polar&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Figure.next_subpanel"><code class="name flex">
<span>def <span class="ident">next_subpanel</span></span>(<span>self, sharex=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Return axes of next sub panel</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Axes for a given panel</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def next_subpanel(self, sharex=False):
    &#34;&#34;&#34; Return axes of next sub panel

    Returns
    -------
    ax : matplotlib.axes.Axes
        Axes for a given panel
    &#34;&#34;&#34;
    self.sg_current += 1
    if self.sg_current == 0 or not sharex:
        self.sg_current_ax = self.fig.add_subplot(self.fig_sub_grid[self.sg_current])
    else:
        self.sg_current_ax = self.fig.add_subplot(self.fig_sub_grid[self.sg_current], sharex=self.sg_current_ax)
    return self.sg_current_ax</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cnvpytor.viewparams.ViewParams" href="viewparams.html#cnvpytor.viewparams.ViewParams">ViewParams</a></b></code>:
<ul class="hlist">
<li><code><a title="cnvpytor.viewparams.ViewParams.bin_size_f" href="viewparams.html#cnvpytor.viewparams.ViewParams.bin_size_f">bin_size_f</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="cnvpytor.viewer.Reader"><code class="flex name class">
<span>class <span class="ident">Reader</span></span>
<span>(</span><span>files)</span>
</code></dt>
<dd>
<section class="desc"><p>Class constructor opens cnvpytor files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of cnvpytor filenames.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Reader:
    def __init__(self, files):
        &#34;&#34;&#34; Class constructor opens cnvpytor files.

        Parameters
        ----------
        files : list of str
            List of cnvpytor filenames.

        &#34;&#34;&#34;
        self.io = [IO(f, ro=True) for f in files]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cnvpytor.viewer.Show" href="#cnvpytor.viewer.Show">Show</a></li>
</ul>
</dd>
<dt id="cnvpytor.viewer.Show"><code class="flex name class">
<span>class <span class="ident">Show</span></span>
<span>(</span><span>files)</span>
</code></dt>
<dd>
<section class="desc"><p>Class constructor opens cnvpytor files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of cnvpytor filenames.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Show(Reader):
    def ls(self):
        &#34;&#34;&#34; Prints to stdout content of all cnvpytor files.

        &#34;&#34;&#34;
        for i in self.io:
            i.ls()

    def meta(self):
        &#34;&#34;&#34; Prints to stdout meta tags of all cnvpytor files.

        &#34;&#34;&#34;
        for i in self.io:
            i.read_meta_attribute()

    def info(self, bin_sizes):
        &#34;&#34;&#34; Prints to stdout RD info for all cnvpytor files.
        Columns are following:
            filename
            mean read length, stdev of read length in %
            mean template length, stdev of template length in %
            for each bin_size (including 100 always):
                rd level and corresponding stdev for each chromosome type (autosomes, sex chromosomes and mitochondria)

        &#34;&#34;&#34;
        if 100 not in bin_sizes:
            bin_sizes = [100] + bin_sizes
        labels = [&#34;FILE&#34;, &#34;RL&#34;, &#34;dRL[%]&#34;, &#34;FL&#34;, &#34;dFL[%]&#34;]
        for bs in bin_sizes:
            labels.append(&#34;RD_AUTO_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_AUTO_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_GC_AUTO_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_GC_AUTO_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_XY_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_XY_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_GC_XY_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_GC_XY_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            if bs &lt;= 500:
                labels.append(&#34;RD_MT_&#34; + binsize_format(bs))
                labels.append(&#34;dRD_MT_&#34; + binsize_format(bs) + &#34;[%]&#34;)
                labels.append(&#34;RD_GC_MT_&#34; + binsize_format(bs))
                labels.append(&#34;dRD_CG_MT_&#34; + binsize_format(bs) + &#34;[%]&#34;)
        print((&#34;{:}\t{:}\t{:}\t{:}\t{:}\t&#34; + &#34;{:}\t&#34; * (len(labels) - 5)).format(*tuple(labels)))
        for i in self.io:
            rfd = i.get_signal(None, None, &#34;read frg dist&#34;)
            rd = np.sum(rfd, axis=1)
            fd = np.sum(rfd, axis=0)
            mrl = np.sum(rd * np.arange(rd.size)) / np.sum(rd)
            mfl = np.sum(fd * np.arange(fd.size)) / np.sum(fd)
            mrl2 = np.sum(rd * np.arange(rd.size) * np.arange(rd.size)) / np.sum(rd)
            mfl2 = np.sum(fd * np.arange(fd.size) * np.arange(fd.size)) / np.sum(fd)
            sdr = 100. * np.sqrt(mrl2 - mrl * mrl) / mrl
            sdf = 100. * np.sqrt(mfl2 - mfl * mfl) / mfl
            print(&#34;{:}\t{:.2f}\t{:.2f}\t{:.2f}\t{:.2f}\t&#34;.format(i.filename, mrl, sdr, mfl, sdf), end=&#34;&#34;)
            for bs in bin_sizes:
                for flag in [FLAG_AUTO, FLAG_SEX, FLAG_MT]:
                    if bs &lt;= 500 or not flag == FLAG_MT:
                        if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=flag):
                            stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=flag)
                            if stat[4] &gt; 0:
                                stat[5] /= stat[4] / 100.
                            print(&#34;{:.2f}\t{:.2f}\t&#34;.format(stat[4], stat[5]), end=&#34;&#34;)
                        else:
                            print(&#34;{:}\t{:}\t&#34;.format(&#34;-&#34;, &#34;-&#34;), end=&#34;&#34;)
                        if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=(flag | FLAG_GC_CORR)):
                            stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=(flag | FLAG_GC_CORR))
                            if stat[4] &gt; 0:
                                stat[5] /= stat[4] / 100.
                            print(&#34;{:.2f}\t{:.2f}\t&#34;.format(stat[4], stat[5]), end=&#34;&#34;)
                        else:
                            print(&#34;{:}\t{:}\t&#34;.format(&#34;-&#34;, &#34;-&#34;), end=&#34;&#34;)
            print()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cnvpytor.viewer.Reader" href="#cnvpytor.viewer.Reader">Reader</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cnvpytor.viewer.Viewer" href="#cnvpytor.viewer.Viewer">Viewer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cnvpytor.viewer.Show.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, bin_sizes)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints to stdout RD info for all cnvpytor files.
Columns are following:
filename
mean read length, stdev of read length in %
mean template length, stdev of template length in %
for each bin_size (including 100 always):
rd level and corresponding stdev for each chromosome type (autosomes, sex chromosomes and mitochondria)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def info(self, bin_sizes):
    &#34;&#34;&#34; Prints to stdout RD info for all cnvpytor files.
    Columns are following:
        filename
        mean read length, stdev of read length in %
        mean template length, stdev of template length in %
        for each bin_size (including 100 always):
            rd level and corresponding stdev for each chromosome type (autosomes, sex chromosomes and mitochondria)

    &#34;&#34;&#34;
    if 100 not in bin_sizes:
        bin_sizes = [100] + bin_sizes
    labels = [&#34;FILE&#34;, &#34;RL&#34;, &#34;dRL[%]&#34;, &#34;FL&#34;, &#34;dFL[%]&#34;]
    for bs in bin_sizes:
        labels.append(&#34;RD_AUTO_&#34; + binsize_format(bs))
        labels.append(&#34;dRD_AUTO_&#34; + binsize_format(bs) + &#34;[%]&#34;)
        labels.append(&#34;RD_GC_AUTO_&#34; + binsize_format(bs))
        labels.append(&#34;dRD_GC_AUTO_&#34; + binsize_format(bs) + &#34;[%]&#34;)
        labels.append(&#34;RD_XY_&#34; + binsize_format(bs))
        labels.append(&#34;dRD_XY_&#34; + binsize_format(bs) + &#34;[%]&#34;)
        labels.append(&#34;RD_GC_XY_&#34; + binsize_format(bs))
        labels.append(&#34;dRD_GC_XY_&#34; + binsize_format(bs) + &#34;[%]&#34;)
        if bs &lt;= 500:
            labels.append(&#34;RD_MT_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_MT_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_GC_MT_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_CG_MT_&#34; + binsize_format(bs) + &#34;[%]&#34;)
    print((&#34;{:}\t{:}\t{:}\t{:}\t{:}\t&#34; + &#34;{:}\t&#34; * (len(labels) - 5)).format(*tuple(labels)))
    for i in self.io:
        rfd = i.get_signal(None, None, &#34;read frg dist&#34;)
        rd = np.sum(rfd, axis=1)
        fd = np.sum(rfd, axis=0)
        mrl = np.sum(rd * np.arange(rd.size)) / np.sum(rd)
        mfl = np.sum(fd * np.arange(fd.size)) / np.sum(fd)
        mrl2 = np.sum(rd * np.arange(rd.size) * np.arange(rd.size)) / np.sum(rd)
        mfl2 = np.sum(fd * np.arange(fd.size) * np.arange(fd.size)) / np.sum(fd)
        sdr = 100. * np.sqrt(mrl2 - mrl * mrl) / mrl
        sdf = 100. * np.sqrt(mfl2 - mfl * mfl) / mfl
        print(&#34;{:}\t{:.2f}\t{:.2f}\t{:.2f}\t{:.2f}\t&#34;.format(i.filename, mrl, sdr, mfl, sdf), end=&#34;&#34;)
        for bs in bin_sizes:
            for flag in [FLAG_AUTO, FLAG_SEX, FLAG_MT]:
                if bs &lt;= 500 or not flag == FLAG_MT:
                    if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=flag):
                        stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=flag)
                        if stat[4] &gt; 0:
                            stat[5] /= stat[4] / 100.
                        print(&#34;{:.2f}\t{:.2f}\t&#34;.format(stat[4], stat[5]), end=&#34;&#34;)
                    else:
                        print(&#34;{:}\t{:}\t&#34;.format(&#34;-&#34;, &#34;-&#34;), end=&#34;&#34;)
                    if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=(flag | FLAG_GC_CORR)):
                        stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=(flag | FLAG_GC_CORR))
                        if stat[4] &gt; 0:
                            stat[5] /= stat[4] / 100.
                        print(&#34;{:.2f}\t{:.2f}\t&#34;.format(stat[4], stat[5]), end=&#34;&#34;)
                    else:
                        print(&#34;{:}\t{:}\t&#34;.format(&#34;-&#34;, &#34;-&#34;), end=&#34;&#34;)
        print()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Show.ls"><code class="name flex">
<span>def <span class="ident">ls</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints to stdout content of all cnvpytor files.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ls(self):
    &#34;&#34;&#34; Prints to stdout content of all cnvpytor files.

    &#34;&#34;&#34;
    for i in self.io:
        i.ls()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Show.meta"><code class="name flex">
<span>def <span class="ident">meta</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints to stdout meta tags of all cnvpytor files.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def meta(self):
    &#34;&#34;&#34; Prints to stdout meta tags of all cnvpytor files.

    &#34;&#34;&#34;
    for i in self.io:
        i.read_meta_attribute()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cnvpytor.viewer.Viewer"><code class="flex name class">
<span>class <span class="ident">Viewer</span></span>
<span>(</span><span>files, params={}, force_agg=False, history_file_size=1000)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of cnvpytor filenames</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>List of parameters different than default to be passed to ViewParams class.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Viewer(Show, Figure, HelpDescription):

    def __init__(self, files, params={}, force_agg=False, history_file_size=1000):
        &#34;&#34;&#34;

        Parameters
        ----------
        files : list of str
            List of cnvpytor filenames
        params : dict
            List of parameters different than default to be passed to ViewParams class.

        &#34;&#34;&#34;
        _logger.debug(&#34;Viewer class init: files [%s], params %s.&#34; % (&#34;, &#34;.join(files), str(params)))
        Figure.__init__(self, params, force_agg=force_agg)
        Show.__init__(self, files)
        self.history_file_size = history_file_size
        self.cnvpytor_dir = os.path.expanduser(&#39;~/.cnvpytor&#39;)
        self.save_history = False
        if os.path.exists(self.cnvpytor_dir):
            if os.access(self.cnvpytor_dir, os.W_OK):
                self.save_history = True
            if os.path.exists(self.cnvpytor_dir+&#34;/viewer.conf&#34;):
                conf = eval(open(self.cnvpytor_dir+&#34;/viewer.conf&#34;).read())
                for key in conf:
                    setattr(self,key,conf[key])

        self.io_gc = self.io[0]
        self.io_mask = self.io[0]
        self.reference_genome = None
        self.plot_files = list(range(len(files)))
        self.default[&#34;plot_files&#34;] = list(range(len(files)))
        if self.io[0].signal_exists(None, None, &#34;reference genome&#34;):
            rg_name = np.array(self.io[0].get_signal(None, None, &#34;reference genome&#34;)).astype(&#34;str&#34;)[0]
            self.reference_genome = Genome.reference_genomes[rg_name]
            if &#34;mask_file&#34; in Genome.reference_genomes[rg_name]:
                self.io_mask = IO(Genome.reference_genomes[rg_name][&#34;mask_file&#34;], ro=True, buffer=True)
            if &#34;gc_file&#34; in Genome.reference_genomes[rg_name]:
                self.io_gc = IO(Genome.reference_genomes[rg_name][&#34;gc_file&#34;], ro=True, buffer=True)

    def parse(self, command):
        current = &#34;regions&#34;
        regions = []

        for p in command:
            if p.isdigit() and (int(p) % 100) == 0:
                self.bin_size = int(p)
                if current == &#34;rd&#34;:
                    self.rd()
                if current == &#34;baf&#34;:
                    self.baf()
                if current == &#34;likelihood&#34;:
                    self.likelihood()
                elif current == &#34;manhattan&#34;:
                    self.global_plot()
                elif current == &#34;calls&#34;:
                    if len(self.callers) &gt; 0:
                        self.manhattan(plot_type=self.callers[0])
                elif current == &#34;stat&#34;:
                    self.stat(int(p))
                elif current == &#34;circular&#34;:
                    self.circular()
                elif current == &#34;regions&#34;:
                    self.multiple_regions(regions)
                    regions = []
            elif p == &#34;rdstat&#34;:
                self.stat()
            elif p == &#34;snp&#34;:
                self.snp()
            elif p in [&#34;rd&#34;, &#34;baf&#34;, &#34;manhattan&#34;, &#34;calls&#34;, &#34;stat&#34;, &#34;regions&#34;, &#34;likelihood&#34;, &#34;circular&#34;]:
                current = p
            elif current == &#34;regions&#34;:
                regions.append(p)
            else:
                current = p

    def plot_command(self, command):
        self.interactive = False
        self.parse(command)

    def prompt(self):
        self.interactive = True

        chromosomes = set({})
        for f in self.io:
            chromosomes = chromosomes.union(set(f.rd_chromosomes()))
            chromosomes = chromosomes.union(set(f.snp_chromosomes()))
        for c in chromosomes:
            self.command_tree[c] = None
        self.command_tree[&#34;set&#34;][&#34;style&#34;] = dict(zip(plt.style.available, [None] * len(plt.style.available)))
        if os.path.exists(self.cnvpytor_dir+&#34;/history&#34;):
            readline.read_history_file(self.cnvpytor_dir+&#34;/history&#34;)

        readline.parse_and_bind(&#34;tab: complete&#34;)
        completer = PromptCompleter(self.command_tree)
        readline.set_completer(completer.complete)
        quit = False
        try:
            while not quit:
                prompt_str = &#34;&#34;
                if os.isatty(sys.stdin.fileno()):
                    prompt_str = &#34;cnvpytor&gt; &#34;
                else:
                    self.interactive = False
                try:
                    line = raw_input(prompt_str)
                except NameError:
                    line = input(prompt_str)

                if line[0] == &#34;#&#34; or line[0] == &#34;&#34;:
                    continue

                if self.save_history and self.interactive:
                    readline.set_history_length(self.history_file_size)
                    readline.write_history_file(self.cnvpytor_dir+&#34;/history&#34;)

                pre = line.split(&#34;&gt;&#34;)
                f = pre[0].strip().split(&#34; &#34;)
                n = len(f)
                if len(line) == 0:
                    continue
                elif f[0] == &#34;quit&#34; or f[0] == &#34;exit&#34;:
                    quit = True
                elif line[0] == &#34;|&#34;:
                    try:
                        eval(compile(line[1:], &#39;&lt;string&gt;&#39;, &#39;single&#39;))
                    except Exception as e:
                        print(traceback.format_exc())
                elif f[0] == &#34;save&#34;:
                    if n &gt; 1:
                        try:
                            plt.savefig(f[1])
                        except ValueError:
                            _logger.warning(&#34;File extension should be: .jpg, .png, .svg, .eps or .pdf&#34;)
                        except:
                            _logger.warning(&#34;Figure is not saved due to an error!&#34;)

                elif f[0] in [&#34;draw&#34;, &#34;repaint&#34;, &#34;update&#34;]:
                    if n == 1:
                        self.fig.canvas.draw()
                elif f[0] == &#34;ls&#34;:
                    self.ls()
                elif f[0] == &#34;meta&#34;:
                    self.meta()
                elif f[0] == &#34;show&#34;:
                    if n == 1:
                        self.show()
                elif f[0] == &#34;set&#34;:
                    if n &gt; 1:
                        self.set(f[1], f[2:])
                elif f[0] == &#34;help&#34; and n &gt; 1:
                    self.help(f[1])
                elif f[0] == &#34;help&#34; and n == 1:
                    self.help(&#34;help&#34;)
                elif f[0] == &#34;unset&#34;:
                    if n &gt; 1:
                        self.unset(f[1])
                elif f[0] == &#34;genotype&#34;:
                    if n &gt; 1:
                        self.genotype_all([self.bin_size], f[1:], interactive=True)
                elif f[0] == &#34;snv&#34;:
                    if n == 2:
                        self.snp(callset=f[1])
                    elif n == 1:
                        self.snp(callset=&#34;default&#34;)
                elif f[0] == &#34;compare&#34;:
                    if n == 3:
                        self.compare(f[1], f[2], plot=self.plot)
                    elif n == 4:
                        self.compare(f[1], f[2], n_bins=int(f[3]), plot=self.plot)
                elif f[0] == &#34;info&#34;:
                    if n &gt; 1:
                        self.info(list(map(binsize_type, f[1:])))
                elif f[0] == &#34;print&#34;:
                    if f[1] == &#34;calls&#34;:
                        if self.print_filename == &#34;&#34;:
                            self.print_calls()
                        else:
                            self.print_calls_file()
                    elif f[1] == &#34;joint_calls&#34;:
                        self.print_simple_joint_calls()

                else:
                    try:
                        if f[0] not in [&#34;rdstat&#34;, &#34;snp&#34;]:
                            self.parse(f + [str(self.bin_size)])
                        else:
                            self.parse(f)
                        if len(pre) &gt; 1:
                            fns = pre[1].strip().split(&#34; &#34;)
                            if fns[0] != &#34;&#34;:
                                plt.savefig(fns[0], dpi=200)
                    except Exception as e:
                        print(traceback.format_exc())
        except (EOFError, KeyboardInterrupt):
            print()
            return

    def help(self, param):
        if param in self.param_help:
            print(self.param_help[param])
        else:
            print(&#34;\nUnknown parameter !\n&#34;)

    @staticmethod
    def set_style(style):
        if style in plt.style.available:
            plt.style.use(&#34;default&#34;)
            plt.style.use(style)

    def file_title(self, ix):
        if ix &lt; len(self.file_titles):
            return self.file_titles[ix]
        else:
            return self.io[ix].filename.split(&#34;/&#34;)[-1].replace(&#34;.pytor&#34;, &#34;&#34;)

    def show(self):
        print(&#34;\nParameters&#34;)
        for key in sorted(self.params.keys()):
            print(&#34;    * %s: %s&#34; % (key, str(self.params[key])))
            if key == &#34;plot_files&#34;:
                for i in range(len(self.io)):
                    print(&#34;            %d: %s&#34; % (i, self.io[i].filename))
        print()

    def stat(self, his_bin_size=100, return_image=False):
        plt.clf()
        auto = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_AUTO)
        sex = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_SEX)
        mt = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_MT) and (his_bin_size &lt; 1001)
        if not (auto or sex or mt):
            return
        cond = [auto, sex, mt]
        stat_list = []
        n_cols = sum(map(int, cond))
        ix = 1
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, figsize=(4 * n_cols, 8), dpi=90, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        for t, c, flag in zip([&#34;Autosomes&#34;, &#34;X/Y&#34;, &#34;Mitochondria&#34;], cond, [FLAG_AUTO, FLAG_SEX, FLAG_MT]):
            if c:
                stat = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD stat&#34;, flag)
                stat_list.append(stat)
                max_rd = int(stat[0])
                bin_size = int(stat[1])
                n_bins = int(stat[2])
                lim_rd = int(max(2 * stat[4], stat[4] + 3 * stat[5]))
                _logger.info(&#34;RD stat for %s: %.2f +- %.2f&#34; % (t, stat[4], stat[5]))
                if t == &#34;Mitochondria&#34; and auto:
                    _logger.info(&#34;RD stat for %s - number of mitochondria per cell: %.2f +- %.2f&#34; % (
                        t, 2 * stat[4] / stat_list[0][4],
                        2 * stat[5] / stat_list[0][4] + stat_list[0][5] * stat[4] / (
                                stat_list[0][4] * stat_list[0][4])))
                his_p = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD p dist&#34;, flag)
                his_u = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD u dist&#34;, flag)
                his_rd_gc = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD GC dist&#34;, flag)
                gc_corr = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;GC corr&#34;, flag)
                ax = plt.subplot(2, n_cols, ix)
                ax.set_xlabel(&#34;RD&#34;)
                ax.set_ylabel(&#34;GC [%]&#34;)
                ax.xaxis.set_ticklabels([])
                ax.set_title(t)
                his_rd_gc[0][0] = 0
                ax.imshow(his_rd_gc[:lim_rd // bin_size, :].T, aspect=&#34;auto&#34;, interpolation=&#39;nearest&#39;, origin=&#39;lower&#39;)
                ax.plot(gc_corr * stat[4] / bin_size, range(101), &#34;w-&#34;)

                ax = plt.subplot(2, n_cols, ix + n_cols)
                ax.set_ylabel(&#34;Normalised distribution&#34;)
                ax.set_xlabel(&#34;RD&#34;)
                ax.set_xlim([0, lim_rd])
                # ax.set_ylim([0, 1.1])
                bins = range(0, max_rd, bin_size)
                x = np.arange(0, max_rd // bin_size * bin_size, 0.1 * bin_size)
                plt.plot(x, normal(x, 1, stat[4], stat[5]), &#34;g-&#34;)
                x = np.array(bins)
                plt.plot(x[:len(his_u)], his_u / stat[3], &#34;y*&#34;)
                plt.plot(x[:len(his_p)], his_p / stat[3], &#34;b*&#34;)
                ix += 1
        plt.subplots_adjust(bottom=0.08, top=0.95, wspace=0.25, hspace=0, left=0.05 * 3 / n_cols, right=0.95)
        if return_image:
            self.fig.canvas.draw()
            import PIL
            pil_image = PIL.Image.frombytes(&#39;RGB&#39;, self.fig.canvas.get_width_height(),
                                            self.fig.canvas.tostring_rgb())
            return pil_image
        elif self.output_filename != &#34;&#34;:
            plt.savefig(self._image_filename(&#34;stat&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def rd(self):
        bin_size = self.bin_size
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            rd_chr = self.io[self.plot_file].rd_chromosome_name(c)
            if self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                    self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                    (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append((rd_chr, l))
        self.new_figure(panel_count=len(chroms))
        for c, l in chroms:
            flag_rd = FLAG_USEMASK if self.rd_use_mask else 0
            mean, stdev = self.io[self.plot_file].rd_normal_level(bin_size, flag_rd | FLAG_GC_CORR)
            his_p = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
            his_p_corr = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            his_p_seg = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD partition&#34;, flag_rd | FLAG_GC_CORR)
            his_p_call = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
            his_p_mosaic_seg = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                                  flag_rd | FLAG_GC_CORR)
            his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
            his_p_mosaic_call = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                                   flag_rd | FLAG_GC_CORR)
            his_p_mosaic_seg_2d = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic segments 2d&#34;,
                                                                     flag_rd | FLAG_GC_CORR)
            his_p_mosaic_seg_2d = segments_decode(his_p_mosaic_seg_2d)
            his_p_mosaic_call_2d = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic call 2d&#34;,
                                                                      flag_rd | FLAG_GC_CORR)
            his_p_mosaic = np.zeros_like(his_p) * np.nan
            if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call and (
                    &#34;rd_mosaic&#34; in self.callers):
                for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                    for segi in seg:
                        his_p_mosaic[segi] = lev
            his_p_mosaic_2d = np.zeros_like(his_p) * np.nan
            if his_p_mosaic_call_2d is not None and len(his_p_mosaic_call_2d) &gt; 0 and self.rd_call and (
                    &#34;combined_mosaic&#34; in self.callers):
                for seg, lev in zip(list(his_p_mosaic_seg_2d), list(his_p_mosaic_call_2d[0])):
                    for segi in seg:
                        his_p_mosaic_2d[segi] = lev
            ax = self.next_panel()
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // bin_size, 10e6 // bin_size), minor=[])
            if (self.rd_range[1] - self.rd_range[0]) &lt; 30:
                ax.yaxis.set_ticks(np.arange(int(self.rd_range[0]), int(self.rd_range[1] + 1), 1) * mean / 2,
                                   minor=[])
            ax.set_ylim([self.rd_range[0] * mean / 2, self.rd_range[1] * mean / 2])
            n_bins = l // bin_size
            ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
            ax.grid()
            if self.rd_raw:
                plt.step(his_p, self.rd_colors[0])
            if self.rd_corrected:
                plt.step(his_p_corr, self.rd_colors[1])
            if his_p_seg is not None and len(his_p_seg) &gt; 0 and self.rd_partition:
                plt.step(his_p_seg, self.rd_colors[2])
            if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call:
                plt.step(his_p_call, self.rd_colors[3])
            if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call and (
                    &#34;rd_mosaic&#34; in self.callers):
                plt.step(his_p_mosaic, self.rd_colors[4])
            if his_p_mosaic_call_2d is not None and len(his_p_mosaic_call_2d) &gt; 0 and self.rd_call and (
                    &#34;combined_mosaic&#34; in self.callers):
                plt.step(his_p_mosaic_2d, self.rd_colors[5])
        self.fig_show(suffix=&#34;rd&#34;)

    def rd_diff(self, file1, file2):
        bin_size = self.bin_size
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            rd_chr = self.io[self.plot_file].rd_chromosome_name(c)
            if self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                    self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                    (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append((rd_chr, l))
        self.new_figure(panel_count=len(chroms))
        for c, l in chroms:
            flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
            stat1 = self.io[file1].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
            stat2 = self.io[file2].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
            if stat1 is None:
                _logger.error(
                    &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[file1].filename))
                return
            if stat2 is None:
                _logger.error(
                    &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[file2].filename))
                return
            flag_rd = (FLAG_USEMASK if self.rd_use_mask else 0)
            his_p_corr1 = self.io[file1].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            his_p_corr2 = self.io[file2].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            ax = self.next_panel()
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            if (self.rd_range[1] - self.rd_range[0]) &lt; 30:
                ax.yaxis.set_ticks(np.arange(int(self.rd_range[0]), int(self.rd_range[1] + 1), 1) * mean / 2,
                                   minor=[])
            ax.yaxis.set_ticks(np.arange(0, 2, 0.25), minor=[])
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // bin_size, 10e6 // bin_size), minor=[])
            ax.set_ylim([0, 1])
            n_bins = l // bin_size
            ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
            ax.grid()

            plt.step(np.abs(his_p_corr1 / stat1[4] - his_p_corr2 / stat2[4]), &#34;k&#34;)
        self.fig_show(suffix=&#34;rd_diff&#34;)

    def likelihood(self):
        bin_size = self.bin_size
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0)
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        chroms = []
        if self.reference_genome is None:
            chroms = self.io[self.plot_file].snp_chromosomes()
        else:
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
                if self.io[self.plot_file].signal_exists(snp_chr, bin_size, &#34;SNP likelihood&#34;, snp_flag) and (
                        Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                    chroms.append(snp_chr)
        self.new_figure(panel_count=len(chroms))
        for c in chroms:
            likelihood = self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
            img = np.array(likelihood).transpose()
            ax = self.next_panel()
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.imshow(img, aspect=&#39;auto&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.xaxis.set_ticks(np.arange(0, likelihood.shape[0], 50), minor=[])
            ax.set_xlim([0, likelihood.shape[0]])
            if self.snp_call and (&#34;baf_mosaic&#34; in self.callers):
                likelihood = self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                segments = segments_decode(
                    self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
                call_pos = []
                call_i1 = []
                call_i2 = []
                call_c = []
                for s, lh in zip(segments, likelihood):
                    i1, i2, p = likelihood_pixels_pval(lh)
                    if i1 != i2 and len(s) &gt; self.min_segment_size:
                        alpha = -np.log(p + 1e-40) / self.contrast
                        if alpha &gt; 1:
                            alpha = 1
                        for pos in s:
                            call_pos.append(pos)
                            call_i1.append(min(i1, i2))
                            call_i2.append(max(i1, i2))
                            color = colors.to_rgb(self.lh_colors[0]) + (alpha,)
                            call_c.append(color)
                plt.scatter(call_pos, call_i1, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                            marker=self.lh_marker)
                plt.scatter(call_pos, call_i2, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                            marker=self.lh_marker)
            if self.snp_call and (&#34;combined_mosaic&#34; in self.callers):
                likelihood = self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood call 2d&#34;, snp_flag)
                segments = segments_decode(
                    self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood segments 2d&#34;, snp_flag))
                call_pos = []
                call_i1 = []
                call_i2 = []
                call_c = []
                for s, lh in zip(segments, likelihood):
                    i1, i2, p = likelihood_pixels_pval(lh)
                    if i1 != i2 and len(s) &gt; self.min_segment_size:
                        alpha = -np.log(p + 1e-40) / self.contrast
                        if alpha &gt; 1:
                            alpha = 1
                        for pos in s:
                            call_pos.append(pos)
                            call_i1.append(min(i1, i2))
                            call_i2.append(max(i1, i2))
                            color = colors.to_rgb(self.lh_colors[1]) + (alpha,)
                            call_c.append(color)
                plt.scatter(call_pos, call_i1, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                            marker=self.lh_marker)
                plt.scatter(call_pos, call_i2, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                            marker=self.lh_marker)
        self.fig_show(suffix=&#34;likelihood&#34;)

    def baf(self):
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0)
        chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
            if self.io[self.plot_file].signal_exists(snp_chr, self.bin_size, &#34;SNP baf&#34;, snp_flag) and \
                    self.io[self.plot_file].signal_exists(snp_chr, self.bin_size, &#34;SNP maf&#34;, snp_flag) and \
                    self.io[self.plot_file].signal_exists(snp_chr, self.bin_size, &#34;SNP i1&#34;, snp_flag) and \
                    self.io[self.plot_file].signal_exists(snp_chr, self.bin_size, &#34;SNP i2&#34;, snp_flag) and \
                    (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append((snp_chr, l))

        self.new_figure(panel_count=len(chroms))
        for c, l in chroms:
            baf = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP baf&#34;, snp_flag)
            maf = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP maf&#34;, snp_flag)
            i1 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP i1&#34;, snp_flag)
            i2 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP i2&#34;, snp_flag)

            ax = self.next_panel()
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // self.bin_size, 10e6 // self.bin_size), minor=[])
            ax.set_ylim([0, 1])
            n_bins = l // self.bin_size
            ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
            ax.grid()
            ax.step(baf, self.baf_colors[0])
            ax.step(maf, self.baf_colors[1])
            ax.step(i1, self.baf_colors[2])
        self.fig_show(suffix=&#34;baf&#34;)

    def snp(self, plot_gt=None, plot_pmask=None, callset=None):
        if plot_pmask is None:
            plot_pmask = [0, 1]
        if plot_gt is None:
            plot_gt = [0, 1, 2, 3]
        chroms = []
        if self.reference_genome is None:
            chroms = self.io[self.plot_file].snp_chromosomes()
        else:
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
                if callset is None:
                    if self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP pos&#34;, 0) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP desc&#34;, 0) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP counts&#34;, 0) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP qual&#34;, 0) and \
                            (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append(snp_chr)
                else:
                    if self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP pos&#34;, 0, name=callset) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP desc&#34;, 0,
                                                                  name=callset) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP counts&#34;, 0,
                                                                  name=callset) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP qual&#34;, 0,
                                                                  name=callset) and \
                            (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append(snp_chr)
        self.new_figure(panel_count=len(chroms))
        for c in chroms:
            pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_file].read_snp(c, callset=callset)
            hpos = []
            baf = []
            color = []
            qlpha = 0.7
            for i in range(len(pos)):
                if (nref[i] + nalt[i]) != 0:
                    if (gt[i] % 4 in plot_gt) and ((flag[i] &gt;&gt; 1) in plot_pmask):
                        hpos.append(pos[i])
                        if gt[i] % 4 != 2:
                            baf.append(1.0 * nalt[i] / (nref[i] + nalt[i]))
                        else:
                            baf.append(1.0 * nref[i] / (nref[i] + nalt[i]))
                        if self.snp_alpha_P:
                            alpha = None
                            color.append(colors.to_rgba(self.snp_colors[(gt[i] % 4) * 2 + 1], (flag[i] &gt;&gt; 1) * 0.4))
                        else:
                            color.append(self.snp_colors[(gt[i] % 4) * 2 + (flag[i] &gt;&gt; 1)])

            ax = self.next_panel()
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
            l = max(pos)
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6), 10e6), minor=[])
            ax.set_ylim([0., 1.])
            ax.set_xlim([-0.05 * l, 1.05 * l])
            ax.grid()
            if self.markersize == &#34;auto&#34;:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=0.7)
            else:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=0.7)
        self.fig_show(suffix=&#34;snp&#34;)

    def get_calls(self):
        bin_size = self.bin_size
        n = len(self.plot_files)
        ix = self.plot_files
        if self.annotate:
            annotator = Annotator(self.reference_genome)
        ret = []
        for caller in self.callers:
            if caller == &#34;rd_mean_shift&#34;:
                for i in range(n):
                    io = self.io[ix[i]]
                    chroms = io.rd_chromosomes()
                    for c in chroms:
                        if (c in self.chrom) or len(self.chrom) == 0:
                            flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                            if io.signal_exists(c, bin_size, &#34;calls&#34;, flag):
                                calls = io.read_calls(c, bin_size, &#34;calls&#34;, flag)
                                for call in calls:
                                    if in_interval(call[&#34;size&#34;], self.size_range) \
                                            and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                            and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                            and in_interval(call[&#34;Q0&#34;], self.Q0_range) \
                                            and in_interval(call[&#34;dG&#34;], self.dG_range):
                                        type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;

                                        row = [self.file_title(ix[i]), caller, type, c, call[&#34;start&#34;], call[&#34;end&#34;],
                                               call[&#34;size&#34;], call[&#34;cnv&#34;], call[&#34;p_val&#34;], call[&#34;p_val_2&#34;],
                                               call[&#34;p_val_3&#34;], call[&#34;p_val_4&#34;], call[&#34;Q0&#34;], call[&#34;pN&#34;], call[&#34;dG&#34;]]
                                        if self.annotate:
                                            row.append(annotator.get_info(&#34;%s:%d-%d&#34; % (c, call[&#34;start&#34;], call[&#34;end&#34;])))
                                        ret.append(row)
            elif caller == &#34;combined_mosaic&#34;:
                for i in range(n):
                    io = self.io[ix[i]]
                    chroms = io.rd_chromosomes()
                    for c in chroms:
                        if (c in self.chrom) or len(self.chrom) == 0:
                            flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR | \
                                   (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
                            if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                                calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)
                                for call in calls:
                                    if in_interval(call[&#34;size&#34;], self.size_range) \
                                            and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                            and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                            and in_interval(call[&#34;Q0&#34;], self.Q0_range):

                                        if n &gt; 1:
                                            print(&#34;%s\t&#34; % self.file_title(ix[i]), end=&#34;&#34;)
                                        if len(self.callers) &gt; 1:
                                            print(&#34;%s\t&#34; % caller, end=&#34;&#34;)
                                        keys = [&#34;start&#34;, &#34;end&#34;, &#34;size&#34;, &#34;cnv&#34;, &#34;p_val&#34;, &#34;lh_del&#34;, &#34;lh_loh&#34;,
                                                &#34;lh_dup&#34;, &#34;Q0&#34;, &#34;pN&#34;, &#34;pNS&#34;, &#34;pP&#34;, &#34;bins&#34;, &#34;baf&#34;,
                                                &#34;rd_p_val&#34;, &#34;baf_p_val&#34;, &#34;segment&#34;, &#34;hets&#34;, &#34;homs&#34;]
                                        type = {-1: &#34;deletion&#34;, 0: &#34;cnnloh&#34;, 1: &#34;duplication&#34;}[call[&#34;type&#34;]]
                                        row = [self.file_title(i), caller, type, c] + [call[k] for k in keys]
                                        for m in range(2):
                                            row += call[&#34;models&#34;][m]

                                        if self.annotate:
                                            row.append(annotator.get_info(&#34;%s:%d-%d&#34; % (data[3], data[4], data[5])))
                                        ret.append(row)
        return ret

    def print_calls_file(self):
        format = self.print_filename.split(&#34;.&#34;)[-1]
        calls = self.get_calls()
        if self.print_filename == &#34;&#34;:
            for call in calls:
                print(*call, sep=&#34;\t&#34;)
        elif format == &#34;tsv&#34;:
            with open(self.print_filename, &#39;w&#39;) as f:
                for call in calls:
                    print(*call, sep=&#34;\t&#34;, file=f)
        elif format == &#34;xlsx&#34;:
            import xlsxwriter
            workbook = xlsxwriter.Workbook(self.print_filename)
            files_callers = []
            sheets = {}
            rix = {}
            for call in calls:
                caller = call[1]
                fc = call[0] + &#34; (&#34; + caller + &#34;)&#34;
                sfc = call[0][:25] + &#34; &#34; + ({&#34;rd_mean_shift&#34;: &#34;ms&#34;, &#34;combined_mosaic&#34;: &#34;2d&#34;}[caller])
                if fc not in files_callers:
                    sheets[fc] = workbook.add_worksheet(sfc)
                    rix[fc] = 0
                    files_callers.append(fc)
            for call in calls:
                caller = call[1]
                fc = call[0] + &#34; (&#34; + caller + &#34;)&#34;
                cix = 0
                for f in call[2:]:
                    sheets[fc].write(rix[fc], cix, f)
                    cix += 1
                rix[fc] += 1
            workbook.close()
        elif format == &#34;vcf&#34;:
            samples = []
            for call in calls:
                sample = call[0]
                if sample not in samples:
                    samples.append(sample)
            header = &#34;&#34;&#34;##fileformat=VCFv4.1
##fileDate={date}
##reference={rg}
##source=CNVpytor
##INFO=&lt;ID=END,Number=1,Type=Integer,Description=&#34;End position of the variant described in this record&#34;&gt;
##INFO=&lt;ID=IMPRECISE,Number=0,Type=Flag,Description=&#34;Imprecise structural variation&#34;&gt;
##INFO=&lt;ID=SVLEN,Number=1,Type=Integer,Description=&#34;Difference in length between REF and ALT alleles&#34;&gt;
##INFO=&lt;ID=SVTYPE,Number=1,Type=String,Description=&#34;Type of structural variant&#34;&gt;
##INFO=&lt;ID=pytorRD,Number=1,Type=Float,Description=&#34;Normalized RD&#34;&gt;
##INFO=&lt;ID=pytorP1,Number=1,Type=Float,Description=&#34;e-val by t-test&#34;&gt;
##INFO=&lt;ID=pytorP2,Number=1,Type=Float,Description=&#34;e-val by Gaussian tail&#34;&gt;
##INFO=&lt;ID=pytorP3,Number=1,Type=Float,Description=&#34;e-val by t-test (middle)&#34;&gt;
##INFO=&lt;ID=pytorP4,Number=1,Type=Float,Description=&#34;e-val by Gaussian tail (middle)&#34;&gt;
##INFO=&lt;ID=pytorQ0,Number=1,Type=Float,Description=&#34;Fraction of reads with 0 mapping quality&#34;&gt;
##INFO=&lt;ID=pytorPN,Number=1,Type=Integer,Description=&#34;Fraction of N bases&#34;&gt;
##INFO=&lt;ID=pytorDG,Number=1,Type=Integer,Description=&#34;Distance to nearest gap in reference genome&#34;&gt;
##INFO=&lt;ID=pytorCL,Number=1,Type=Integer,Description=&#34;Caller method&#34;&gt;
##INFO=&lt;ID=SAMPLES,Number=.,Type=String,Description=&#34;Sample genotyped to have the variant&#34;&gt;
##ALT=&lt;ID=DEL,Description=&#34;Deletion&#34;&gt;
##ALT=&lt;ID=DUP,Description=&#34;Duplication&#34;&gt;
##ALT=&lt;ID=LOH,Description=&#34;Copy number neutral loss of heterozygosity&#34;&gt;
##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=&#34;Genotype&#34;&gt;;
##FORMAT=&lt;ID=CN,Number=1,Type=Integer,Description=&#34;Copy number genotype for imprecise events&#34;&gt;
#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\t{samples}&#34;&#34;&#34;
            if self.reference_genome:
                rg = self.reference_genome[&#34;name&#34;]
            else:
                rg = &#34;unknown&#34;
            header = header.format(date=datetime.date.today().strftime(&#34;%Y-%m-%d&#34;), rg=rg, samples=&#34;\t&#34;.join(samples))
            ii = 0
            with open(self.print_filename, &#39;w&#39;) as f:
                print(header, file=f)
                for call in calls:
                    ii += 1
                    id = &#34;CNVpytor_&#34; + {&#34;deletion&#34;: &#34;del&#34;, &#34;duplication&#34;: &#34;dup&#34;, &#34;cnnloh&#34;: &#34;loh&#34;}[call[2]] + str(ii)
                    alt = {&#34;deletion&#34;: &#34;&lt;DEL&gt;&#34;, &#34;duplication&#34;: &#34;&lt;DUP&gt;&#34;, &#34;cnnloh&#34;: &#34;&lt;LOH&gt;&#34;}[call[2]]
                    info = &#34;END=&#34; + str(int(call[5])) + &#34;;IMPRECISE;SVLEN=&#34; + str(int(call[6])) + &#34;;SVTYPE=&#34; + alt[1:4]
                    info += &#34;;pytorRD=&#34; + str(call[7])
                    info += &#34;;pytorP1=&#34; + str(call[8])
                    info += &#34;;pytorP2=&#34; + str(call[9])
                    info += &#34;;pytorP3=&#34; + str(call[10])
                    info += &#34;;pytorP4=&#34; + str(call[11])
                    info += &#34;;pytorQ0=&#34; + str(call[12])
                    info += &#34;;pytorPN=&#34; + str(call[13])
                    info += &#34;;pytorDG=&#34; + str(call[14])
                    info += &#34;;pytorCL=&#34; + call[1]
                    format = &#34;GT:CN&#34;
                    row = [call[3], int(call[4]), id, &#34;.&#34;, alt, &#34;.&#34;, &#34;PASS&#34;, info, format]
                    for sample in samples:
                        if sample == call[0]:
                            if call[2] == &#34;deletion&#34; and call[7] &lt; 0.25:
                                row.append(&#34;1/1:0&#34;)
                            elif call[2] == &#34;deletion&#34; and call[7] &gt; 0.25:
                                row.append(&#34;0/1:0&#34;)
                            elif call[2] == &#34;duplication&#34; and call[7] &lt;= 1.75:
                                row.append(&#34;0/1:2&#34;)
                            elif call[2] == &#34;duplication&#34; and call[7] &gt; 1.75 and call[7] &lt;= 2.25:
                                row.append(&#34;1/1:2&#34;)
                            elif call[2] == &#34;duplication&#34; and call[7] &gt; 2.25:
                                row.append(&#34;./1:%.2f&#34; % call[7])
                            else:
                                row.append(&#34;./.:.&#34;)
                        else:
                            row.append(&#34;./.:.&#34;)
                    print(*row, sep=&#34;\t&#34;, file=f)
        if self.plot:
            for call in calls:
                plot_start = call[4] - call[6]
                if plot_start &lt; 0:
                    plot_start = 0
                plot_end = call[5] + call[6]
                self.multiple_regions([&#34;%s:%d-%d&#34; % (c, plot_start, plot_end)])

    def print_calls(self):
        bin_size = self.bin_size
        n = len(self.plot_files)
        ix = self.plot_files
        if self.annotate:
            annotator = Annotator(self.reference_genome)
        for caller in self.callers:
            if caller == &#34;rd_mean_shift&#34;:
                for i in range(n):
                    io = self.io[ix[i]]
                    chroms = io.rd_chromosomes()
                    for c in chroms:
                        if (c in self.chrom) or len(self.chrom) == 0:
                            flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                            if io.signal_exists(c, bin_size, &#34;calls&#34;, flag):
                                calls = io.read_calls(c, bin_size, &#34;calls&#34;, flag)
                                for call in calls:
                                    if in_interval(call[&#34;size&#34;], self.size_range) \
                                            and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                            and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                            and in_interval(call[&#34;Q0&#34;], self.Q0_range) \
                                            and in_interval(call[&#34;dG&#34;], self.dG_range):
                                        type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;
                                        if n &gt; 1:
                                            print(&#34;%s\t&#34; % self.file_title(i), end=&#34;&#34;)
                                        if len(self.callers) &gt; 1:
                                            print(&#34;%s\t&#34; % caller, end=&#34;&#34;)
                                        print(&#34;%s\t%s:%d-%d\t%d\t%.4f\t%e\t%e\t%e\t%e\t%.4f\t%.4f\t%d\t&#34; % (
                                            type, c, call[&#34;start&#34;], call[&#34;end&#34;], call[&#34;size&#34;], call[&#34;cnv&#34;],
                                            call[&#34;p_val&#34;],
                                            call[&#34;p_val_2&#34;], call[&#34;p_val_3&#34;], call[&#34;p_val_4&#34;], call[&#34;Q0&#34;], call[&#34;pN&#34;],
                                            call[&#34;dG&#34;]), end=&#34;&#34;)
                                        if self.annotate:
                                            print(&#34;\t%s&#34; % annotator.get_info(
                                                &#34;%s:%d-%d&#34; % (c, call[&#34;start&#34;], call[&#34;end&#34;])))
                                        else:
                                            print()
                                        if self.plot:
                                            plot_start = call[&#34;start&#34;] - call[&#34;size&#34;]
                                            if plot_start &lt; 0:
                                                plot_start = 0
                                            plot_end = call[&#34;end&#34;] + call[&#34;size&#34;]
                                            self.multiple_regions([&#34;%s:%d-%d&#34; % (c, plot_start, plot_end)])
            elif caller == &#34;combined_mosaic&#34;:
                for i in range(n):
                    io = self.io[ix[i]]
                    chroms = io.rd_chromosomes()
                    for c in chroms:
                        if (c in self.chrom) or len(self.chrom) == 0:
                            flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR | \
                                   (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
                            if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                                calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)
                                for call in calls:
                                    if in_interval(call[&#34;size&#34;], self.size_range) \
                                            and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                            and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                            and in_interval(call[&#34;Q0&#34;], self.Q0_range):
                                        type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;
                                        if n &gt; 1:
                                            print(&#34;%s\t&#34; % self.file_title(i), end=&#34;&#34;)
                                        if len(self.callers) &gt; 1:
                                            print(&#34;%s\t&#34; % caller, end=&#34;&#34;)
                                        keys = [&#34;start&#34;, &#34;end&#34;, &#34;size&#34;, &#34;cnv&#34;, &#34;p_val&#34;, &#34;lh_del&#34;, &#34;lh_loh&#34;,
                                                &#34;lh_dup&#34;, &#34;Q0&#34;, &#34;pN&#34;, &#34;pNS&#34;, &#34;pP&#34;, &#34;bins&#34;, &#34;baf&#34;,
                                                &#34;rd_p_val&#34;, &#34;baf_p_val&#34;, &#34;segment&#34;, &#34;hets&#34;, &#34;homs&#34;]
                                        type = {-1: &#34;deletion&#34;, 0: &#34;cnnloh&#34;, 1: &#34;duplication&#34;}[call[&#34;type&#34;]]
                                        data = [type, c] + [call[k] for k in keys]
                                        for m in range(2):
                                            data += call[&#34;models&#34;][m]

                                        print((&#34;%s\t%s:%d-%d\t%d\t%.4f\t%e\t%e\t%e\t%e&#34; + \
                                               &#34;\t%.4f\t%.4f\t%.4f\t%.4f\t&#34; + &#34;%d\t%d\t%.4f\t%e\t%e\t%d\t%d\t%d\t&#34; + \
                                               &#34;CN%d/CN%d\t%e\t%.4f\t%d\tCN%d/CN%d\t%e\t%.4f&#34;) % tuple(data), end=&#34;&#34;)
                                        if self.annotate:
                                            print(&#34;\t%s&#34; % annotator.get_info(&#34;%s:%d-%d&#34; % (data[1], data[2], data[3])))
                                        else:
                                            print()
                                        if self.plot:
                                            plot_start = call[&#34;start&#34;] - call[&#34;size&#34;]
                                            if plot_start &lt; 0:
                                                plot_start = 0
                                            plot_end = call[&#34;end&#34;] + call[&#34;size&#34;]
                                            self.multiple_regions([&#34;%s:%d-%d&#34; % (c, plot_start, plot_end)])

    def print_simple_joint_calls(self):

        bin_size = self.bin_size
        n = len(self.plot_files)
        if n == 0:
            return
        ix = self.plot_files
        format = self.print_filename.split(&#34;.&#34;)[-1]
        if format == &#34;tsv&#34;:
            f = open(self.print_filename, &#39;w&#39;)
        elif format == &#34;xlsx&#34;:
            import xlsxwriter
            if os.path.exists(self.print_filename):
                os.remove(self.print_filename)
            workbook = xlsxwriter.Workbook(self.print_filename)
            sheet = workbook.add_worksheet(&#34;merged_calls&#34;)
            header = [&#34;TYPE&#34;, &#34;REGION&#34;, &#34;SIZE&#34;]
            for i in range(n):
                header.append(self.file_title(ix[i]))
            if self.annotate:
                header.append(&#34;GENES&#34;)
            styleh = workbook.add_format({&#39;bold&#39;: True, &#39;font_color&#39;: &#39;white&#39;})
            styleh.set_pattern(1)  # This is optional when using a solid fill.
            styleh.set_bg_color(&#39;#555555&#39;)
            styleh2 = workbook.add_format({&#39;bold&#39;: True, &#39;font_color&#39;: &#39;white&#39;})
            styleh2.set_pattern(1)  # This is optional when using a solid fill.
            styleh2.set_bg_color(&#39;#555555&#39;)
            styleh2.set_rotation(75)
            style_r = workbook.add_format()
            style_r.set_pattern(1)  # This is optional when using a solid fill.
            style_r.set_bg_color(&#39;red&#39;)
            style_g = workbook.add_format()
            style_g.set_pattern(1)  # This is optional when using a solid fill.
            style_g.set_bg_color(&#39;green&#39;)
            style_size = workbook.add_format({&#39;num_format&#39;: &#39;#,##0&#39;})
            style_cn = workbook.add_format({&#39;num_format&#39;: &#39;0&#39;})
            style_cn_b = workbook.add_format({&#39;num_format&#39;: &#39;0&#39;, &#39;bold&#39;: True})
            sheet.set_column(0, 0, 10)
            sheet.set_column(1, 1, 22)
            sheet.set_column(2, 2, 10)
            if self.annotate:
                sheet.set_column(len(header) - 1, len(header) - 1, 100)

            for col, val in enumerate(header):
                if col &gt; 2 and col &lt; len(header) - int(self.annotate):
                    sheet.write(0, col, val, styleh2)
                else:
                    sheet.write(0, col, val, styleh)
            ri = 0
        if self.annotate:
            annotator = Annotator(self.reference_genome)
        chroms = self.io[ix[0]].rd_chromosomes()
        for c in chroms:
            if (c in self.chrom) or len(self.chrom) == 0:
                flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                calls = [list(filter(lambda call: in_interval(call[&#34;size&#34;], self.size_range) \
                                                  and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                                  and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                                  and in_interval(call[&#34;Q0&#34;], self.Q0_range) \
                                                  and in_interval(call[&#34;dG&#34;], self.dG_range),
                                     self.io[ix[i]].read_calls(c, bin_size, &#34;calls&#34;, flag))) for i in range(n)]
                pointers = [0] * n
                while any([pointers[i] &lt; len(calls[i]) for i in range(n)]):
                    starts = [calls[i][pointers[i]][&#34;start&#34;] if pointers[i] &lt; len(calls[i]) else np.inf for i in
                              range(n)]
                    mini = starts.index(min(starts))
                    maxend = 0
                    toupdate = []
                    minend = calls[mini][pointers[mini]][&#34;end&#34;]
                    maxstart = 0
                    files = []
                    types = []
                    cns = []
                    for i in range(n):
                        if (pointers[i] &lt; len(calls[i])) and ((min(calls[i][pointers[i]][&#34;end&#34;],
                                                                   calls[mini][pointers[mini]][&#34;end&#34;]) -
                                                               calls[i][pointers[i]][&#34;start&#34;]) &gt; (
                                                                      0.5 * calls[mini][pointers[mini]][&#34;size&#34;])) \
                                and ((min(calls[i][pointers[i]][&#34;end&#34;],
                                          calls[mini][pointers[mini]][&#34;end&#34;]) -
                                      calls[i][pointers[i]][&#34;start&#34;]) &gt; (
                                             0.5 * (calls[i][pointers[i]][&#34;end&#34;] - calls[i][pointers[i]][&#34;start&#34;]))):
                            toupdate.append(i)
                            call = calls[i][pointers[i]]
                            if call[&#34;end&#34;] &gt; maxend:
                                maxend = call[&#34;end&#34;]
                            if call[&#34;end&#34;] &lt; minend:
                                minend = call[&#34;end&#34;]
                            if call[&#34;start&#34;] &gt; maxstart:
                                maxstart = call[&#34;start&#34;]
                            type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;
                            types.append(type)
                            files.append(i)
                            cns.append(int(call[&#34;cnv&#34;] * 2))
                    type = max(set(types), key=types.count)
                    data = [type, c, maxstart, minend, minend - maxstart + 1]
                    genotypes = [
                        self.genotype([bin_size], &#34;%s:%d-%d&#34; % (c, maxstart, minend), file_index=ix[i], p_val=True)[0]
                        for i
                        in range(n)]
                    copynumbers = [c[3] for c in genotypes]
                    if np.all([np.abs(c - np.round(c)) &lt; 0.25 for c in copynumbers]) or True:
                        if self.print_filename == &#34;&#34;:
                            print((&#34;%s\t%s:%d-%d\t%d&#34; + n * &#34;\t%.2f&#34;) % tuple(data + copynumbers), end=&#34;&#34;)
                            print(&#34;\t%s&#34; % str(files), end=&#34;&#34;)
                            if self.annotate:
                                print(&#34;\t%s&#34; % annotator.get_info(&#34;%s:%d-%d&#34; % (c, maxstart, minend)))
                            else:
                                print()
                        elif format == &#34;tsv&#34;:
                            print((&#34;%s\t%s:%d-%d\t%d&#34; + n * &#34;\t%.2f&#34;) % tuple(data + copynumbers), end=&#34;&#34;, file=f)
                            print(&#34;\t%s&#34; % str(files), end=&#34;&#34;, file=f)
                            if self.annotate:
                                print(&#34;\t%s&#34; % annotator.get_info(&#34;%s:%d-%d&#34; % (c, maxstart, minend)), file=f)
                            else:
                                print(file=f)
                        elif format == &#34;xlsx&#34;:
                            ri += 1
                            if type == &#34;deletion&#34;:
                                sheet.write(ri, 0, data[0], style_r)
                            else:
                                sheet.write(ri, 0, data[0], style_g)
                            sheet.write(ri, 1, &#34;%s:%d-%d&#34; % (c, maxstart, minend))
                            sheet.write(ri, 2, data[4], style_size)
                            for col, val in enumerate(copynumbers):
                                if col in files:
                                    sheet.write(ri, 3 + col, val, style_cn_b)
                                else:
                                    sheet.write(ri, 3 + col, val, style_cn)
                            if self.annotate:
                                sheet.write(ri, 3 + len(copynumbers),
                                            annotator.get_info(&#34;%s:%d-%d&#34; % (c, maxstart, minend)))

                        if self.plot:
                            plot_start = maxstart - (minend - maxstart)
                            if plot_start &lt; 0:
                                plot_start = 0
                            plot_end = minend + (minend - maxstart)
                            self.multiple_regions([&#34;%s:%d-%d&#34; % (c, plot_start, plot_end)])
                    for i in toupdate:
                        pointers[i] += 1
        if format == &#34;tsv&#34;:
            f.close()
        elif format == &#34;xlsx&#34;:
            sheet.conditional_format(1, 3, ri, len(header) - int(self.annotate), {&#39;type&#39;: &#39;3_color_scale&#39;,
                                                                                  &#39;min_color&#39;: &#34;#FF0000&#34;,
                                                                                  &#39;mid_color&#39;: &#34;#FFFFFF&#34;,
                                                                                  &#39;max_color&#39;: &#34;#00FF00&#34;,
                                                                                  &#39;min_type&#39;: &#39;num&#39;,
                                                                                  &#39;min_value&#39;: 0,
                                                                                  &#39;mid_type&#39;: &#39;num&#39;,
                                                                                  &#39;mid_value&#39;: 2,
                                                                                  &#39;max_type&#39;: &#39;num&#39;,
                                                                                  &#39;max_value&#39;: 4
                                                                                  })
            workbook.close()

    def manhattan(self, plot_type=&#34;rd&#34;):
        bin_size = self.bin_size
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for manhattan.&#34;)
            return
        n = len(self.plot_files)
        ix = self.plot_files

        self.new_figure(panel_count=n, grid=(1, n), panel_size=(24, 2))
        for i in range(n):
            ax = self.next_panel()
            io = self.io[ix[i]]
            ax.set_title(self.file_title(ix[i]), position=(0.01, 1.01),
                         fontdict={&#39;verticalalignment&#39;: &#39;bottom&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})

            if plot_type == &#34;rd&#34;:
                chroms = []
                for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                    rd_chr = io.rd_chromosome_name(c)
                    if len(self.chrom) == 0 or (rd_chr in self.chrom) or (c in self.chrom):
                        if io.signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                                io.signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                            chroms.append((rd_chr, l))

                apos = 0
                xticks = [0]

                max_m, stdev = io.rd_normal_level(bin_size, FLAG_GC_CORR)
                for c, l in chroms:
                    flag_rd = (FLAG_USEMASK if self.rd_use_mask else 0)
                    his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                    his_p_corr = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
                    if self.rd_manhattan_call:
                        his_p_call = io.get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
                        his_p_mosaic_seg = io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                         flag_rd | FLAG_GC_CORR)
                        his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
                        his_p_mosaic_call = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                          flag_rd | FLAG_GC_CORR)
                        his_p_mosaic_seg_2d = io.get_signal(c, bin_size, &#34;RD mosaic segments 2d&#34;,
                                                            flag_rd | FLAG_GC_CORR)
                        his_p_mosaic_seg_2d = segments_decode(his_p_mosaic_seg_2d)
                        his_p_mosaic_call_2d = io.get_signal(c, bin_size, &#34;RD mosaic call 2d&#34;,
                                                             flag_rd | FLAG_GC_CORR)
                        his_p_mosaic = np.zeros_like(his_p) * np.nan
                        if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and (
                                &#34;rd_mosaic&#34; in self.callers):
                            for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                                for segi in seg:
                                    his_p_mosaic[segi] = lev
                        his_p_mosaic_2d = np.zeros_like(his_p) * np.nan
                        if his_p_mosaic_call_2d is not None and len(
                                his_p_mosaic_call_2d) &gt; 0 and (&#34;combined_mosaic&#34; in self.callers):
                            for seg, lev in zip(list(his_p_mosaic_seg_2d), list(his_p_mosaic_call_2d[0])):
                                for segi in seg:
                                    his_p_mosaic_2d[segi] = lev
                    pos = range(apos, apos + len(his_p))
                    ax.text(apos + len(his_p) // 2, max_m // 10, Genome.canonical_chrom_name(c),
                            fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                    if self.markersize == &#34;auto&#34;:
                        plt.plot(pos, his_p_corr, ls=&#39;&#39;, marker=&#39;.&#39;)
                    else:
                        plt.plot(pos, his_p_corr, ls=&#39;&#39;, marker=&#39;.&#39;, markersize=self.markersize)
                    if self.rd_manhattan_call:
                        if his_p_call is not None and len(his_p_call) &gt; 0 and (&#34;rd_mean_shift&#34; in self.callers):
                            plt.step(pos, his_p_call, &#34;r&#34;)
                        if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and (
                                &#34;rd_mosaic&#34; in self.callers):
                            plt.plot(pos, his_p_mosaic, &#34;k&#34;)
                        if his_p_mosaic_call_2d is not None and len(
                                his_p_mosaic_call_2d) &gt; 0 and (&#34;combined_mosaic&#34; in self.callers):
                            plt.plot(pos, his_p_mosaic_2d, &#34;k&#34;)
                    apos += len(his_p)
                    xticks.append(apos)
                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks(np.arange(0, 15, 0.5) * max_m, minor=[])
                ax.xaxis.set_ticks(xticks, minor=[])
                ax.set_ylim([self.rd_manhattan_range[0] * max_m, self.rd_manhattan_range[1] * max_m])
                n_bins = apos
                ax.set_xlim([0, n_bins])
                ax.grid()

            elif plot_type == &#34;baf_mosaic&#34;:
                chroms = []
                snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                    FLAG_USEHAP if self.snp_use_phase else 0)
                for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                    snp_chr = io.snp_chromosome_name(c)
                    if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                        if io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood call&#34;, snp_flag) and \
                                io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood segments&#34;, snp_flag) and \
                                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                            chroms.append((snp_chr, l))

                apos = 0
                xticks = [0]

                cix = 0
                cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
                for c, l in chroms:
                    likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                    segments = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
                    call_pos = []
                    call_baf = []
                    call_c = []
                    for s, lh in zip(segments, likelihood):
                        b, p = likelihood_baf_pval(lh)
                        if b &gt; 0 and len(s) &gt; self.min_segment_size:
                            alpha = -np.log(p + 1e-40) / self.contrast
                            if alpha &gt; 1:
                                alpha = 1
                            for pos in s:
                                call_pos.append(apos + pos)
                                call_baf.append(b)
                                color = cmap[cix % len(cmap)]
                                color = (color[0], color[1], color[2], alpha)
                                call_c.append(color)

                    ax.text(apos + l // bin_size // 2, 0.4, Genome.canonical_chrom_name(c),
                            fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                    plt.scatter(call_pos, call_baf, s=20, color=np.array(call_c), edgecolors=&#39;face&#39;, marker=&#39;|&#39;)
                    apos += l // bin_size
                    xticks.append(apos)
                    cix += 1

                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks(np.arange(0, 0.5, 0.1), minor=[])
                ax.xaxis.set_ticks(xticks, minor=[])
                ax.set_ylim([0, 0.5])
                n_bins = apos
                ax.set_xlim([0, n_bins])
                ax.grid()

            elif plot_type == &#34;rd_mean_shift&#34;:
                chroms = []
                flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR

                for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                    rd_chr = io.rd_chromosome_name(c)
                    if rd_chr is not None and len(self.chrom) == 0 or (rd_chr in self.chrom) or (c in self.chrom):
                        if (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                            chroms.append((rd_chr, l))

                apos = 0
                xticks = [0]

                cix = 0
                cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
                for c, l in chroms:
                    call_pos = []
                    call_conc = []
                    call_c = []
                    if io.signal_exists(c, bin_size, &#34;calls&#34;, flag):
                        calls = io.read_calls(c, bin_size, &#34;calls&#34;, flag)

                        for call in calls:
                            if in_interval(call[&#34;size&#34;], self.size_range) and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                    and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                    and in_interval(call[&#34;Q0&#34;], self.Q0_range):
                                alpha = - np.log(call[&#34;p_val&#34;] + 1e-40) / self.contrast
                                if alpha &gt; 1:
                                    alpha = 1
                                if alpha &lt; 0:
                                    alpha = 0
                                for pos in range(int(call[&#34;start&#34;]) // bin_size, int(call[&#34;end&#34;]) // bin_size + 1):
                                    call_pos.append(apos + pos)
                                    level = call[&#34;cnv&#34;] * 2
                                    if level &gt; 4:
                                        level = 4
                                    call_conc.append(level)
                                    if call[&#34;type&#34;] == 1:
                                        call_c.append((0, 1, 0, alpha))
                                    elif call[&#34;type&#34;] == -1:
                                        call_c.append((1, 0, 0, alpha))
                                    else:
                                        call_c.append((0, 0, 1, alpha))
                        ax.text(apos + l // bin_size // 2, 0.4, Genome.canonical_chrom_name(c),
                                fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                        plt.scatter(call_pos, call_conc, s=20, color=np.array(call_c), edgecolors=&#39;face&#39;, marker=&#39;|&#39;)
                        apos += l // bin_size
                        xticks.append(apos)
                        cix += 1

                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks(np.arange(0, 4.0, 1.0), minor=[])
                ax.xaxis.set_ticks(xticks, minor=[])
                ax.set_ylim([0, 4.0])
                n_bins = apos
                ax.set_xlim([0, n_bins])
                ax.grid()

            elif plot_type == &#34;combined_mosaic&#34;:
                chroms = []
                flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                    FLAG_USEHAP if self.snp_use_phase else 0) | (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR

                for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                    snp_chr = io.snp_chromosome_name(c)
                    if snp_chr is not None and len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                        if (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                            chroms.append((snp_chr, l))

                apos = 0
                xticks = [0]

                cix = 0
                cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
                for c, l in chroms:
                    call_pos = []
                    call_conc = []
                    call_c = []
                    if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                        calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)

                        for call in calls:
                            if call[&#34;bins&#34;] &gt; self.min_segment_size:
                                alpha = -np.log(call[&#34;p_val&#34;] + 1e-40) / self.contrast
                                if alpha &gt; 1:
                                    alpha = 1
                                for pos in range(int(call[&#34;start&#34;]) // bin_size, int(call[&#34;end&#34;]) // bin_size + 1):
                                    call_pos.append(apos + pos)
                                    call_conc.append(call[&#34;models&#34;][0][4])
                                    if call[&#34;type&#34;] == 1:
                                        call_c.append((0, 1, 0, alpha))
                                    elif call[&#34;type&#34;] == -1:
                                        call_c.append((1, 0, 0, alpha))
                                    else:
                                        call_c.append((0, 0, 1, alpha))

                        ax.text(apos + l // bin_size // 2, 0.4, Genome.canonical_chrom_name(c),
                                fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                        plt.scatter(call_pos, call_conc, s=20, color=np.array(call_c), edgecolors=&#39;face&#39;, marker=&#39;|&#39;)
                        apos += l // bin_size
                        xticks.append(apos)
                        cix += 1

                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks(np.arange(0, 1.0, 0.1), minor=[])
                ax.xaxis.set_ticks(xticks, minor=[])
                ax.set_ylim([0, 1.0])

                n_bins = apos
                ax.set_xlim([0, n_bins])
                ax.grid()

        self.fig_show(suffix=&#34;manhattan&#34; if plot_type == &#34;rd&#34; else &#34;snp_calls&#34;)

    def callmap(self, color=&#34;frequency&#34;, background=&#34;white&#34;, pixel_size=1700000, max_p_val=1e-20, min_freq=0.01,
                plot=&#34;cmap&#34;):
        bin_size = self.bin_size
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for callmap.&#34;)
            return
        n = len(self.plot_files)
        ix = self.plot_files

        if plot:
            self.new_figure(panel_count=n, grid=(1, 1), panel_size=(24, 0.24 * n))

        chroms = []
        starts = []
        ends = []
        pixels = 0
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            if l &gt; 10 * bin_size:
                if len(self.chrom) == 0 or (c in self.chrom) or (self.io[0].snp_chromosome_name(c) in self.chrom):
                    chroms.append(c)
                    starts.append(pixels)
                    pixels += l // pixel_size + 1
                    ends.append(pixels - 1)

        cmap = np.zeros((n, pixels, 3))
        cmap[:, ends, :] = 1

        for i in range(n):
            io = self.io[ix[i]]
            print(io.filename)
            flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                FLAG_USEHAP if self.snp_use_phase else 0) | (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
            flag_rd = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
            for c, start in zip(chroms, starts):
                snp_chr = io.snp_chromosome_name(c)
                if io.signal_exists(snp_chr, bin_size, &#34;calls combined&#34;, flag):

                    calls = io.read_calls(snp_chr, bin_size, &#34;calls combined&#34;, flag)
                    segments = io.get_signal(snp_chr, bin_size, &#34;RD mosaic segments 2d&#34;, flag_rd)
                    segments = segments_decode(segments)

                    for call in calls:
                        if call[&#34;bins&#34;] &gt; self.min_segment_size and call[&#34;p_val&#34;] &lt; max_p_val and &#34;segment&#34; in call and \
                                call[&#34;models&#34;][0][4] &gt; min_freq:
                            cix = int(call[&#34;type&#34;]) + 1
                            for b in segments[int(call[&#34;segment&#34;])]:
                                if color == &#34;frequency&#34;:
                                    cmap[i, start + b * bin_size // pixel_size, cix] = max(
                                        cmap[i, start + b * bin_size // pixel_size, cix], call[&#34;models&#34;][0][4])
                                elif color == &#34;coverage&#34;:
                                    cmap[i, start + b * bin_size // pixel_size, cix] += bin_size / pixel_size
                                else:  # model copy number
                                    if call[&#34;models&#34;][0][0] == 0:
                                        cmap[i, start + b * bin_size // pixel_size, 0] = 1
                                    elif call[&#34;models&#34;][0][0] == 1:
                                        cmap[i, start + b * bin_size // pixel_size, 0] = 1
                                        cmap[i, start + b * bin_size // pixel_size, 1] = 1
                                    elif call[&#34;models&#34;][0][0] == 2:
                                        cmap[i, start + b * bin_size // pixel_size, 2] = 1
                                    else:
                                        cn = call[&#34;models&#34;][0][0]
                                        if cn &gt; 6:
                                            cn = 6
                                        cmap[i, start + b * bin_size // pixel_size, 1] = (2 + cn) / 8

        def b2w(pixel):
            if np.all(pixel == 1):
                pixel[:] = 0
            elif pixel[0] &gt; pixel[1] and pixel[0] &gt; pixel[2]:
                pixel[1] = pixel[2] = 1 - pixel[0]
                pixel[0] = 1
            elif pixel[1] &gt; pixel[2]:
                pixel[0] = pixel[2] = 1 - pixel[1]
                pixel[1] = 1
            else:
                pixel[0] = pixel[1] = 1 - pixel[2]
                pixel[2] = 1
            return pixel

        if background == &#34;white&#34;:
            cmap = cmap.reshape(n * pixels, 3)
            np.apply_along_axis(b2w, 1, cmap)
            cmap = cmap.reshape(n, pixels, 3)

        cmap = (255 * cmap).astype(&#34;int&#34;)
        if plot == &#34;cmap&#34;:
            self.new_figure(panel_count=1, grid=(1, 1), panel_size=(24, 0.24 * n))
            ax = self.next_panel()
            plt.imshow(cmap, aspect=&#39;auto&#39;)
            for i in ends[:-1]:
                plt.axvline(x=i - 0.5, color=&#39;red&#39;, linewidth=0.5)
            ax.set_yticks([])
            ax.set_yticklabels([])
            ax.set_xticks((np.array(starts) + np.array(ends)) / 2)
            chroms = list(map(Genome.canonical_chrom_name, chroms))
            ax.set_xticklabels(chroms)
            self.fig_show(suffix=&#34;callmap&#34;)
        elif plot == &#34;regions&#34;:
            self.new_figure(panel_count=1, grid=(1, 1), panel_size=(24, 24))
            ax = self.next_panel()
            corr = np.corrcoef(
                np.concatenate((cmap[:, :, 0].transpose(), cmap[:, :, 1].transpose(), cmap[:, :, 2].transpose()),
                               axis=0))
            plt.imshow(corr, aspect=&#39;auto&#39;, vmin=-1, vmax=1)
            plt.colorbar()
            starts3 = np.concatenate((np.array(starts), np.array(starts) + ends[-1], np.array(starts) + 2 * ends[-1]))
            ends3 = np.concatenate((np.array(ends), np.array(ends) + ends[-1], np.array(ends) + 2 * ends[-1]))
            for i in ends3[:-1]:
                plt.axvline(x=i - 0.5, color=&#39;red&#39;, linewidth=0.5)
                plt.axhline(y=i - 0.5, color=&#39;red&#39;, linewidth=0.5)

            ax.set_xticks((starts3 + ends3) / 2)
            ax.set_yticks((starts3 + ends3) / 2)
            chroms = list(map(Genome.canonical_chrom_name, chroms))
            ax.set_xticklabels(chroms + chroms + chroms)
            ax.set_yticklabels(chroms + chroms + chroms)
            self.fig_show(suffix=&#34;callmap&#34;)
        else:
            self.new_figure(panel_count=2, panel_size=(12, 12))
            ax = self.next_panel()
            x = np.concatenate((cmap[:, :, 0], cmap[:, :, 1], cmap[:, :, 2]),
                               axis=1)
            corr = np.corrcoef(x)
            plt.imshow(corr, aspect=&#39;auto&#39;, vmin=-1, vmax=1)
            plt.colorbar()
            ax = plt.gca()

            ax.set_xticks(range(n))
            ax.set_yticks(range(n))
            ax = self.next_panel()
            Z = hierarchy.linkage(x, &#39;average&#39;, &#39;correlation&#39;)
            dn = hierarchy.dendrogram(Z)

            self.fig_show(suffix=&#34;callmap&#34;)
        return cmap

    def multiple_regions(self, regions):
        n = len(self.plot_files) * len(regions)
        self.new_figure(panel_count=n)
        j = 0
        for i in range(len(self.plot_files)):
            for r in regions:
                self.regions(self.plot_files[i], r)
                j += 1
        self.fig_show(suffix=&#34;regions&#34;)

    def regions(self, ix, region):
        panels = self.panels
        bin_size = self.bin_size
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0)
        self.new_subgrid(len(panels), hspace=0.05, wspace=0.1)
        r = decode_region(region, max_size=1000000000)
        io = self.io[ix]
        for i in range(len(panels)):
            ax = self.next_subpanel(sharex=True)
            if i == 0 and self.title:
                ax.set_title(self.file_title(ix) + &#34;: &#34; + region, position=(0.01, 0.9),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                             color=&#39;C0&#39;)

            if panels[i] == &#34;rd&#34;:
                g_p = [0]
                g_p_corr = [0]
                g_p_seg = [0]
                g_p_call = [0]
                g_p_call_mosaic = [0]
                g_p_call_mosaic_2d = [0]
                mean, stdev = 0, 0
                borders = []
                pos_x = []
                for c, (pos1, pos2) in r:
                    if pos2 == 1000000000:
                        pos2 = io.get_chromosome_length(c)
                        if pos2 is None:
                            pos2 = 1000000000
                    flag_rd = 0
                    if self.rd_use_mask:
                        flag_rd = FLAG_USEMASK
                    mean, stdev = io.rd_normal_level(bin_size, flag_rd | FLAG_GC_CORR)
                    his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                    his_p_corr = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_seg = io.get_signal(c, bin_size, &#34;RD partition&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_call = io.get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg = io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                     flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
                    his_p_mosaic_call = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                      flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg_2d = io.get_signal(c, bin_size, &#34;RD mosaic segments 2d&#34;,
                                                        flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg_2d = segments_decode(his_p_mosaic_seg_2d)
                    his_p_mosaic_call_2d = io.get_signal(c, bin_size, &#34;RD mosaic call 2d&#34;,
                                                         flag_rd | FLAG_GC_CORR)
                    his_p_mosaic = np.zeros_like(his_p) * np.nan
                    if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and (&#34;rd_mosaic&#34; in self.callers):
                        for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                            for segi in seg:
                                his_p_mosaic[segi] = lev
                    his_p_mosaic_2d = np.zeros_like(his_p) * np.nan
                    if his_p_mosaic_call_2d is not None and len(his_p_mosaic_call_2d) &gt; 0 and (
                            &#34;combined_mosaic&#34; in self.callers):
                        for seg, lev in zip(list(his_p_mosaic_seg_2d), list(his_p_mosaic_call_2d[0])):
                            for segi in seg:
                                his_p_mosaic_2d[segi] = lev
                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    bins = len(list(his_p[start_bin:end_bin]))
                    pos_x.extend(range(pos1, pos2 + bin_size, bin_size)[0:bins])

                    g_p.extend(list(his_p[start_bin:end_bin]))
                    g_p_corr.extend(list(his_p_corr[start_bin:end_bin]))
                    if his_p_seg is not None and len(his_p_seg) &gt; 0 and self.rd_partition:
                        g_p_seg.extend(list(his_p_seg[start_bin:end_bin]))
                    if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call and (
                            &#34;rd_mean_shift&#34; in self.callers):
                        g_p_call.extend(list(his_p_call[start_bin:end_bin]))
                    if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call and (
                            &#34;rd_mosaic&#34; in self.callers):
                        g_p_call_mosaic.extend(list(his_p_mosaic[start_bin:end_bin]))
                    if his_p_mosaic_call_2d is not None and len(his_p_mosaic_call_2d) &gt; 0 and self.rd_call and (
                            &#34;combined_mosaic&#34; in self.callers):
                        g_p_call_mosaic_2d.extend(list(his_p_mosaic_2d[start_bin:end_bin]))
                    borders.append(len(g_p) - 1)

                def format_func(value, tick_number):
                    ix = int(value)
                    if ix + 1 &lt; len(pos_x):
                        p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    elif ix &lt; len(pos_x):
                        p = pos_x[ix]
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    else:
                        return &#34;&#34;

                l = len(g_p)
                if i == len(panels) - 1:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                    ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                    ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                    ax.xaxis.grid()
                else:
                    plt.setp(ax.get_xticklabels(), visible=False)

                if (self.rd_range[1] - self.rd_range[0]) &lt; 30:
                    ax.yaxis.set_ticks(np.arange(int(self.rd_range[0]), int(self.rd_range[1] + 1), 1) * mean / 2,
                                       minor=[])
                    ax.yaxis.set_ticklabels([str(i) for i in range(int(self.rd_range[0]), int(self.rd_range[1] + 1))])
                ax.set_ylim([self.rd_range[0] * mean / 2, self.rd_range[1] * mean / 2])
                ax.set_ylabel(&#34;Read depth&#34;)
                ax.yaxis.grid()

                if self.rd_raw:
                    ax.step(g_p, self.rd_colors[0], label=&#34;raw&#34;)
                if self.rd_corrected:
                    ax.step(g_p_corr, self.rd_colors[1], label=&#34;GC corrected&#34;)
                if len(g_p_seg) &gt; 1:
                    plt.step(g_p_seg, self.rd_colors[2], label=&#34;partitioning&#34;)
                if len(g_p_call) &gt; 1:
                    plt.step(g_p_call, self.rd_colors[3], label=&#34;cnv calls&#34;)
                if len(g_p_call_mosaic) &gt; 1:
                    plt.step(g_p_call_mosaic, self.rd_colors[4], label=&#34;mosaic cnv calls&#34;)
                if len(g_p_call_mosaic_2d) &gt; 1:
                    plt.step(g_p_call_mosaic_2d, self.rd_colors[5], label=&#34;combined cnv calls&#34;)
                for i in borders[:-1]:
                    ax.axvline(i, color=&#34;g&#34;, lw=1)
                if self.legend:
                    ax.legend(loc=&#39;upper center&#39;, bbox_to_anchor=(0.5, -0.05), shadow=True, ncol=2)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;snp&#34;:
                borders = []
                hpos = []
                baf = []
                color = []
                alpha = 0.7
                start_pos = 0
                pos_x = []
                for c, (pos1, pos2) in r:
                    if pos2 == 1000000000:
                        pos2 = io.get_chromosome_length(c)
                        if pos2 is None:
                            pos2 = 1000000000
                    pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c)
                    ix = 0
                    mdp = 0
                    while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                        if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0 and ((not self.snp_use_id) or (flag[ix] &amp; 1)):
                            hpos.append((start_pos + pos[ix] - pos1) / bin_size)
                            if pos[ix] - pos1 &gt; mdp:
                                mdp = pos[ix] - pos1
                            if gt[ix] % 4 != 2:
                                baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            else:
                                baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                            if self.snp_alpha_P:
                                alpha = None
                                color.append(
                                    colors.to_rgba(self.snp_colors[(gt[ix] % 4) * 2 + 1], (flag[ix] &gt;&gt; 1) * 0.4))
                            else:
                                color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                        ix += 1
                    start_pos += pos2 - pos1
                    pos_x.extend(range(pos1, pos2 + bin_size, bin_size))
                    borders.append(start_pos / bin_size)

                def format_func(value, tick_number):
                    ix = int(value)
                    if ix + 1 &lt; len(pos_x):
                        p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    elif ix &lt; len(pos_x):
                        p = pos_x[ix]
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    else:
                        return &#34;&#34;

                l = len(pos_x)
                if i == len(panels) - 1:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                    ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                    ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                    ax.xaxis.grid()
                else:
                    plt.setp(ax.get_xticklabels(), visible=False)

                # ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
                ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
                ax.set_ylabel(&#34;Allele frequency&#34;)
                l = max(hpos)
                ax.set_ylim([-0.05, 1.05])
                # ax.set_xlim([0, borders[-1]])
                ax.yaxis.grid()
                if self.markersize == &#34;auto&#34;:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=alpha)
                else:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=alpha)

                for i in borders[:-1]:
                    ax.axvline(i, color=&#34;g&#34;, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;snv&#34; or panels[i][:4] == &#34;snv:&#34;:
                callset = &#34;default&#34;
                if panels[i][:4] == &#34;snv:&#34;:
                    callset = panels[i].split(&#34;:&#34;)[1]
                borders = []
                hpos = []
                baf = []
                color = []
                alpha = 0.7
                start_pos = 0
                pos_x = []
                for c, (pos1, pos2) in r:
                    if pos2 == 1000000000:
                        pos2 = io.get_chromosome_length(c)
                        if pos2 is None:
                            pos2 = 1000000000
                    pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c, callset=callset)
                    ix = 0
                    mdp = 0
                    while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                        if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0:
                            hpos.append((start_pos + pos[ix] - pos1) / bin_size)
                            if pos[ix] - pos1 &gt; mdp:
                                mdp = pos[ix] - pos1
                            if gt[ix] % 4 != 2:
                                baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            else:
                                baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                            if self.snp_alpha_P:
                                alpha = None
                                color.append(
                                    colors.to_rgba(self.snp_colors[(gt[ix] % 4) * 2 + 1], (flag[ix] &gt;&gt; 1) * 0.4))
                            else:
                                color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                        ix += 1
                    start_pos += pos2 - pos1
                    pos_x.extend(range(pos1, pos2 + bin_size, bin_size))
                    borders.append(start_pos / bin_size)

                def format_func(value, tick_number):
                    ix = int(value)
                    if ix + 1 &lt; len(pos_x):
                        p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    elif ix &lt; len(pos_x):
                        p = pos_x[ix]
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    else:
                        return &#34;&#34;

                l = len(pos_x)
                if i == len(panels) - 1:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                    ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                    ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                else:
                    plt.setp(ax.get_xticklabels(), visible=False)
                ax.xaxis.grid()
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
                ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
                ax.set_ylabel(&#34;Allele frequency&#34;)
                ax.set_ylim([0., 1.])
                ax.yaxis.grid()
                if self.markersize == &#34;auto&#34;:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=alpha)
                else:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=alpha)

                for i in borders[:-1]:
                    ax.axvline(i, color=&#34;g&#34;, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;baf&#34;:
                g_baf, g_maf, g_i1, g_i2 = [0], [0], [0], [0]
                borders = []
                pos_x = []

                for c, (pos1, pos2) in r:
                    if pos2 == 1000000000:
                        pos2 = io.get_chromosome_length(c)
                        if pos2 is None:
                            pos2 = 1000000000

                    flag_snp = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                        FLAG_USEHAP if self.snp_use_phase else 0)
                    baf = io.get_signal(c, bin_size, &#34;SNP baf&#34;, flag_snp)
                    maf = io.get_signal(c, bin_size, &#34;SNP maf&#34;, flag_snp)
                    i1 = io.get_signal(c, bin_size, &#34;SNP i1&#34;, flag_snp)
                    i2 = io.get_signal(c, bin_size, &#34;SNP i2&#34;, flag_snp)

                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    bins = len(list(baf[start_bin:end_bin]))
                    pos_x.extend(range(pos1, pos2 + bin_size, bin_size)[0:bins])

                    g_baf.extend(list(baf[start_bin:end_bin]))
                    g_maf.extend(list(maf[start_bin:end_bin]))
                    g_i1.extend(list(i1[start_bin:end_bin]))
                    g_i2.extend(list(i2[start_bin:end_bin]))
                    borders.append(len(g_baf) - 1)

                def format_func(value, tick_number):
                    ix = int(value)
                    if ix + 1 &lt; len(pos_x):
                        p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    elif ix &lt; len(pos_x):
                        p = pos_x[ix]
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    else:
                        return &#34;&#34;

                l = len(g_baf)
                if i == len(panels) - 1:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                    ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                    ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                    ax.xaxis.grid()

                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
                ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
                ax.set_ylabel(&#34;Allele frequency&#34;)

                ax.set_ylim([0, 1])
                # ax.set_xlim([-l * 0.0, l * 1.0])

                ax.yaxis.grid()
                # ax.xaxis.grid()
                ax.step(g_baf, self.baf_colors[0], label=&#34;BAF&#34;)
                ax.step(g_maf, self.baf_colors[1], label=&#34;MAF&#34;)
                ax.step(g_i1, self.baf_colors[2], label=&#34;I1&#34;)
                if self.legend:
                    ax.legend()
                for i in borders[:-1]:
                    ax.axvline(i, color=&#34;g&#34;, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;likelihood&#34;:
                borders = []
                gl = []
                call_pos = []
                call_i1 = []
                call_i2 = []
                call_c = []
                call_pos_2d = []
                call_i1_2d = []
                call_i2_2d = []
                call_c_2d = []
                tlen = 0
                tlen_2d = 0
                pos_x = []
                for c, (pos1, pos2) in r:
                    if pos2 == 1000000000:
                        pos2 = io.get_chromosome_length(c)
                        if pos2 is None:
                            pos2 = 1000000000
                    likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    bins = len(list(likelihood[start_bin:end_bin]))
                    pos_x.extend(range(pos1, pos2 + bin_size, bin_size)[0:bins])
                    gl.extend(list(likelihood[start_bin:end_bin]))
                    borders.append(len(gl) - 1)
                    if self.snp_call and (&#34;baf_mosaic&#34; in self.callers):
                        likelihood_call = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                        segments = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))

                        for s, lh in zip(segments, likelihood_call):
                            i1, i2, p = likelihood_pixels_pval(lh)
                            if i1 != i2 and len(s) &gt; self.min_segment_size:
                                alpha = -np.log(p + 1e-40) / self.contrast
                                if alpha &gt; 1:
                                    alpha = 1
                                for pos in s:
                                    if pos &gt;= start_bin and pos &lt; end_bin:
                                        call_pos.append(pos - start_bin + tlen)
                                        call_i1.append(min(i1, i2))
                                        call_i2.append(max(i1, i2))
                                        color = colors.to_rgb(self.lh_colors[0]) + (alpha,)
                                        call_c.append(color)
                        tlen += end_bin - start_bin
                    if self.snp_call and (&#34;combined_mosaic&#34; in self.callers):
                        likelihood_call = io.get_signal(c, bin_size, &#34;SNP likelihood call 2d&#34;, snp_flag)
                        segments = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments 2d&#34;, snp_flag))

                        for s, lh in zip(segments, likelihood_call):
                            i1, i2, p = likelihood_pixels_pval(lh)
                            if i1 != i2 and len(s) &gt; self.min_segment_size:
                                alpha = -np.log(p + 1e-40) / self.contrast
                                if alpha &gt; 1:
                                    alpha = 1
                                for pos in s:
                                    if pos &gt;= start_bin and pos &lt; end_bin:
                                        call_pos_2d.append(pos - start_bin + tlen_2d)
                                        call_i1_2d.append(min(i1, i2))
                                        call_i2_2d.append(max(i1, i2))
                                        color = colors.to_rgb(self.lh_colors[1]) + (alpha,)
                                        call_c_2d.append(color)
                        tlen_2d += end_bin - start_bin

                def format_func(value, tick_number):
                    ix = int(value)
                    if ix + 1 &lt; len(pos_x):
                        p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    elif ix &lt; len(pos_x):
                        p = pos_x[ix]
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    else:
                        return &#34;&#34;

                img = np.array(gl).transpose()
                l = img.shape[1]
                if i == len(panels) - 1:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                    ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                    ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                    # ax.xaxis.grid()
                else:
                    plt.setp(ax.get_xticklabels(), visible=False)

                ax.imshow(img, aspect=&#39;auto&#39;)
                # ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticks([0, img.shape[0] / 4, img.shape[0] / 2, 3 * img.shape[0] / 4, img.shape[0] - 1],
                                   minor=[])
                ax.yaxis.set_ticklabels([&#34;1&#34;, &#34;3/4&#34;, &#34;1/2&#34;, &#34;1/4&#34;, &#34;0&#34;])
                ax.set_ylabel(&#34;Allele frequency&#34;)
                # ax.xaxis.set_ticks(np.arange(0, len(gl), 50), minor=[])
                # ax.set_xlim([-0.5, img.shape[1] - 0.5])
                if self.snp_call and (&#34;baf_mosaic&#34; in self.callers):
                    plt.scatter(call_pos, call_i1, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                                marker=self.lh_marker)
                    plt.scatter(call_pos, call_i2, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                                marker=self.lh_marker)
                if self.snp_call and (&#34;combined_mosaic&#34; in self.callers):
                    plt.scatter(call_pos_2d, call_i1_2d, s=self.lh_markersize, color=np.array(call_c_2d),
                                edgecolors=&#39;face&#39;, marker=self.lh_marker)
                    plt.scatter(call_pos_2d, call_i2_2d, s=self.lh_markersize, color=np.array(call_c_2d),
                                edgecolors=&#39;face&#39;, marker=self.lh_marker)

                for i in borders[:-1]:
                    ax.axvline(i + 0.5, color=&#34;g&#34;, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;CN&#34;:
                borders = []
                gh1 = []
                gh2 = []
                tlen = 0
                tlen_2d = 0
                for c, (pos1, pos2) in r:
                    if pos2 == 1000000000:
                        pos2 = io.get_chromosome_length(c)
                        if pos2 is None:
                            pos2 = 1000000000

                    his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    if end_bin &gt; len(his_p):
                        end_bin = len(his_p)
                    h1 = np.array([0] * (end_bin - start_bin))
                    h2 = np.array([0] * (end_bin - start_bin))
                    h1[his_p != 0] = 1
                    h2[his_p != 0] = 1

                    flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                        FLAG_USEHAP if self.snp_use_phase else 0) | (
                               FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                    flag_rd = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
                    if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                        calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)
                        segments = io.get_signal(c, bin_size, &#34;RD mosaic segments 2d&#34;, flag_rd)
                        segments = segments_decode(segments)

                        for call in calls:
                            for b in segments[int(call[&#34;segment&#34;])]:
                                if b &lt; end_bin and b &gt;= start_bin:
                                    h1[b - start_bin] = call[&#34;models&#34;][0][1]
                                    h2[b - start_bin] = call[&#34;models&#34;][0][2]
                    gh1.extend(list(h1))
                    gh2.extend(list(h2))
                    borders.append(len(gh1) - 1)
                x = range(len(gh1))
                plt.gca().get_xaxis().get_major_formatter().set_useOffset(False)
                plt.stackplot(x, gh1, gh2, baseline=&#39;sym&#39;)

                def format_func(value, tick_number):
                    ix = int(value)
                    if ix + 1 &lt; len(pos_x):
                        p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    elif ix &lt; len(pos_x):
                        p = pos_x[ix]
                        return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                    else:
                        return &#34;&#34;

                l = len(gh1)
                if i == len(panels) - 1:
                    ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                    ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                    ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                    ax.xaxis.grid()

                for i in borders[:-1]:
                    ax.axvline(i + 0.5, color=&#34;g&#34;, lw=1)
                self.fig.add_subplot(ax)

    def global_plot(self):
        chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            rd_chr = self.io[self.plot_files[0]].rd_chromosome_name(c)
            if (len(self.chrom) == 0 or (rd_chr in self.chrom) or (c in self.chrom)) and rd_chr is not None:
                if (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                    chroms.append((rd_chr, l))
        panels = self.panels
        bin_size = self.bin_size
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0)
        rd_flag = (FLAG_USEMASK if self.rd_use_mask else 0) | (FLAG_GC_CORR if self.rd_use_gc_corr else 0)
        n = len(self.plot_files)
        self.new_figure(panel_count=n)
        for ii in range(len(self.plot_files)):
            ix = self.plot_files[ii]
            self.new_subgrid(len(panels), hspace=0.05, wspace=0.05)
            io = self.io[ix]
            for i in range(len(panels)):
                ax = self.next_subpanel(sharex=True)
                if i == 0:
                    ax.set_title(self.file_title(ix), position=(0.01, 0.9),
                                 fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                                 color=&#39;C0&#39;)

                if panels[i] == &#34;rd&#34;:
                    start = 0
                    xticks = [0]
                    xticks_minor = []
                    xticks_labels = []
                    for c, l in chroms:
                        mean, stdev = io.rd_normal_level(bin_size, rd_flag | FLAG_GC_CORR)
                        his_p = io.get_signal(c, bin_size, &#34;RD&#34;, rd_flag)
                        pos = range(start, start + len(his_p))
                        if self.markersize == &#34;auto&#34;:
                            plt.plot(pos, his_p, ls=&#39;&#39;, marker=&#39;.&#39;, markersize=1)
                        else:
                            plt.plot(pos, his_p, ls=&#39;&#39;, marker=&#39;.&#39;, markersize=self.markersize)
                        xticks_minor.append(start + len(his_p) // 2)
                        xticks_labels.append(Genome.canonical_chrom_name(c))
                        start += l // bin_size + 1
                        xticks.append(start)

                    ax.set_xlim([0, start])
                    ax.xaxis.set_ticks(xticks)
                    ax.xaxis.set_ticklabels([&#34;&#34;] * len(xticks))
                    if i == (len(panels) - 1):
                        ax.xaxis.set_ticks(xticks_minor, minor=True)
                        ax.xaxis.set_ticklabels(xticks_labels, minor=True)
                    else:
                        plt.setp(ax.get_xticklabels(which=&#34;both&#34;), visible=False)
                    yticks = np.arange(self.rd_manhattan_range[0], self.rd_manhattan_range[1], 0.5)
                    ax.yaxis.set_ticklabels([str(int(2 * t)) for t in yticks])
                    ax.yaxis.set_ticks(yticks * mean)
                    ax.set_ylabel(&#34;RD [CN]&#34;)
                    ax.set_ylim([self.rd_manhattan_range[0] * mean, self.rd_manhattan_range[1] * mean])
                    ax.grid()
                    self.fig.add_subplot(ax)

                elif panels[i] == &#34;snp&#34;:
                    start = 0
                    xticks = []
                    xticks_minor = []
                    xticks_labels = []
                    pos_x = []
                    for c, l in chroms:
                        pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c)
                        ix = 0
                        hpos = []
                        color = []
                        alpha = 0.7
                        baf = []
                        while ix &lt; len(pos):
                            if (nref[ix] + nalt[ix]) != 0 and ((not self.snp_use_id) or (flag[ix] &amp; 1)):
                                hpos.append(start + (pos[ix] / bin_size))
                                if gt[ix] % 4 != 2:
                                    baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                                else:
                                    baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                                if self.snp_alpha_P:
                                    alpha = None
                                    color.append(
                                        colors.to_rgba(self.snp_colors[(gt[ix] % 4) * 2 + 1], (flag[ix] &gt;&gt; 1) * 0.4))
                                else:
                                    color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                            ix += 1
                        if self.markersize == &#34;auto&#34;:
                            ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=0.1, alpha=alpha)
                        else:
                            ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=alpha)
                        xticks_minor.append(start + l // bin_size // 2)
                        xticks_labels.append(Genome.canonical_chrom_name(c))
                        start += l // bin_size + 1
                        xticks.append(start)
                    ax.set_xlim([0, start])
                    ax.xaxis.set_ticks(xticks)
                    ax.xaxis.set_ticklabels([&#34;&#34;] * len(xticks))
                    if i == (len(panels) - 1):
                        ax.xaxis.set_ticks(xticks_minor, minor=True)
                        ax.xaxis.set_ticklabels(xticks_labels, minor=True)
                    else:
                        plt.setp(ax.get_xticklabels(minor=True), visible=False)
                    ax.grid()
                    ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0])
                    ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
                    ax.set_ylabel(&#34;BAF&#34;)
                    ax.set_ylim([-0.05, 1.05])
                    ax.yaxis.grid()
                    self.fig.add_subplot(ax)

                elif panels[i] == &#34;snv&#34; or panels[i][:4] == &#34;snv:&#34;:
                    callset = &#34;default&#34;
                    if panels[i][:4] == &#34;snv:&#34;:
                        callset = panels[i].split(&#34;:&#34;)[1]
                    start = 0
                    xticks = []
                    xticks_minor = []
                    xticks_labels = []
                    pos_x = []
                    for c, l in chroms:
                        pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c, callset=callset)
                        ix = 0
                        hpos = []
                        color = []
                        alpha = 0.7
                        baf = []
                        while ix &lt; len(pos):
                            if (nref[ix] + nalt[ix]) != 0 and ((not self.snp_use_id) or (flag[ix] &amp; 1)):
                                hpos.append(start + (pos[ix] / bin_size))
                                if gt[ix] % 4 != 2:
                                    baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                                else:
                                    baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                                if self.snp_alpha_P:
                                    alpha = None
                                    color.append(
                                        colors.to_rgba(self.snp_colors[(gt[ix] % 4) * 2 + 1], (flag[ix] &gt;&gt; 1) * 0.4))
                                else:
                                    color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                            ix += 1
                        if self.markersize == &#34;auto&#34;:
                            ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=0.1, alpha=alpha)
                        else:
                            ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=alpha)
                        xticks_minor.append(start + l // bin_size // 2)
                        xticks_labels.append(Genome.canonical_chrom_name(c))
                        start += l // bin_size + 1
                        xticks.append(start)
                    ax.set_xlim([0, start])
                    ax.xaxis.set_ticks(xticks)
                    ax.xaxis.set_ticklabels([&#34;&#34;] * len(xticks))
                    if i == (len(panels) - 1):
                        ax.xaxis.set_ticks(xticks_minor, minor=True)
                        ax.xaxis.set_ticklabels(xticks_labels, minor=True)
                    else:
                        plt.setp(ax.get_xticklabels(minor=True), visible=False)
                    ax.grid()
                    ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0])
                    ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
                    ax.set_ylabel(&#34;BAF&#34;)
                    ax.set_ylim([-0.05, 1.05])
                    ax.yaxis.grid()
                    self.fig.add_subplot(ax)


                elif panels[i] == &#34;likelihood&#34;:
                    start = 0
                    xticks = [0]
                    xticks_minor = []
                    xticks_labels = []
                    gl = []
                    for c, l in chroms:
                        likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
                        lh = list(likelihood)
                        size = l // bin_size + 1
                        if len(lh) &lt; size:
                            if len(lh)&gt;0:
                                lh.extend([lh[-1] for jj in range(size - len(lh))])
                            elif len(gl)&gt;0:
                                lh.extend([gl[-1] for jj in range(size - len(lh))])

                        gl.extend(lh)
                        xticks_minor.append(start + l // bin_size // 2)
                        xticks_labels.append(Genome.canonical_chrom_name(c))
                        start += l // bin_size + 1
                        xticks.append(start)

                    img = np.array(gl).transpose()
                    img[0, :] = 0
                    img[-1, :] = 0
                    ax.imshow(img, aspect=&#39;auto&#39;)
                    ax.yaxis.set_ticks([0, img.shape[0] / 4, img.shape[0] / 2, 3 * img.shape[0] / 4, img.shape[0] - 1],
                                       minor=[])
                    ax.yaxis.set_ticklabels([&#34;1&#34;, &#34;3/4&#34;, &#34;1/2&#34;, &#34;1/4&#34;, &#34;0&#34;])
                    ax.set_ylabel(&#34;BAF&#34;)
                    ax.set_xlim([0, start])
                    ax.xaxis.set_ticks(xticks)
                    ax.xaxis.set_ticklabels([&#34;&#34;] * len(xticks))
                    if i == (len(panels) - 1):
                        ax.xaxis.set_ticks(xticks_minor, minor=True)
                        ax.xaxis.set_ticklabels(xticks_labels, minor=True)
                    else:
                        plt.setp(ax.get_xticklabels(minor=True), visible=False)
                    ax.xaxis.grid()
                    self.fig.add_subplot(ax)

        self.fig_show(suffix=&#34;global&#34;)

    def circular(self):
        chroms = self.chrom
        bin_size = self.bin_size
        n = len(self.plot_files)
        ix = self.plot_files
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0)
        rd_flag = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
        self.new_figure(panel_count=n)
        for i in range(n):
            ax = self.next_polar_panel()
            ax.set_theta_zero_location(&#34;N&#34;)
            ax.set_theta_direction(-1)
            rainbow = ax._get_lines
            io = self.io[ix[i]]
            plot_len = 0
            plot_chroms = []
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                rd_chr = io.rd_chromosome_name(c)
                if rd_chr is not None and (len(chroms) == 0 or (rd_chr in chroms) or (c in chroms)) and (
                        Genome.is_autosome(c) or Genome.is_sex_chrom(c)
                ) and io.signal_exists(rd_chr, bin_size, &#34;SNP maf&#34;, snp_flag) and io.signal_exists(
                    rd_chr, bin_size, &#34;RD&#34;, rd_flag):
                    plot_chroms.append((rd_chr, l))
                    plot_len += l // bin_size + 1
            rd_mean, stdev = io.rd_normal_level(bin_size, rd_flag)
            tl = 0
            dt = 2.0 * np.pi / plot_len
            theta = np.arange(0, 2.0 * np.pi, dt)
            angles = []
            labels = []
            for j in range(len(plot_chroms)):
                c, l = plot_chroms[j]
                next_color = rainbow.get_next_color()
                rd_color = self.rd_circular_colors[j % len(self.rd_circular_colors)]
                snp_color = self.snp_circular_colors[j % len(self.snp_circular_colors)]
                rd = io.get_signal(c, bin_size, &#34;RD&#34;, rd_flag)
                maf = io.get_signal(c, bin_size, &#34;SNP maf&#34;, snp_flag)
                c01 = io.get_signal(c, bin_size, &#34;SNP bin count 0|1&#34;, snp_flag)
                c10 = io.get_signal(c, bin_size, &#34;SNP bin count 1|0&#34;, snp_flag)
                hets = c01 + c10
                np.warnings.filterwarnings(&#39;ignore&#39;)
                maf[hets &lt; (bin_size / 10000)] = 0
                # plt.polar(theta[tl:tl + maf.size], 1 - maf / 2, color=snp_color, linewidth=0.3)
                # plt.fill_between(theta[tl:tl + maf.size], 1 - maf / 2, np.ones_like(maf), color=snp_color, alpha=0.8)
                plt.polar(theta[tl:tl + maf.size], 1 - maf / 2, linewidth=0.3, color=next_color)
                plt.fill_between(theta[tl:tl + maf.size], 1 - maf / 2, np.ones_like(maf), alpha=1, color=next_color)
                markersize = 5
                if self.markersize != &#34;auto&#34;:
                    markersize = self.markersize
                ax.scatter(theta[tl:tl + rd.size], np.ones_like(rd) / 10. + 0.7 * rd / (self.rd_range[1] * rd_mean / 2),
                           s=markersize, alpha=0.7, color=next_color)

                # plt.polar(theta[tl:tl + rd.size], np.ones_like(rd) / 10. + 0.7 * rd / (self.rd_range[1] * rd_mean / 2),
                #          color=rd_color, linewidth=0.3)
                # plt.fill_between(theta[tl:tl + rd.size], np.ones_like(rd) / 10.,
                #                 np.ones_like(rd) / 10. + 0.7 * rd / (self.rd_range[1] * rd_mean / 2),
                #                 color=rd_color,
                #                 alpha=0.8)

                # ax.text(theta[tl + maf.size // 3], 0.8, c, fontsize=8)
                labels.append(Genome.canonical_chrom_name(c))
                angles.append(180 * theta[tl + rd.size // 2] / np.pi)
                tl += l // bin_size + 1
            for cn in range(int(self.rd_range[1])):
                plt.polar(theta, np.ones_like(theta) * (0.1 + 0.7 * (cn / self.rd_range[1])), color=&#34;k&#34;, linewidth=0.1)
            ax.set_rmax(1.0)
            ax.set_rticks([])
            ax.set_thetagrids(angles, labels=labels, fontsize=10, weight=&#34;bold&#34;, color=&#34;black&#34;)
            ax.set_title(self.file_title(ix[i]), loc=&#34;left&#34;, fontsize=10, weight=&#34;bold&#34;, color=&#34;black&#34;)
            ax.grid(False)
        self.fig_show(suffix=&#34;circular&#34;)

    def rd_baf(self, hist=True):
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, figsize=(12, 8), facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        n = len(self.plot_files)
        ix = self.plot_files
        if self.grid == &#34;auto&#34;:
            sx, sy = self._panels_shape(n)
        else:
            sx, sy = tuple(self.grid)
        grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        bin_size = self.bin_size
        for i in range(n):
            ax = self.fig.add_subplot(grid[i])
            io = self.io[ix[i]]

            chroms = []
            snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                FLAG_USEHAP if self.snp_use_phase else 0)
            rd_flag = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = io.snp_chromosome_name(c)
                if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                    if io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood call&#34;, snp_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood segments&#34;, snp_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;RD mosaic call&#34;, rd_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;RD mosaic segments&#34;, rd_flag) and \
                            Genome.is_autosome(c):
                        chroms.append((snp_chr, l))
            x = []
            y = []
            for c, l in chroms:
                flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO

                likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                segments_baf = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
                rd = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;, rd_flag)
                segments_rd = segments_decode(io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;, rd_flag))

                mbaf = {}
                mrd = {}
                for s, lh in zip(segments_baf, likelihood):
                    b, p = likelihood_baf_pval(lh)
                    for pos in s:
                        mbaf[pos] = 0.5 - b
                for s, r in zip(segments_rd, rd[0]):
                    for pos in s:
                        mrd[pos] = r
                for p in mbaf:
                    if p in mrd:
                        x.append(mbaf[p])
                        y.append(mrd[p])

            if hist:
                from matplotlib.colors import LogNorm
                ax.hist2d(x, y, bins=[np.arange(0, 0.51, 0.01), np.arange(0, max(y), max(y) / 100.)], norm=LogNorm())
            else:
                ax.scatter(x, y, marker=&#34;.&#34;, alpha=0.5)

        if self.output_filename != &#34;&#34;:
            plt.savefig(self._image_filename(&#34;rd_baf&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def dispersion(self, legend=True):
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(8)
            self.fig.set_figwidth(12)
        grid = gridspec.GridSpec(1, 2, wspace=0.2, hspace=0.2)

        ax = self.fig.add_subplot(grid[0])
        for i in self.io:
            bin_sizes = sorted(set([int(x[1]) for x in i.chromosomes_bin_sizes_with_signal(&#34;RD&#34;)]))
            rd = []
            drd = []
            for bs in bin_sizes:
                if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO):
                    stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO)
                    rd.append(stat[4])
                    drd.append(stat[5])
            ax.set_yscale(&#34;log&#34;)
            ax.set_xscale(&#34;log&#34;)
            ax.grid(True)
            ax.set_xlabel(&#34;mean RD&#34;)
            ax.set_ylabel(&#34;stdev RD&#34;)
            if legend:
                ax.legend(loc=&#34;upper left&#34;)
            ax.plot(rd, drd, &#34;*-&#34;, label=i.filename)

        ax = self.fig.add_subplot(grid[1])
        for i in self.io:
            bin_sizes = sorted(set([int(x[1]) for x in i.chromosomes_bin_sizes_with_signal(&#34;RD&#34;)]))
            rd = []
            drd = []
            for bs in bin_sizes:
                if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO | FLAG_GC_CORR):
                    stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO | FLAG_GC_CORR)
                    rd.append(stat[4])
                    drd.append(stat[5])
            ax.set_yscale(&#34;log&#34;)
            ax.set_xscale(&#34;log&#34;)
            ax.grid(True)
            ax.set_xlabel(&#34;mean RD (GC corr)&#34;)
            ax.set_ylabel(&#34;stdev RD (GC corr)&#34;)
            if legend:
                ax.legend(loc=&#34;upper left&#34;)
            ax.plot(rd, drd, &#34;*-&#34;, label=i.filename)

        if self.output_filename != &#34;&#34;:
            plt.savefig(self._image_filename(&#34;dispersion&#34;), dpi=200)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def region_rd_stat(self, region, n_bins=21, plot=False, legend=True):
        n = len(self.plot_files)
        ix = self.plot_files
        if plot:
            plt.clf()
            plt.rcParams[&#34;font.size&#34;] = 8
            if self.grid == &#34;auto&#34;:
                sx, sy = self._panels_shape(n)
            else:
                sx, sy = tuple(self.grid)
            self.fig = plt.figure(1, dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
            if self.output_filename != &#34;&#34;:
                self.fig.set_figheight(3 * sy)
                self.fig.set_figwidth(4 * sx)
            grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        for i in range(n):
            io = self.io[ix[i]]
            if plot:
                ax = self.fig.add_subplot(grid[i])
                ax.set_title(self.file_title(ix[i]), position=(0.01, 1.07),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            regs = decode_region(region)
            data = []
            for c, (pos1, pos2) in regs:
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size
                data += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])

            data = np.array(data)
            dmin = np.min(data)
            dmax = np.max(data)
            p1 = np.percentile(data, 1)
            p99 = np.percentile(data, 99)
            data = data[data &gt; p1]
            data = data[data &lt; p99]
            mean = np.mean(data)
            std = np.std(data)

            rd_min = mean - 5 * std
            rd_max = mean + 5 * std
            bins = np.linspace(rd_min, rd_max, n_bins)

            hist, binsr = np.histogram(data, bins=bins)

            fitn, fitm, fits = fit_normal(bins[:-1], hist)[0]

            print(&#34;%s\t%s\t%.4f\t%.4f\t%e\t%e\t%.4f\t%.4f\t%.4f\t%.4f&#34; % (
                io.filename, region, fitm, fits, dmin, dmax, p1, p99, mean, std))

            if plot:
                x = np.linspace(bins[0], bins[-1], 1001)
                plt.plot(x, normal(x, fitn, fitm, fits), &#34;g-&#34;, label=region)
                plt.plot(bins[:-1], hist, &#34;b*&#34;)
                if legend:
                    plt.legend()

        if plot:
            if self.output_filename != &#34;&#34;:
                plt.savefig(self._image_filename(&#34;comp&#34;), dpi=200)
                plt.close(self.fig)
            elif self.interactive:
                plt.show(block=False)
                plt.draw()
            else:
                plt.show()

    def compare(self, region1, region2, n_bins=21, plot=False, stdout=True, legend=True):
        n = len(self.plot_files)
        ix = self.plot_files
        ret = []

        if plot:
            plt.clf()
            plt.rcParams[&#34;font.size&#34;] = 8
            if self.grid == &#34;auto&#34;:
                sx, sy = self._panels_shape(n)
            else:
                sx, sy = tuple(self.grid)
            self.fig = plt.figure(1, dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
            if self.output_filename != &#34;&#34;:
                self.fig.set_figheight(3 * sy)
                self.fig.set_figwidth(4 * sx)
            grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        for i in range(n):
            io = self.io[ix[i]]
            if plot:
                ax = self.fig.add_subplot(grid[i])
                ax.set_title(self.file_title(ix[i]), position=(0.01, 1.07),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            regs1 = decode_region(region1)
            regs2 = decode_region(region2)
            data1 = []
            data2 = []
            for c, (pos1, pos2) in regs1:
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size
                data1 += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])
            for c, (pos1, pos2) in regs2:
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size
                data2 += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])

            data1 = np.array(data1)
            p1_1 = np.percentile(data1, 1)
            p99_1 = np.percentile(data1, 99)
            data1 = data1[data1 &gt; p1_1]
            data1 = data1[data1 &lt; p99_1]
            mean1 = np.mean(data1)
            std1 = np.std(data1)

            data2 = np.array(data2)
            p1_2 = np.percentile(data2, 1)
            p99_2 = np.percentile(data2, 99)
            data2 = data2[data2 &gt; p1_2]
            data2 = data2[data2 &lt; p99_2]
            mean2 = np.mean(data2)
            std2 = np.std(data2)

            rd_min = min(mean1 - 5 * std1, mean2 - 5 * std2)
            rd_max = max(mean1 + 5 * std1, mean2 + 5 * std2)
            bins = np.linspace(rd_min, rd_max, n_bins)

            hist1, binsr = np.histogram(data1, bins=bins)
            hist2, binsr = np.histogram(data2, bins=bins)

            fitn1, fitm1, fits1 = fit_normal(bins[:-1], hist1)[0]
            fitn2, fitm2, fits2 = fit_normal(bins[:-1], hist2)[0]

            pval = t_test_2_samples(fitm1, fits1, sum(hist1), fitm2, fits2, sum(hist2))

            if stdout:
                print(&#34;%s\t%s\t%s\t%.4f\t%.4f\t%.4f\t%.4f\t%e\t%.4f\t%.4f&#34; % (
                    io.filename, region1, region2, fitm1, fits1, fitm2, fits2, pval, fitm1 / fitm2,
                    fitm1 / fitm2 * (fits1 / fitm1 / np.sqrt(sum(hist1)) + fits2 / fitm2 / np.sqrt(sum(hist2)))))
            ret.append([io.filename, region1, region2, fitm1, fits1, fitm2, fits2, pval, fitm1 / fitm2,
                        fitm1 / fitm2 * (fits1 / fitm1 / np.sqrt(sum(hist1)) + fits2 / fitm2 / np.sqrt(sum(hist2)))])

            if plot:
                x = np.linspace(bins[0], bins[-1], 1001)
                plt.plot(x, normal(x, fitn1, fitm1, fits1), &#34;g-&#34;, label=region1)
                plt.plot(x, normal(x, fitn2, fitm2, fits2), &#34;b-&#34;, label=region2)
                plt.plot(bins[:-1], hist1, &#34;g*&#34;)
                plt.plot(bins[:-1], hist2, &#34;b*&#34;)
                if legend:
                    plt.legend()

        if plot:
            if self.output_filename != &#34;&#34;:
                plt.savefig(self._image_filename(&#34;comp&#34;), dpi=200)
                plt.close(self.fig)
            elif self.interactive:
                plt.show(block=False)
                plt.draw()
            else:
                plt.show()

        return ret

    def compare_baf(self, region1, region2, plot=False, stdout=True, legend=True):
        n = len(self.plot_files)
        ix = self.plot_files
        ret = []

        if plot:
            plt.clf()
            plt.rcParams[&#34;font.size&#34;] = 8
            if self.grid == &#34;auto&#34;:
                sx, sy = self._panels_shape(n)
            else:
                sx, sy = tuple(self.grid)
            self.fig = plt.figure(1, dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
            if self.output_filename != &#34;&#34;:
                self.fig.set_figheight(3 * sy)
                self.fig.set_figwidth(4 * sx)
            grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        for i in range(n):
            io = self.io[ix[i]]
            if plot:
                ax = self.fig.add_subplot(grid[i])
                ax.set_title(self.file_title(ix[i]), position=(0.01, 1.07),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            regs1 = decode_region(region1)
            regs2 = decode_region(region2)
            data1 = []
            data2 = []
            for c, (pos1, pos2) in regs1:
                flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;SNP likelihood&#34;, flag)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size
                data1 += list(his_p[bin1:bin2 + 1])
            for c, (pos1, pos2) in regs2:
                flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;SNP likelihood&#34;, flag)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size

                data2 += list(his_p[bin1:bin2 + 1])

            d1 = np.array(data1)
            d2 = np.array(data2)
            h1 = np.ones_like(d1[0])
            h2 = np.ones_like(d2[0])
            for i in range(len(d1)):
                if sum(d1[i]) != 0:
                    h1 *= d1[i]
                h1 /= sum(h1)
            for i in range(len(d2)):
                if sum(d2[i]) != 0:
                    h2 *= d2[i]
                h2 /= sum(h2)

            b1, p1 = likelihood_baf_pval(h1)
            b2, p2 = likelihood_baf_pval(h2)

            if stdout:
                print(&#34;%s\t%s\t%s\t%.4f\t%e\t%.4f\t%e&#34; % (
                    io.filename, region1, region2, b1, p1, b2, p2))
            ret.append([io.filename, region1, region2, b1, p1, b2, p2])

            if plot:
                plt.plot(h1, &#34;g&#34;)
                plt.plot(h2, &#34;b&#34;)

        if plot:
            if self.output_filename != &#34;&#34;:
                plt.savefig(self._image_filename(&#34;comp_baf&#34;), dpi=200)
                plt.close(self.fig)
            elif self.interactive:
                plt.show(block=False)
                plt.draw()
            else:
                plt.show()

        return ret

    def single_cell_allelic_dropout(self, callset=None, res=1000, n_bins=100, threshold=0.1, snp_threshold=0.01,
                                    neigh=False, plot=False, stdout=True, title=None):
        &#34;&#34;&#34;
        Function used to identify regions without allelic dropout in the case of single cell amplification.
        It requires baf data for bin size. It will filter out all bins with at least one SNP bellow snp_threshold and
        all bins with collective maximum baf likelihood bellow threshold parameter.

        Parameters
        ----------
        callset : str or None
            Name of callset if not default.
        res : int
            Resolution in bins used to calculate percentage of dropouts in region.
        n_bins : int
            Number of bins in histograms.
        threshold : float
            Collective threshold of AF for allelic dropout
        snp_threshold : float
            Single SNP threshold of AF for allelic dropout
        neigh : bool
            Remove neighbouring bins also.
        plot : bool
            Make plots.
        stdout : bool
            Print out good regions

        &#34;&#34;&#34;

        if plot:
            self.new_figure(panel_count=2, panel_size=(16, 6), title=title)
            ax = self.next_panel()
            bafG = []
            baf = []
            cpos = 0
            sizeG = []
            sizeB = []
        for c in self.io[self.plot_file].snp_chromosomes():
            if len(self.chrom) == 0 or (c in self.chrom):
                snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                    FLAG_USEHAP if self.snp_use_phase else 0)
                i1 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP i1&#34;, snp_flag)
                pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_file].read_snp(c, callset=callset)
                c00 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP bin count 0|0&#34;, snp_flag)
                c11 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP bin count 1|1&#34;, snp_flag)
                homs = c00 + c11
                c01 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP bin count 0|1&#34;, snp_flag)
                c10 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP bin count 1|0&#34;, snp_flag)
                hets = c01 + c10
                count = c01 + c10 + c00 + c11
                mask = np.zeros_like(i1)
                density = np.zeros(len(mask) // res)
                # mask[hets == 0] = 1
                mask[hets == 0] = 2
                mask[i1 &gt; (0.5 - threshold)] = 1
                for ix in range(len(pos)):
                    if (nref[ix] + nalt[ix]) != 0 and ((gt[ix] % 4) in [1, 2]):
                        b = 1.0 * nalt[ix] / (nref[ix] + nalt[ix])
                        if (b &lt; snp_threshold) or (b &gt; (1 - snp_threshold)):
                            mask[(pos[ix] - 1) // self.bin_size] = 1

                if neigh:
                    ada = mask == 1
                    ada1 = np.roll(ada, 1)
                    ada2 = np.roll(ada, -1)
                    ada1[0] = False
                    ada2[-1] = False
                    mask[ada1] = 1
                    mask[ada2] = 1
                ix = 0
                while ix &lt; len(mask):
                    if mask[ix] == 2:
                        adan = 0
                        if ix &gt; 0 and mask[ix - 1] == 1:
                            adan = 1
                        jx = ix
                        while jx &lt; len(mask) and mask[jx] == 2:
                            jx += 1
                        if jx &lt; len(mask) and mask[jx] == 1:
                            adan = 1
                        mask[ix:jx] = adan
                        ix = jx
                    else:
                        ix += 1
                ix = 0
                ojx = 0
                while ix &lt; len(mask):
                    if mask[ix] == 0:
                        jx = ix
                        while jx &lt; len(mask) and mask[jx] == 0:
                            jx += 1
                        if stdout:
                            print(&#34;%s\t%d\t%d&#34; % (c, ix * self.bin_size + 1, jx * self.bin_size))
                        sizeG.append((jx - ix) * self.bin_size)
                        if ix &gt; ojx:
                            sizeB.append((ix - ojx) * self.bin_size)
                        ojx = jx
                        ix = jx
                    else:
                        ix += 1
                if plot:
                    for ix in range(len(density)):
                        density[ix] = np.mean(mask[res * ix:res * (ix + 1)])
                    ax.plot(np.arange(cpos, cpos + len(density)) * res, density)
                    cpos += len(density)
                    for ix in range(len(pos)):
                        if (nref[ix] + nalt[ix]) != 0 and ((gt[ix] % 4) in [1, 2]):
                            baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            if mask[(pos[ix] - 1) // self.bin_size] == 0:
                                bafG.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
        ax.set_xlabel(&#34;Position in genome [bins]&#34;)
        ax.set_ylabel(&#34;Percentage of allelic dropout&#34;)
        ax.grid(True)
        if plot:
            self.new_subgrid(2, grid=&#34;horizontal&#34;, hspace=0.05, wspace=0.2)
            ax = self.next_subpanel()
            ms = 5 * max(np.mean(sizeG), np.mean(sizeB))
            ax.hist(sizeB, bins=np.arange(1, ms, self.bin_size), histtype=&#34;step&#34;, log=True,
                    label=&#34;Allelic dropout regions&#34;, linewidth=3)
            ax.hist(sizeG, bins=np.arange(1, ms, self.bin_size), histtype=&#34;step&#34;, log=True,
                    label=&#34;Region with both alleles&#34;, linewidth=3)
            ax.legend()
            ax.grid(True)
            ax.set_xlabel(&#34;Size [bp]&#34;)
            ax.set_ylabel(&#34;Number of regions&#34;)
            self.fig.add_subplot(ax)

            ax = self.next_subpanel()
            ax.hist(baf, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)),
                    label=&#34;All heterozygous variants&#34;)
            ax.hist(bafG, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)),
                    label=&#34;Region with both alleles&#34;)
            ax.legend()
            ax.grid(True)
            ax.set_xlabel(&#34;VAF&#34;)
            ax.set_ylabel(&#34;Distribution&#34;)
            self.fig.add_subplot(ax)

            self.fig_show(suffix=&#34;allelic_dropout&#34;)

    def compare_rd_dist(self, regions):
        self.new_figure(panel_count=1)
        ax = self.next_panel()
        ax.set_ylabel(&#34;Normalised distribution&#34;)
        ax.set_xlabel(&#34;Difference in copy number&#34;)
        regs = decode_region(regions)
        io1 = self.io[self.plot_files[0]]
        io2 = self.io[self.plot_files[1]]
        bin_size = self.bin_size
        drd = []
        for c, (pos1, pos2) in regs:
            flag_rd = 0
            if self.rd_use_mask:
                flag_rd = FLAG_USEMASK
            mean1, stdev = io1.rd_normal_level(bin_size, flag_rd | FLAG_GC_CORR)
            mean2, stdev = io2.rd_normal_level(bin_size, flag_rd | FLAG_GC_CORR)
            his_p_corr1 = io1.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            his_p_corr2 = io2.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            for i in range(len(his_p_corr1)):
                drd.append(his_p_corr1[i] * 2 / mean1 - his_p_corr2[i] * 2 / mean2)

        # for i in range(n):
        #     io = self.io[ix[i]]
        #     stat = self.io[self.plot_file].get_signal(None, self.bin_size, &#34;RD stat&#34;, FLAG_AUTO)
        #     his_p = io.get_signal(None, self.bin_size, &#34;RD p dist&#34;, FLAG_AUTO)
        #     bin_size = int(stat[1])
        #     max_rd = int(stat[0])
        #     lim_rd = int(max(2 * stat[4], stat[4] + 3 * stat[5]))
        #     ax.set_xlim([0, lim_rd])
        #     bins = range(0, 2*max_rd + 5*bin_size, bin_size)
        #     x = np.arange(0, max_rd // bin_size * bin_size, 0.1 * bin_size)
        #     #plt.plot(x, normal(x, 1, stat[4], stat[5]), &#34;g-&#34;)
        #     x = np.array(bins)
        #     plt.plot(x[1:len(his_p)], his_p[1:] / stat[3],label = io.filename)
        ax.hist(drd, bins=np.linspace(-0.5, 0.5, 100))
        # ax.legend()
        ax.set_yticklabels([])
        ax.grid()
        self.fig_show(suffix=&#34;compare_rd&#34;)

    def snp_dist(self, regions, callset=None, n_bins=100, gt_plot=[0, 1, 2, 3], titles=None, beta_distribution=False,
                 log_scale=False):
        nf = len(self.plot_files)
        regions = regions.split(&#34; &#34;)
        nr = len(regions)
        n = nf * nr
        self.new_figure(panel_count=n)
        for ii in range(nf):
            for i in range(nr):
                ax = self.next_panel()
                if titles is None:
                    ax.set_title(self.file_title(self.plot_files[ii]) + &#34;: &#34; + regions[i], position=(0.01, 1.10),
                                 fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
                else:
                    ax.set_title(titles[i], position=(0.01, 1.10),
                                 fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
                regs = decode_region(regions[i])
                baf = []
                bafP = []
                bafNP = []
                mean_rd = 0
                for c, (pos1, pos2) in regs:
                    pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_files[ii]].read_snp(c,
                                                                                                      callset=callset)
                    ix = 0
                    while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                        if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0 and ((gt[ix] % 4) in gt_plot):
                            if gt[ix] % 4 != 2:
                                baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                                if flag[ix] &amp; 2:
                                    bafP.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                                    mean_rd += nref[ix] + nalt[ix]
                                else:
                                    bafNP.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            else:
                                baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                                if flag[ix] &amp; 2:
                                    bafP.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                                    mean_rd += nref[ix] + nalt[ix]
                                else:
                                    bafNP.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                        ix += 1
                mean_rd /= len(bafP)
                x_bins = np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1))
                ax.hist(baf, bins=x_bins, label=&#34;All heterozygous variants&#34;)
                ax.hist(bafP, bins=x_bins, label=&#34;P bases only&#34;)
                # ax.hist(bafNP, bins=x_bins, label=&#34;non-P bases only&#34;, histtype=u&#39;step&#39;)
                if log_scale:
                    plt.yscale(&#39;log&#39;, nonposy=&#39;clip&#39;)

                if beta_distribution:
                    xx = np.linspace(0.2, 0.8, 200)
                    ax.plot(xx, beta.pdf(xx, mean_rd / 2, mean_rd / 2) * len(bafP) / n_bins, c=&#34;black&#34;,
                            label=&#34;Beta distribution&#34;)
                ax.legend(bbox_to_anchor=(0, 1.02, 1, 0.2), loc=&#34;lower left&#34;, mode=&#34;expand&#34;, borderaxespad=0, ncol=3)
                ax.set_xlabel(&#34;VAF&#34;)
                ax.set_ylabel(&#34;Distribution&#34;)

        self.fig_show(suffix=&#34;snp_dist&#34;)

    def phased_baf(self, regions, callset=None, print=False):
        regions = regions.split(&#34; &#34;)
        n = len(regions)
        ret = []
        for i in range(n):
            regs = decode_region(regions[i])
            talt = 0
            tref = 0
            taltP = 0
            trefP = 0
            for c, (pos1, pos2) in regs:
                pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_file].read_snp(c, callset=callset)
                ix = 0
                while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                    if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0:
                        if gt[ix] == 5:
                            talt += nalt[ix]
                            tref += nref[ix]
                            if flag[ix] &amp; 2:
                                taltP += nalt[ix]
                                trefP += nref[ix]
                        elif gt[ix] == 6:
                            tref += nalt[ix]
                            talt += nref[ix]
                            if flag[ix] &amp; 2:
                                trefP += nalt[ix]
                                taltP += nref[ix]
                    ix += 1
            baf = talt / (tref + talt)
            bafP = taltP / (trefP + taltP)
            ret.append([baf, bafP])
            if print:
                print(&#34;%s\t%f\t%f&#34; % (regions[i], baf, bafP))
        return ret

    def snp_compare(self, regions, ix1, ix2, callset=None, n_bins=100, titles=None, test_loh=False):
        regions = regions.split(&#34; &#34;)
        n = len(regions)
        self.new_figure(panel_count=n)
        for i in range(n):
            ax = self.next_panel()
            if titles is None:
                ax.set_title(regions[i], position=(0.01, 1.07),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            else:
                ax.set_title(titles[i], position=(0.01, 1.07),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            regs = decode_region(regions[i])
            oval = []
            for c, (pos_start, pos_end) in regs:
                pos1, ref1, alt1, nref1, nalt1, gt1, flag1, qual1 = self.io[ix1].read_snp(c, callset=callset)
                pos2, ref2, alt2, nref2, nalt2, gt2, flag2, qual2 = self.io[ix2].read_snp(c, callset=callset)

                counts1 = {}
                counts2 = {}
                ix = 0
                while ix &lt; len(pos1) and pos1[ix] &lt;= pos_end:
                    if pos1[ix] &gt;= pos_start and (nref1[ix] + nalt1[ix]) != 0:
                        counts1[pos1[ix]] = (nref1[ix] / np.sqrt(nref1[ix] ** 2 + nalt1[ix] ** 2),
                                             nalt1[ix] / np.sqrt(nref1[ix] ** 2 + nalt1[ix] ** 2))
                    ix += 1
                ix = 0
                xx = []
                yy = []
                cc = []
                hist1 = []
                hist2 = []
                while ix &lt; len(pos2) and pos2[ix] &lt;= pos_end:
                    if pos2[ix] &gt;= pos_start and (nref2[ix] + nalt2[ix]) != 0:
                        counts2[pos2[ix]] = (nref2[ix], nalt2[ix])
                    ix += 1
                for p in counts1:
                    if p in counts2:
                        xx.append(p)
                        yy.append(counts1[p][1] / (counts1[p][0] + counts1[p][1]))
                        cc.append(&#34;green&#34;)
                        xx.append(p)
                        yy.append(counts2[p][1] / (counts2[p][0] + counts2[p][1]))
                        cc.append(&#34;blue&#34;)
                        if counts2[p][1] / (counts2[p][0] + counts2[p][1]) &gt; 0.8:
                            t = counts1[p][1] / (counts1[p][0] + counts1[p][1])
                            if t &gt; 0.2 and t &lt; 0.8:
                                hist1.append(t)
                        else:
                            t = counts1[p][1] / (counts1[p][0] + counts1[p][1])
                            if t &gt; 0.2 and t &lt; 0.8:
                                hist2.append(t)
                    else:
                        xx.append(p)
                        yy.append(counts1[p][1] / (counts1[p][0] + counts1[p][1]))
                        cc.append(&#34;red&#34;)
                        t = counts1[p][1] / (counts1[p][0] + counts1[p][1])
                        if t &gt; 0.2 and t &lt; 0.8:
                            hist2.append(t)
                for p in counts2:
                    if not (p in counts1):
                        xx.append(p)
                        yy.append(counts2[p][1] / (counts2[p][0] + counts2[p][1]))
                        cc.append(&#34;orange&#34;)

            if test_loh:
                ax.hist(hist1, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)), histtype=&#39;step&#39;)
                ax.hist(hist2, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)), histtype=&#39;step&#39;)
                print(&#34;H1:&#34;, np.mean(hist1), np.std(hist1), len(hist1))
                print(&#34;H2:&#34;, np.mean(hist2), np.std(hist2), len(hist2))
                ax.set_xlabel(&#34;baf&#34;)
                ax.set_ylabel(&#34;distribnution&#34;)
            else:
                ax.scatter(xx, yy, marker=&#34;.&#34;, s=0.1, c=cc)
                # ax.hist(oval, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)))
                ax.set_xlabel(&#34;position&#34;)
                ax.set_ylabel(&#34;baf&#34;)

        self.fig_show(suffix=&#34;snp_dist&#34;)

    def denovo_calls(self, sample, reference, call_type=&#34;mosaic&#34;):
        bin_size = self.bin_size
        io = self.io[sample]
        if call_type == &#34;mosaic&#34;:
            chroms = io.rd_chromosomes()
            for c in chroms:
                if (c in self.chrom) or len(self.chrom) == 0:
                    flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                    if io.signal_exists(c, bin_size, &#34;calls&#34;, flag):
                        calls = io.read_calls(c, bin_size, &#34;calls&#34;, flag)
                        for call in calls:
                            if in_interval(call[&#34;size&#34;], self.size_range) \
                                    and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                    and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                    and in_interval(call[&#34;Q0&#34;], self.Q0_range):
                                type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;
                                region = &#34;%s:%d-%d&#34; % (c, call[&#34;start&#34;], call[&#34;end&#34;])

                                cn0 = self.genotype([bin_size], region, file_index=sample)[0][3]
                                cref = list(
                                    map(lambda x: self.genotype([bin_size], region, file_index=x)[0][3], reference))
                                if (((sum(map(lambda x: 0 if (cn0 - x) &gt; 0.5 else 1, cref)) == 0) and cn0 &gt; 2.5) \
                                    or ((sum(map(lambda x: 0 if (x - cn0) &gt; 0.5 else 1, cref)) == 0) and cn0 &lt; 1.5)) \
                                        and (sum(map(lambda x: 0 if np.abs(x - 2.) &lt; 0.5 else 1, cref)) == 0):
                                    print(type, region, call[&#34;cnv&#34;], cn0, cref)

                                # if n &gt; 1:
                                #     print(&#34;%s\t&#34; % self.file_title(i), end=&#34;&#34;)
                                # print(&#34;%s\t%s:%d-%d\t%d\t%.4f\t%e\t%e\t%e\t%e\t%.4f\t%.4f\t&#34; % (
                                #     type, c, call[&#34;start&#34;], call[&#34;end&#34;], call[&#34;size&#34;], call[&#34;cnv&#34;], call[&#34;p_val&#34;],
                                #     call[&#34;p_val_2&#34;], call[&#34;p_val_3&#34;], call[&#34;p_val_4&#34;], call[&#34;Q0&#34;], call[&#34;pN&#34;]))

    def genotype(self, bin_sizes, region, p_val=False, interactive=False, file_index=None):
        if file_index is None:
            file_index = self.plot_file
        ret = []
        regs = decode_region(region, max_size=1000000000)
        for c, (pos1, pos2) in regs:
            chr_len = self.io[file_index].get_chromosome_length(c)
            if chr_len is not None and pos2 == 1000000000:
                pos2 = chr_len
            if interactive:
                print(c + &#34;:&#34; + str(pos1) + &#34;-&#34; + str(pos2), end=&#34;&#34;)
            ret.append([c, pos1, pos2])
            for bs in bin_sizes:
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                stat = self.io[file_index].get_signal(c, bs, &#34;RD stat&#34;, flag_rd | FLAG_AUTO)
                if stat is None or len(stat) == 0:
                    stat = self.io[file_index].get_signal(c, bs, &#34;RD stat&#34;, flag_rd | FLAG_SEX)
                his_p = self.io[file_index].get_signal(c, bs, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // bs
                bin2 = (pos2 - 1) // bs
                rc = 0
                rc2 = 0
                if bin1 == bin2:
                    try:
                        rc = (pos2 - pos1 + 1) * his_p[bin1] / bs
                        rc2 = (pos2 - pos1 + 1) * his_p[bin1] * his_p[bin1] / bs
                    except IndexError:
                        pass
                else:
                    try:
                        rc += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] / bs
                        rc += (pos2 - bin2 * bs) * his_p[bin2] / bs
                        rc2 += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] * his_p[bin1] / bs
                        rc2 += (pos2 - bin2 * bs) * his_p[bin2] * his_p[bin2] / bs
                    except IndexError:
                        pass
                    for ix in range(bin1 + 1, bin2):
                        try:
                            rc += his_p[ix]
                            rc2 += his_p[ix] * his_p[ix]
                        except IndexError:
                            pass
                e2 = 0
                if p_val:
                    e1 = getEValue(stat[4], stat[5], his_p, bin1, bin2 + 1) * 2.9e9 / bs
                    e2 = gaussianEValue(stat[4], stat[5], his_p, bin1, bin2 + 1) * 2.9e9
                if interactive:
                    print(&#34;\t%f&#34; % (2. * rc / (stat[4] * (pos2 - pos1 + 1) / bs)), end=&#34;&#34;)
                    if p_val:
                        print(&#34;\t%e\t%e&#34; % (e1, e2), end=&#34;&#34;)

                ret[-1].append(2. * rc / (stat[4] * (pos2 - pos1 + 1) / bs))
                if p_val:
                    ret[-1].append(e2)
            if interactive:
                print()

        return ret

    def genotype_all(self, bin_sizes, regions, interactive=False, file_index=None):
        if file_index is None:
            file_index = self.plot_file
        rd_gc_chromosomes = {}
        for c in self.io_gc.gc_chromosomes():
            rd_name = self.io[file_index].rd_chromosome_name(c)
            if not rd_name is None:
                rd_gc_chromosomes[rd_name] = c
        ret = {}
        for bs in bin_sizes:
            oc = &#34;&#34;
            ret[bs] = []
            for region in regions:
                regs = decode_region(region, max_size=1000000000)
                c, (pos1, pos2) = regs[0]
                if oc != c:
                    chr_len = self.io[file_index].get_chromosome_length(c)
                    if chr_len is not None and pos2 == 1000000000:
                        pos2 = chr_len
                    flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                    stat = self.io[file_index].get_signal(c, bs, &#34;RD stat&#34;, flag_rd | FLAG_AUTO)
                    if stat is None or len(stat) == 0:
                        stat = self.io[file_index].get_signal(c, bs, &#34;RD stat&#34;, flag_rd | FLAG_SEX)
                    his_p = self.io[file_index].get_signal(c, bs, &#34;RD&#34;, flag_rd)
                    qrd_p = self.io[file_index].get_signal(c, bs, &#34;RD&#34;)
                    qrd_u = self.io[file_index].get_signal(c, bs, &#34;RD unique&#34;)
                    gc, at, distN = False, False, False
                    if c in rd_gc_chromosomes and self.io_gc.signal_exists(rd_gc_chromosomes[c], None, &#34;GC/AT&#34;):
                        gcat = self.io_gc.get_signal(rd_gc_chromosomes[c], None, &#34;GC/AT&#34;)
                        gc, at = gc_at_decompress(gcat)
                        NN = 100 - np.array(gc) - np.array(at)
                        distN = np.zeros_like(NN, dtype=&#34;long&#34;) - 1
                        distN[NN == 100] = 0
                        prev = 0
                        for Ni in range(0, distN.size):
                            if distN[Ni] == -1:
                                prev += 100
                                distN[Ni] = prev
                            else:
                                prev = 0
                        prev = 0
                        for Ni in range(distN.size - 1, -1, -1):
                            if distN[Ni] &gt; 0:
                                prev += 100
                                if prev &lt; distN[Ni]:
                                    distN[Ni] = prev
                            else:
                                prev = 0
                    snp = c in self.io[file_index].snp_chromosomes()
                    snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                        FLAG_USEHAP if self.snp_use_phase else 0)
                    if snp:
                        snp_likelihood = list(
                            self.io[file_index].get_signal(c, bs, &#34;SNP likelihood&#34;, snp_flag).astype(&#34;float64&#34;))
                        snp_hets = self.io[file_index].get_signal(c, bs, &#34;SNP bin count 0|1&#34;, snp_flag)
                        snp_hets += self.io[file_index].get_signal(c, bs, &#34;SNP bin count 1|0&#34;, snp_flag)
                        snp_homs = self.io[file_index].get_signal(c, bs, &#34;SNP bin count 1|1&#34;, snp_flag)
                else:
                    if chr_len is not None and pos2 == 1000000000:
                        pos2 = chr_len
                oc = c
                ret[bs].append([c, pos1, pos2])

                bin1 = (pos1 - 1) // bs
                bin2 = (pos2 - 1) // bs
                rc = 0
                rc2 = 0
                sp = 0
                su = 0
                nansize = 0
                if bin1 == bin2:
                    try:
                        if not np.isnan(his_p[bin1]):
                            rc = (pos2 - pos1 + 1) * his_p[bin1] / bs
                            rc2 = (pos2 - pos1 + 1) * his_p[bin1] * his_p[bin1] / bs
                            sp = (pos2 - pos1 + 1) * qrd_p[bin1] / bs
                            su = (pos2 - pos1 + 1) * qrd_u[bin1] / bs
                            nansize = (pos2 - pos1 + 1)
                    except IndexError:
                        pass
                else:
                    try:
                        if not np.isnan(his_p[bin1]):
                            rc += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] / bs
                            rc2 += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] * his_p[bin1] / bs
                            sp += (bin1 * bs - pos1 + 1 + bs) * qrd_p[bin1] / bs
                            su += (bin1 * bs - pos1 + 1 + bs) * qrd_u[bin1] / bs
                            nansize += (bin1 * bs - pos1 + 1 + bs)
                        if not np.isnan(his_p[bin2]):
                            rc += (pos2 - bin2 * bs) * his_p[bin2] / bs
                            rc2 += (pos2 - bin2 * bs) * his_p[bin2] * his_p[bin2] / bs
                            sp += (pos2 - bin2 * bs) * qrd_p[bin2] / bs
                            su += (pos2 - bin2 * bs) * qrd_u[bin2] / bs
                            nansize += (pos2 - bin2 * bs)

                    except IndexError:
                        pass
                    for ix in range(bin1 + 1, bin2):
                        try:
                            if not np.isnan(his_p[ix]):
                                rc += his_p[ix]
                                rc2 += his_p[ix] * his_p[ix]
                                sp += qrd_p[ix]
                                su += qrd_u[ix]
                                nansize += bs
                        except IndexError:
                            pass
                if gc:
                    sbin1 = (pos1 - 1) // 100
                    sbin2 = (pos2 - 1) // 100
                    pN = 0
                    if bin1 == bin2:
                        try:
                            pN = (pos2 - pos1 + 1) * (gc[sbin1] + at[sbin1]) / 100
                        except IndexError:
                            pass
                    else:
                        try:
                            pN += (sbin1 * 100 - pos1 + 101) * (gc[sbin1] + at[sbin1]) / 100
                            pN += (pos2 - sbin2 * 100) * (gc[sbin2] + at[sbin2]) / 100

                        except IndexError:
                            pass
                        for ix in range(sbin1 + 1, sbin2):
                            try:
                                pN += gc[ix] + at[ix]
                            except IndexError:
                                pass

                e1 = getEValue(stat[4], stat[5], his_p, bin1, bin2 + 1) * 2.9e9 / bs
                e2 = gaussianEValue(stat[4], stat[5], his_p, bin1, bin2 + 1) * 2.9e9
                dG = -1
                if gc:
                    pN = 1 - pN / (pos2 - pos1 + 1)
                    dG = np.min(distN[sbin1:sbin2])
                else:
                    pN = -1
                    dG = -1
                if nansize == 0:
                    rc = np.nan
                else:
                    rc = 2 * rc / (stat[4] * nansize / bs)
                ret[bs][-1].append(rc)
                ret[bs][-1].append(e1)
                ret[bs][-1].append(e2)
                q0 = 0
                if sp != 0:
                    q0 = (sp - su) / sp
                ret[bs][-1].append(q0)
                ret[bs][-1].append(pN)
                ret[bs][-1].append(dG)
                ret[bs][-1].append(nansize / (pos2 - pos1 + 1))
                if snp:
                    homs = np.sum(snp_homs[bin1:bin2 + 1])
                    hets = np.sum(snp_hets[bin1:bin2 + 1])
                    lh = np.ones_like(snp_likelihood[0])
                    for ix in range(bin1, min(bin2 + 1, len(snp_likelihood))):
                        lh *= snp_likelihood[ix]
                        lh /= np.sum(lh)
                    baf, baf_p = likelihood_baf_pval(lh)
                    ret[bs][-1] += [homs, hets, baf, baf_p]
                else:
                    ret[bs][-1] += [0, 0, 0, 1]
        if interactive:
            plist = []
            for bs in bin_sizes:
                if len(plist) == 0:
                    plist = ret[bs]
                else:
                    for ix in range(len(ret[bs])):
                        plist[ix] += ret[bs][ix][3:]
            for r in plist:
                print(
                    (&#34;%s:%d-%d&#34; + (len(bin_sizes) * &#34;\t%.4f\t%e\t%e\t%.4f\t%.4f\t%d\t%.4f\t%d\t%d\t%.4f\t%e&#34;)) % tuple(
                        r))
        return ret

    def genotype_prompt(self, bin_sizes=[], all=False):
        done = False
        while not done:
            try:
                try:
                    line = raw_input(&#34;&#34;)
                except NameError:
                    line = input(&#34;&#34;)
            except EOFError:
                return
            if line is None or line == &#34;&#34;:
                done = True
            else:
                if all:
                    self.genotype_all(bin_sizes, [line], interactive=True)
                else:
                    self.genotype(bin_sizes, line, interactive=True)

    def rd_baf_call_models(self, maxcn=10):
        bin_size = self.bin_size
        n = len(self.plot_files)
        ix = self.plot_files
        self.new_figure(panel_count=n)

        for i in range(n):
            ax = self.next_panel()
            io = self.io[ix[i]]
            ax.set_title(self.file_title(ix[i]), position=(0.1, 0.1),
                         fontdict={&#39;verticalalignment&#39;: &#39;bottom&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})

            chroms = []
            flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                FLAG_USEHAP if self.snp_use_phase else 0) | (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR

            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = io.snp_chromosome_name(c)
                if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                    if (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append((snp_chr, l))

            x = np.linspace(0, 1, 1000)
            master_lh = {}
            for cn in range(maxcn, -1, -1):
                for h1 in range(cn // 2 + 1):
                    h2 = cn - h1
                    mrd = 2 - 2 * x + x * cn
                    np.seterr(divide=&#39;ignore&#39;)
                    mbaf = 0.5 - (1 - x + x * h1) / (2 - 2 * x + (h1 + h2) * x)
                    plt.plot(mbaf, mrd, &#34;-&#34;, label=&#34;%d: %d/%d&#34; % (cn, h1, h2), zorder=6 - cn)

            cix = 0
            cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
            for c, l in chroms:
                call_rd = []
                call_baf = []
                call_label = []
                if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                    calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)

                    for call in calls:
                        if call[&#34;bins&#34;] &gt; self.min_segment_size:
                            call_rd.append(call[&#34;cnv&#34;] * 2)
                            call_baf.append(call[&#34;baf&#34;])
                            call_label.append(c + &#34;:&#34; + str(call[&#34;start&#34;]) + &#34;-&#34; + str(call[&#34;end&#34;]))

                plt.scatter(call_baf, call_rd, s=20, edgecolors=&#39;face&#39;, marker=&#39;.&#39;)
                cix += 1

            ax.set_xlabel(&#34;|Î”BAF|&#34;)
            ax.set_ylabel(&#34;Relative RD level&#34;)

            ax.legend()

            ax.set_ylim([0, maxcn])
            ax.set_xlim([-0.02, 0.5])
            ax.grid()

        self.fig_show(suffix=&#34;models&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cnvpytor.viewer.Show" href="#cnvpytor.viewer.Show">Show</a></li>
<li><a title="cnvpytor.viewer.Reader" href="#cnvpytor.viewer.Reader">Reader</a></li>
<li><a title="cnvpytor.viewer.Figure" href="#cnvpytor.viewer.Figure">Figure</a></li>
<li><a title="cnvpytor.viewparams.ViewParams" href="viewparams.html#cnvpytor.viewparams.ViewParams">ViewParams</a></li>
<li><a title="cnvpytor.viewparams.HelpDescription" href="viewparams.html#cnvpytor.viewparams.HelpDescription">HelpDescription</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cnvpytor.viewer.Viewer.set_style"><code class="name flex">
<span>def <span class="ident">set_style</span></span>(<span>style)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def set_style(style):
    if style in plt.style.available:
        plt.style.use(&#34;default&#34;)
        plt.style.use(style)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cnvpytor.viewer.Viewer.baf"><code class="name flex">
<span>def <span class="ident">baf</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def baf(self):
    if self.reference_genome is None:
        _logger.warning(&#34;Missing reference genome required for gview.&#34;)
        return
    snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
        FLAG_USEHAP if self.snp_use_phase else 0)
    chroms = []
    for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
        snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
        if self.io[self.plot_file].signal_exists(snp_chr, self.bin_size, &#34;SNP baf&#34;, snp_flag) and \
                self.io[self.plot_file].signal_exists(snp_chr, self.bin_size, &#34;SNP maf&#34;, snp_flag) and \
                self.io[self.plot_file].signal_exists(snp_chr, self.bin_size, &#34;SNP i1&#34;, snp_flag) and \
                self.io[self.plot_file].signal_exists(snp_chr, self.bin_size, &#34;SNP i2&#34;, snp_flag) and \
                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
            chroms.append((snp_chr, l))

    self.new_figure(panel_count=len(chroms))
    for c, l in chroms:
        baf = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP baf&#34;, snp_flag)
        maf = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP maf&#34;, snp_flag)
        i1 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP i1&#34;, snp_flag)
        i2 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP i2&#34;, snp_flag)

        ax = self.next_panel()
        ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                     color=&#39;C0&#39;)
        ax.xaxis.set_ticklabels([])
        ax.yaxis.set_ticklabels([])
        ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
        ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // self.bin_size, 10e6 // self.bin_size), minor=[])
        ax.set_ylim([0, 1])
        n_bins = l // self.bin_size
        ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
        ax.grid()
        ax.step(baf, self.baf_colors[0])
        ax.step(maf, self.baf_colors[1])
        ax.step(i1, self.baf_colors[2])
    self.fig_show(suffix=&#34;baf&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.callmap"><code class="name flex">
<span>def <span class="ident">callmap</span></span>(<span>self, color='frequency', background='white', pixel_size=1700000, max_p_val=1e-20, min_freq=0.01, plot='cmap')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def callmap(self, color=&#34;frequency&#34;, background=&#34;white&#34;, pixel_size=1700000, max_p_val=1e-20, min_freq=0.01,
            plot=&#34;cmap&#34;):
    bin_size = self.bin_size
    if self.reference_genome is None:
        _logger.warning(&#34;Missing reference genome required for callmap.&#34;)
        return
    n = len(self.plot_files)
    ix = self.plot_files

    if plot:
        self.new_figure(panel_count=n, grid=(1, 1), panel_size=(24, 0.24 * n))

    chroms = []
    starts = []
    ends = []
    pixels = 0
    for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
        if l &gt; 10 * bin_size:
            if len(self.chrom) == 0 or (c in self.chrom) or (self.io[0].snp_chromosome_name(c) in self.chrom):
                chroms.append(c)
                starts.append(pixels)
                pixels += l // pixel_size + 1
                ends.append(pixels - 1)

    cmap = np.zeros((n, pixels, 3))
    cmap[:, ends, :] = 1

    for i in range(n):
        io = self.io[ix[i]]
        print(io.filename)
        flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0) | (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
        flag_rd = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
        for c, start in zip(chroms, starts):
            snp_chr = io.snp_chromosome_name(c)
            if io.signal_exists(snp_chr, bin_size, &#34;calls combined&#34;, flag):

                calls = io.read_calls(snp_chr, bin_size, &#34;calls combined&#34;, flag)
                segments = io.get_signal(snp_chr, bin_size, &#34;RD mosaic segments 2d&#34;, flag_rd)
                segments = segments_decode(segments)

                for call in calls:
                    if call[&#34;bins&#34;] &gt; self.min_segment_size and call[&#34;p_val&#34;] &lt; max_p_val and &#34;segment&#34; in call and \
                            call[&#34;models&#34;][0][4] &gt; min_freq:
                        cix = int(call[&#34;type&#34;]) + 1
                        for b in segments[int(call[&#34;segment&#34;])]:
                            if color == &#34;frequency&#34;:
                                cmap[i, start + b * bin_size // pixel_size, cix] = max(
                                    cmap[i, start + b * bin_size // pixel_size, cix], call[&#34;models&#34;][0][4])
                            elif color == &#34;coverage&#34;:
                                cmap[i, start + b * bin_size // pixel_size, cix] += bin_size / pixel_size
                            else:  # model copy number
                                if call[&#34;models&#34;][0][0] == 0:
                                    cmap[i, start + b * bin_size // pixel_size, 0] = 1
                                elif call[&#34;models&#34;][0][0] == 1:
                                    cmap[i, start + b * bin_size // pixel_size, 0] = 1
                                    cmap[i, start + b * bin_size // pixel_size, 1] = 1
                                elif call[&#34;models&#34;][0][0] == 2:
                                    cmap[i, start + b * bin_size // pixel_size, 2] = 1
                                else:
                                    cn = call[&#34;models&#34;][0][0]
                                    if cn &gt; 6:
                                        cn = 6
                                    cmap[i, start + b * bin_size // pixel_size, 1] = (2 + cn) / 8

    def b2w(pixel):
        if np.all(pixel == 1):
            pixel[:] = 0
        elif pixel[0] &gt; pixel[1] and pixel[0] &gt; pixel[2]:
            pixel[1] = pixel[2] = 1 - pixel[0]
            pixel[0] = 1
        elif pixel[1] &gt; pixel[2]:
            pixel[0] = pixel[2] = 1 - pixel[1]
            pixel[1] = 1
        else:
            pixel[0] = pixel[1] = 1 - pixel[2]
            pixel[2] = 1
        return pixel

    if background == &#34;white&#34;:
        cmap = cmap.reshape(n * pixels, 3)
        np.apply_along_axis(b2w, 1, cmap)
        cmap = cmap.reshape(n, pixels, 3)

    cmap = (255 * cmap).astype(&#34;int&#34;)
    if plot == &#34;cmap&#34;:
        self.new_figure(panel_count=1, grid=(1, 1), panel_size=(24, 0.24 * n))
        ax = self.next_panel()
        plt.imshow(cmap, aspect=&#39;auto&#39;)
        for i in ends[:-1]:
            plt.axvline(x=i - 0.5, color=&#39;red&#39;, linewidth=0.5)
        ax.set_yticks([])
        ax.set_yticklabels([])
        ax.set_xticks((np.array(starts) + np.array(ends)) / 2)
        chroms = list(map(Genome.canonical_chrom_name, chroms))
        ax.set_xticklabels(chroms)
        self.fig_show(suffix=&#34;callmap&#34;)
    elif plot == &#34;regions&#34;:
        self.new_figure(panel_count=1, grid=(1, 1), panel_size=(24, 24))
        ax = self.next_panel()
        corr = np.corrcoef(
            np.concatenate((cmap[:, :, 0].transpose(), cmap[:, :, 1].transpose(), cmap[:, :, 2].transpose()),
                           axis=0))
        plt.imshow(corr, aspect=&#39;auto&#39;, vmin=-1, vmax=1)
        plt.colorbar()
        starts3 = np.concatenate((np.array(starts), np.array(starts) + ends[-1], np.array(starts) + 2 * ends[-1]))
        ends3 = np.concatenate((np.array(ends), np.array(ends) + ends[-1], np.array(ends) + 2 * ends[-1]))
        for i in ends3[:-1]:
            plt.axvline(x=i - 0.5, color=&#39;red&#39;, linewidth=0.5)
            plt.axhline(y=i - 0.5, color=&#39;red&#39;, linewidth=0.5)

        ax.set_xticks((starts3 + ends3) / 2)
        ax.set_yticks((starts3 + ends3) / 2)
        chroms = list(map(Genome.canonical_chrom_name, chroms))
        ax.set_xticklabels(chroms + chroms + chroms)
        ax.set_yticklabels(chroms + chroms + chroms)
        self.fig_show(suffix=&#34;callmap&#34;)
    else:
        self.new_figure(panel_count=2, panel_size=(12, 12))
        ax = self.next_panel()
        x = np.concatenate((cmap[:, :, 0], cmap[:, :, 1], cmap[:, :, 2]),
                           axis=1)
        corr = np.corrcoef(x)
        plt.imshow(corr, aspect=&#39;auto&#39;, vmin=-1, vmax=1)
        plt.colorbar()
        ax = plt.gca()

        ax.set_xticks(range(n))
        ax.set_yticks(range(n))
        ax = self.next_panel()
        Z = hierarchy.linkage(x, &#39;average&#39;, &#39;correlation&#39;)
        dn = hierarchy.dendrogram(Z)

        self.fig_show(suffix=&#34;callmap&#34;)
    return cmap</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.circular"><code class="name flex">
<span>def <span class="ident">circular</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def circular(self):
    chroms = self.chrom
    bin_size = self.bin_size
    n = len(self.plot_files)
    ix = self.plot_files
    snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
        FLAG_USEHAP if self.snp_use_phase else 0)
    rd_flag = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
    self.new_figure(panel_count=n)
    for i in range(n):
        ax = self.next_polar_panel()
        ax.set_theta_zero_location(&#34;N&#34;)
        ax.set_theta_direction(-1)
        rainbow = ax._get_lines
        io = self.io[ix[i]]
        plot_len = 0
        plot_chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            rd_chr = io.rd_chromosome_name(c)
            if rd_chr is not None and (len(chroms) == 0 or (rd_chr in chroms) or (c in chroms)) and (
                    Genome.is_autosome(c) or Genome.is_sex_chrom(c)
            ) and io.signal_exists(rd_chr, bin_size, &#34;SNP maf&#34;, snp_flag) and io.signal_exists(
                rd_chr, bin_size, &#34;RD&#34;, rd_flag):
                plot_chroms.append((rd_chr, l))
                plot_len += l // bin_size + 1
        rd_mean, stdev = io.rd_normal_level(bin_size, rd_flag)
        tl = 0
        dt = 2.0 * np.pi / plot_len
        theta = np.arange(0, 2.0 * np.pi, dt)
        angles = []
        labels = []
        for j in range(len(plot_chroms)):
            c, l = plot_chroms[j]
            next_color = rainbow.get_next_color()
            rd_color = self.rd_circular_colors[j % len(self.rd_circular_colors)]
            snp_color = self.snp_circular_colors[j % len(self.snp_circular_colors)]
            rd = io.get_signal(c, bin_size, &#34;RD&#34;, rd_flag)
            maf = io.get_signal(c, bin_size, &#34;SNP maf&#34;, snp_flag)
            c01 = io.get_signal(c, bin_size, &#34;SNP bin count 0|1&#34;, snp_flag)
            c10 = io.get_signal(c, bin_size, &#34;SNP bin count 1|0&#34;, snp_flag)
            hets = c01 + c10
            np.warnings.filterwarnings(&#39;ignore&#39;)
            maf[hets &lt; (bin_size / 10000)] = 0
            # plt.polar(theta[tl:tl + maf.size], 1 - maf / 2, color=snp_color, linewidth=0.3)
            # plt.fill_between(theta[tl:tl + maf.size], 1 - maf / 2, np.ones_like(maf), color=snp_color, alpha=0.8)
            plt.polar(theta[tl:tl + maf.size], 1 - maf / 2, linewidth=0.3, color=next_color)
            plt.fill_between(theta[tl:tl + maf.size], 1 - maf / 2, np.ones_like(maf), alpha=1, color=next_color)
            markersize = 5
            if self.markersize != &#34;auto&#34;:
                markersize = self.markersize
            ax.scatter(theta[tl:tl + rd.size], np.ones_like(rd) / 10. + 0.7 * rd / (self.rd_range[1] * rd_mean / 2),
                       s=markersize, alpha=0.7, color=next_color)

            # plt.polar(theta[tl:tl + rd.size], np.ones_like(rd) / 10. + 0.7 * rd / (self.rd_range[1] * rd_mean / 2),
            #          color=rd_color, linewidth=0.3)
            # plt.fill_between(theta[tl:tl + rd.size], np.ones_like(rd) / 10.,
            #                 np.ones_like(rd) / 10. + 0.7 * rd / (self.rd_range[1] * rd_mean / 2),
            #                 color=rd_color,
            #                 alpha=0.8)

            # ax.text(theta[tl + maf.size // 3], 0.8, c, fontsize=8)
            labels.append(Genome.canonical_chrom_name(c))
            angles.append(180 * theta[tl + rd.size // 2] / np.pi)
            tl += l // bin_size + 1
        for cn in range(int(self.rd_range[1])):
            plt.polar(theta, np.ones_like(theta) * (0.1 + 0.7 * (cn / self.rd_range[1])), color=&#34;k&#34;, linewidth=0.1)
        ax.set_rmax(1.0)
        ax.set_rticks([])
        ax.set_thetagrids(angles, labels=labels, fontsize=10, weight=&#34;bold&#34;, color=&#34;black&#34;)
        ax.set_title(self.file_title(ix[i]), loc=&#34;left&#34;, fontsize=10, weight=&#34;bold&#34;, color=&#34;black&#34;)
        ax.grid(False)
    self.fig_show(suffix=&#34;circular&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, region1, region2, n_bins=21, plot=False, stdout=True, legend=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def compare(self, region1, region2, n_bins=21, plot=False, stdout=True, legend=True):
    n = len(self.plot_files)
    ix = self.plot_files
    ret = []

    if plot:
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        if self.grid == &#34;auto&#34;:
            sx, sy = self._panels_shape(n)
        else:
            sx, sy = tuple(self.grid)
        self.fig = plt.figure(1, dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(3 * sy)
            self.fig.set_figwidth(4 * sx)
        grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
    for i in range(n):
        io = self.io[ix[i]]
        if plot:
            ax = self.fig.add_subplot(grid[i])
            ax.set_title(self.file_title(ix[i]), position=(0.01, 1.07),
                         fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
        regs1 = decode_region(region1)
        regs2 = decode_region(region2)
        data1 = []
        data2 = []
        for c, (pos1, pos2) in regs1:
            flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
            his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
            bin1 = (pos1 - 1) // self.bin_size
            bin2 = (pos2 - 1) // self.bin_size
            data1 += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])
        for c, (pos1, pos2) in regs2:
            flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
            his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
            bin1 = (pos1 - 1) // self.bin_size
            bin2 = (pos2 - 1) // self.bin_size
            data2 += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])

        data1 = np.array(data1)
        p1_1 = np.percentile(data1, 1)
        p99_1 = np.percentile(data1, 99)
        data1 = data1[data1 &gt; p1_1]
        data1 = data1[data1 &lt; p99_1]
        mean1 = np.mean(data1)
        std1 = np.std(data1)

        data2 = np.array(data2)
        p1_2 = np.percentile(data2, 1)
        p99_2 = np.percentile(data2, 99)
        data2 = data2[data2 &gt; p1_2]
        data2 = data2[data2 &lt; p99_2]
        mean2 = np.mean(data2)
        std2 = np.std(data2)

        rd_min = min(mean1 - 5 * std1, mean2 - 5 * std2)
        rd_max = max(mean1 + 5 * std1, mean2 + 5 * std2)
        bins = np.linspace(rd_min, rd_max, n_bins)

        hist1, binsr = np.histogram(data1, bins=bins)
        hist2, binsr = np.histogram(data2, bins=bins)

        fitn1, fitm1, fits1 = fit_normal(bins[:-1], hist1)[0]
        fitn2, fitm2, fits2 = fit_normal(bins[:-1], hist2)[0]

        pval = t_test_2_samples(fitm1, fits1, sum(hist1), fitm2, fits2, sum(hist2))

        if stdout:
            print(&#34;%s\t%s\t%s\t%.4f\t%.4f\t%.4f\t%.4f\t%e\t%.4f\t%.4f&#34; % (
                io.filename, region1, region2, fitm1, fits1, fitm2, fits2, pval, fitm1 / fitm2,
                fitm1 / fitm2 * (fits1 / fitm1 / np.sqrt(sum(hist1)) + fits2 / fitm2 / np.sqrt(sum(hist2)))))
        ret.append([io.filename, region1, region2, fitm1, fits1, fitm2, fits2, pval, fitm1 / fitm2,
                    fitm1 / fitm2 * (fits1 / fitm1 / np.sqrt(sum(hist1)) + fits2 / fitm2 / np.sqrt(sum(hist2)))])

        if plot:
            x = np.linspace(bins[0], bins[-1], 1001)
            plt.plot(x, normal(x, fitn1, fitm1, fits1), &#34;g-&#34;, label=region1)
            plt.plot(x, normal(x, fitn2, fitm2, fits2), &#34;b-&#34;, label=region2)
            plt.plot(bins[:-1], hist1, &#34;g*&#34;)
            plt.plot(bins[:-1], hist2, &#34;b*&#34;)
            if legend:
                plt.legend()

    if plot:
        if self.output_filename != &#34;&#34;:
            plt.savefig(self._image_filename(&#34;comp&#34;), dpi=200)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    return ret</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.compare_baf"><code class="name flex">
<span>def <span class="ident">compare_baf</span></span>(<span>self, region1, region2, plot=False, stdout=True, legend=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def compare_baf(self, region1, region2, plot=False, stdout=True, legend=True):
    n = len(self.plot_files)
    ix = self.plot_files
    ret = []

    if plot:
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        if self.grid == &#34;auto&#34;:
            sx, sy = self._panels_shape(n)
        else:
            sx, sy = tuple(self.grid)
        self.fig = plt.figure(1, dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(3 * sy)
            self.fig.set_figwidth(4 * sx)
        grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
    for i in range(n):
        io = self.io[ix[i]]
        if plot:
            ax = self.fig.add_subplot(grid[i])
            ax.set_title(self.file_title(ix[i]), position=(0.01, 1.07),
                         fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
        regs1 = decode_region(region1)
        regs2 = decode_region(region2)
        data1 = []
        data2 = []
        for c, (pos1, pos2) in regs1:
            flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
            his_p = io.get_signal(c, self.bin_size, &#34;SNP likelihood&#34;, flag)
            bin1 = (pos1 - 1) // self.bin_size
            bin2 = (pos2 - 1) // self.bin_size
            data1 += list(his_p[bin1:bin2 + 1])
        for c, (pos1, pos2) in regs2:
            flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
            his_p = io.get_signal(c, self.bin_size, &#34;SNP likelihood&#34;, flag)
            bin1 = (pos1 - 1) // self.bin_size
            bin2 = (pos2 - 1) // self.bin_size

            data2 += list(his_p[bin1:bin2 + 1])

        d1 = np.array(data1)
        d2 = np.array(data2)
        h1 = np.ones_like(d1[0])
        h2 = np.ones_like(d2[0])
        for i in range(len(d1)):
            if sum(d1[i]) != 0:
                h1 *= d1[i]
            h1 /= sum(h1)
        for i in range(len(d2)):
            if sum(d2[i]) != 0:
                h2 *= d2[i]
            h2 /= sum(h2)

        b1, p1 = likelihood_baf_pval(h1)
        b2, p2 = likelihood_baf_pval(h2)

        if stdout:
            print(&#34;%s\t%s\t%s\t%.4f\t%e\t%.4f\t%e&#34; % (
                io.filename, region1, region2, b1, p1, b2, p2))
        ret.append([io.filename, region1, region2, b1, p1, b2, p2])

        if plot:
            plt.plot(h1, &#34;g&#34;)
            plt.plot(h2, &#34;b&#34;)

    if plot:
        if self.output_filename != &#34;&#34;:
            plt.savefig(self._image_filename(&#34;comp_baf&#34;), dpi=200)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    return ret</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.compare_rd_dist"><code class="name flex">
<span>def <span class="ident">compare_rd_dist</span></span>(<span>self, regions)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def compare_rd_dist(self, regions):
    self.new_figure(panel_count=1)
    ax = self.next_panel()
    ax.set_ylabel(&#34;Normalised distribution&#34;)
    ax.set_xlabel(&#34;Difference in copy number&#34;)
    regs = decode_region(regions)
    io1 = self.io[self.plot_files[0]]
    io2 = self.io[self.plot_files[1]]
    bin_size = self.bin_size
    drd = []
    for c, (pos1, pos2) in regs:
        flag_rd = 0
        if self.rd_use_mask:
            flag_rd = FLAG_USEMASK
        mean1, stdev = io1.rd_normal_level(bin_size, flag_rd | FLAG_GC_CORR)
        mean2, stdev = io2.rd_normal_level(bin_size, flag_rd | FLAG_GC_CORR)
        his_p_corr1 = io1.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
        his_p_corr2 = io2.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
        for i in range(len(his_p_corr1)):
            drd.append(his_p_corr1[i] * 2 / mean1 - his_p_corr2[i] * 2 / mean2)

    # for i in range(n):
    #     io = self.io[ix[i]]
    #     stat = self.io[self.plot_file].get_signal(None, self.bin_size, &#34;RD stat&#34;, FLAG_AUTO)
    #     his_p = io.get_signal(None, self.bin_size, &#34;RD p dist&#34;, FLAG_AUTO)
    #     bin_size = int(stat[1])
    #     max_rd = int(stat[0])
    #     lim_rd = int(max(2 * stat[4], stat[4] + 3 * stat[5]))
    #     ax.set_xlim([0, lim_rd])
    #     bins = range(0, 2*max_rd + 5*bin_size, bin_size)
    #     x = np.arange(0, max_rd // bin_size * bin_size, 0.1 * bin_size)
    #     #plt.plot(x, normal(x, 1, stat[4], stat[5]), &#34;g-&#34;)
    #     x = np.array(bins)
    #     plt.plot(x[1:len(his_p)], his_p[1:] / stat[3],label = io.filename)
    ax.hist(drd, bins=np.linspace(-0.5, 0.5, 100))
    # ax.legend()
    ax.set_yticklabels([])
    ax.grid()
    self.fig_show(suffix=&#34;compare_rd&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.denovo_calls"><code class="name flex">
<span>def <span class="ident">denovo_calls</span></span>(<span>self, sample, reference, call_type='mosaic')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def denovo_calls(self, sample, reference, call_type=&#34;mosaic&#34;):
    bin_size = self.bin_size
    io = self.io[sample]
    if call_type == &#34;mosaic&#34;:
        chroms = io.rd_chromosomes()
        for c in chroms:
            if (c in self.chrom) or len(self.chrom) == 0:
                flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                if io.signal_exists(c, bin_size, &#34;calls&#34;, flag):
                    calls = io.read_calls(c, bin_size, &#34;calls&#34;, flag)
                    for call in calls:
                        if in_interval(call[&#34;size&#34;], self.size_range) \
                                and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                and in_interval(call[&#34;Q0&#34;], self.Q0_range):
                            type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;
                            region = &#34;%s:%d-%d&#34; % (c, call[&#34;start&#34;], call[&#34;end&#34;])

                            cn0 = self.genotype([bin_size], region, file_index=sample)[0][3]
                            cref = list(
                                map(lambda x: self.genotype([bin_size], region, file_index=x)[0][3], reference))
                            if (((sum(map(lambda x: 0 if (cn0 - x) &gt; 0.5 else 1, cref)) == 0) and cn0 &gt; 2.5) \
                                or ((sum(map(lambda x: 0 if (x - cn0) &gt; 0.5 else 1, cref)) == 0) and cn0 &lt; 1.5)) \
                                    and (sum(map(lambda x: 0 if np.abs(x - 2.) &lt; 0.5 else 1, cref)) == 0):
                                print(type, region, call[&#34;cnv&#34;], cn0, cref)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.dispersion"><code class="name flex">
<span>def <span class="ident">dispersion</span></span>(<span>self, legend=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def dispersion(self, legend=True):
    plt.clf()
    plt.rcParams[&#34;font.size&#34;] = 8
    self.fig = plt.figure(1, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    if self.output_filename != &#34;&#34;:
        self.fig.set_figheight(8)
        self.fig.set_figwidth(12)
    grid = gridspec.GridSpec(1, 2, wspace=0.2, hspace=0.2)

    ax = self.fig.add_subplot(grid[0])
    for i in self.io:
        bin_sizes = sorted(set([int(x[1]) for x in i.chromosomes_bin_sizes_with_signal(&#34;RD&#34;)]))
        rd = []
        drd = []
        for bs in bin_sizes:
            if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO):
                stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO)
                rd.append(stat[4])
                drd.append(stat[5])
        ax.set_yscale(&#34;log&#34;)
        ax.set_xscale(&#34;log&#34;)
        ax.grid(True)
        ax.set_xlabel(&#34;mean RD&#34;)
        ax.set_ylabel(&#34;stdev RD&#34;)
        if legend:
            ax.legend(loc=&#34;upper left&#34;)
        ax.plot(rd, drd, &#34;*-&#34;, label=i.filename)

    ax = self.fig.add_subplot(grid[1])
    for i in self.io:
        bin_sizes = sorted(set([int(x[1]) for x in i.chromosomes_bin_sizes_with_signal(&#34;RD&#34;)]))
        rd = []
        drd = []
        for bs in bin_sizes:
            if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO | FLAG_GC_CORR):
                stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO | FLAG_GC_CORR)
                rd.append(stat[4])
                drd.append(stat[5])
        ax.set_yscale(&#34;log&#34;)
        ax.set_xscale(&#34;log&#34;)
        ax.grid(True)
        ax.set_xlabel(&#34;mean RD (GC corr)&#34;)
        ax.set_ylabel(&#34;stdev RD (GC corr)&#34;)
        if legend:
            ax.legend(loc=&#34;upper left&#34;)
        ax.plot(rd, drd, &#34;*-&#34;, label=i.filename)

    if self.output_filename != &#34;&#34;:
        plt.savefig(self._image_filename(&#34;dispersion&#34;), dpi=200)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.file_title"><code class="name flex">
<span>def <span class="ident">file_title</span></span>(<span>self, ix)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def file_title(self, ix):
    if ix &lt; len(self.file_titles):
        return self.file_titles[ix]
    else:
        return self.io[ix].filename.split(&#34;/&#34;)[-1].replace(&#34;.pytor&#34;, &#34;&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.genotype"><code class="name flex">
<span>def <span class="ident">genotype</span></span>(<span>self, bin_sizes, region, p_val=False, interactive=False, file_index=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def genotype(self, bin_sizes, region, p_val=False, interactive=False, file_index=None):
    if file_index is None:
        file_index = self.plot_file
    ret = []
    regs = decode_region(region, max_size=1000000000)
    for c, (pos1, pos2) in regs:
        chr_len = self.io[file_index].get_chromosome_length(c)
        if chr_len is not None and pos2 == 1000000000:
            pos2 = chr_len
        if interactive:
            print(c + &#34;:&#34; + str(pos1) + &#34;-&#34; + str(pos2), end=&#34;&#34;)
        ret.append([c, pos1, pos2])
        for bs in bin_sizes:
            flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
            stat = self.io[file_index].get_signal(c, bs, &#34;RD stat&#34;, flag_rd | FLAG_AUTO)
            if stat is None or len(stat) == 0:
                stat = self.io[file_index].get_signal(c, bs, &#34;RD stat&#34;, flag_rd | FLAG_SEX)
            his_p = self.io[file_index].get_signal(c, bs, &#34;RD&#34;, flag_rd)
            bin1 = (pos1 - 1) // bs
            bin2 = (pos2 - 1) // bs
            rc = 0
            rc2 = 0
            if bin1 == bin2:
                try:
                    rc = (pos2 - pos1 + 1) * his_p[bin1] / bs
                    rc2 = (pos2 - pos1 + 1) * his_p[bin1] * his_p[bin1] / bs
                except IndexError:
                    pass
            else:
                try:
                    rc += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] / bs
                    rc += (pos2 - bin2 * bs) * his_p[bin2] / bs
                    rc2 += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] * his_p[bin1] / bs
                    rc2 += (pos2 - bin2 * bs) * his_p[bin2] * his_p[bin2] / bs
                except IndexError:
                    pass
                for ix in range(bin1 + 1, bin2):
                    try:
                        rc += his_p[ix]
                        rc2 += his_p[ix] * his_p[ix]
                    except IndexError:
                        pass
            e2 = 0
            if p_val:
                e1 = getEValue(stat[4], stat[5], his_p, bin1, bin2 + 1) * 2.9e9 / bs
                e2 = gaussianEValue(stat[4], stat[5], his_p, bin1, bin2 + 1) * 2.9e9
            if interactive:
                print(&#34;\t%f&#34; % (2. * rc / (stat[4] * (pos2 - pos1 + 1) / bs)), end=&#34;&#34;)
                if p_val:
                    print(&#34;\t%e\t%e&#34; % (e1, e2), end=&#34;&#34;)

            ret[-1].append(2. * rc / (stat[4] * (pos2 - pos1 + 1) / bs))
            if p_val:
                ret[-1].append(e2)
        if interactive:
            print()

    return ret</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.genotype_all"><code class="name flex">
<span>def <span class="ident">genotype_all</span></span>(<span>self, bin_sizes, regions, interactive=False, file_index=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def genotype_all(self, bin_sizes, regions, interactive=False, file_index=None):
    if file_index is None:
        file_index = self.plot_file
    rd_gc_chromosomes = {}
    for c in self.io_gc.gc_chromosomes():
        rd_name = self.io[file_index].rd_chromosome_name(c)
        if not rd_name is None:
            rd_gc_chromosomes[rd_name] = c
    ret = {}
    for bs in bin_sizes:
        oc = &#34;&#34;
        ret[bs] = []
        for region in regions:
            regs = decode_region(region, max_size=1000000000)
            c, (pos1, pos2) = regs[0]
            if oc != c:
                chr_len = self.io[file_index].get_chromosome_length(c)
                if chr_len is not None and pos2 == 1000000000:
                    pos2 = chr_len
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                stat = self.io[file_index].get_signal(c, bs, &#34;RD stat&#34;, flag_rd | FLAG_AUTO)
                if stat is None or len(stat) == 0:
                    stat = self.io[file_index].get_signal(c, bs, &#34;RD stat&#34;, flag_rd | FLAG_SEX)
                his_p = self.io[file_index].get_signal(c, bs, &#34;RD&#34;, flag_rd)
                qrd_p = self.io[file_index].get_signal(c, bs, &#34;RD&#34;)
                qrd_u = self.io[file_index].get_signal(c, bs, &#34;RD unique&#34;)
                gc, at, distN = False, False, False
                if c in rd_gc_chromosomes and self.io_gc.signal_exists(rd_gc_chromosomes[c], None, &#34;GC/AT&#34;):
                    gcat = self.io_gc.get_signal(rd_gc_chromosomes[c], None, &#34;GC/AT&#34;)
                    gc, at = gc_at_decompress(gcat)
                    NN = 100 - np.array(gc) - np.array(at)
                    distN = np.zeros_like(NN, dtype=&#34;long&#34;) - 1
                    distN[NN == 100] = 0
                    prev = 0
                    for Ni in range(0, distN.size):
                        if distN[Ni] == -1:
                            prev += 100
                            distN[Ni] = prev
                        else:
                            prev = 0
                    prev = 0
                    for Ni in range(distN.size - 1, -1, -1):
                        if distN[Ni] &gt; 0:
                            prev += 100
                            if prev &lt; distN[Ni]:
                                distN[Ni] = prev
                        else:
                            prev = 0
                snp = c in self.io[file_index].snp_chromosomes()
                snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                    FLAG_USEHAP if self.snp_use_phase else 0)
                if snp:
                    snp_likelihood = list(
                        self.io[file_index].get_signal(c, bs, &#34;SNP likelihood&#34;, snp_flag).astype(&#34;float64&#34;))
                    snp_hets = self.io[file_index].get_signal(c, bs, &#34;SNP bin count 0|1&#34;, snp_flag)
                    snp_hets += self.io[file_index].get_signal(c, bs, &#34;SNP bin count 1|0&#34;, snp_flag)
                    snp_homs = self.io[file_index].get_signal(c, bs, &#34;SNP bin count 1|1&#34;, snp_flag)
            else:
                if chr_len is not None and pos2 == 1000000000:
                    pos2 = chr_len
            oc = c
            ret[bs].append([c, pos1, pos2])

            bin1 = (pos1 - 1) // bs
            bin2 = (pos2 - 1) // bs
            rc = 0
            rc2 = 0
            sp = 0
            su = 0
            nansize = 0
            if bin1 == bin2:
                try:
                    if not np.isnan(his_p[bin1]):
                        rc = (pos2 - pos1 + 1) * his_p[bin1] / bs
                        rc2 = (pos2 - pos1 + 1) * his_p[bin1] * his_p[bin1] / bs
                        sp = (pos2 - pos1 + 1) * qrd_p[bin1] / bs
                        su = (pos2 - pos1 + 1) * qrd_u[bin1] / bs
                        nansize = (pos2 - pos1 + 1)
                except IndexError:
                    pass
            else:
                try:
                    if not np.isnan(his_p[bin1]):
                        rc += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] / bs
                        rc2 += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] * his_p[bin1] / bs
                        sp += (bin1 * bs - pos1 + 1 + bs) * qrd_p[bin1] / bs
                        su += (bin1 * bs - pos1 + 1 + bs) * qrd_u[bin1] / bs
                        nansize += (bin1 * bs - pos1 + 1 + bs)
                    if not np.isnan(his_p[bin2]):
                        rc += (pos2 - bin2 * bs) * his_p[bin2] / bs
                        rc2 += (pos2 - bin2 * bs) * his_p[bin2] * his_p[bin2] / bs
                        sp += (pos2 - bin2 * bs) * qrd_p[bin2] / bs
                        su += (pos2 - bin2 * bs) * qrd_u[bin2] / bs
                        nansize += (pos2 - bin2 * bs)

                except IndexError:
                    pass
                for ix in range(bin1 + 1, bin2):
                    try:
                        if not np.isnan(his_p[ix]):
                            rc += his_p[ix]
                            rc2 += his_p[ix] * his_p[ix]
                            sp += qrd_p[ix]
                            su += qrd_u[ix]
                            nansize += bs
                    except IndexError:
                        pass
            if gc:
                sbin1 = (pos1 - 1) // 100
                sbin2 = (pos2 - 1) // 100
                pN = 0
                if bin1 == bin2:
                    try:
                        pN = (pos2 - pos1 + 1) * (gc[sbin1] + at[sbin1]) / 100
                    except IndexError:
                        pass
                else:
                    try:
                        pN += (sbin1 * 100 - pos1 + 101) * (gc[sbin1] + at[sbin1]) / 100
                        pN += (pos2 - sbin2 * 100) * (gc[sbin2] + at[sbin2]) / 100

                    except IndexError:
                        pass
                    for ix in range(sbin1 + 1, sbin2):
                        try:
                            pN += gc[ix] + at[ix]
                        except IndexError:
                            pass

            e1 = getEValue(stat[4], stat[5], his_p, bin1, bin2 + 1) * 2.9e9 / bs
            e2 = gaussianEValue(stat[4], stat[5], his_p, bin1, bin2 + 1) * 2.9e9
            dG = -1
            if gc:
                pN = 1 - pN / (pos2 - pos1 + 1)
                dG = np.min(distN[sbin1:sbin2])
            else:
                pN = -1
                dG = -1
            if nansize == 0:
                rc = np.nan
            else:
                rc = 2 * rc / (stat[4] * nansize / bs)
            ret[bs][-1].append(rc)
            ret[bs][-1].append(e1)
            ret[bs][-1].append(e2)
            q0 = 0
            if sp != 0:
                q0 = (sp - su) / sp
            ret[bs][-1].append(q0)
            ret[bs][-1].append(pN)
            ret[bs][-1].append(dG)
            ret[bs][-1].append(nansize / (pos2 - pos1 + 1))
            if snp:
                homs = np.sum(snp_homs[bin1:bin2 + 1])
                hets = np.sum(snp_hets[bin1:bin2 + 1])
                lh = np.ones_like(snp_likelihood[0])
                for ix in range(bin1, min(bin2 + 1, len(snp_likelihood))):
                    lh *= snp_likelihood[ix]
                    lh /= np.sum(lh)
                baf, baf_p = likelihood_baf_pval(lh)
                ret[bs][-1] += [homs, hets, baf, baf_p]
            else:
                ret[bs][-1] += [0, 0, 0, 1]
    if interactive:
        plist = []
        for bs in bin_sizes:
            if len(plist) == 0:
                plist = ret[bs]
            else:
                for ix in range(len(ret[bs])):
                    plist[ix] += ret[bs][ix][3:]
        for r in plist:
            print(
                (&#34;%s:%d-%d&#34; + (len(bin_sizes) * &#34;\t%.4f\t%e\t%e\t%.4f\t%.4f\t%d\t%.4f\t%d\t%d\t%.4f\t%e&#34;)) % tuple(
                    r))
    return ret</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.genotype_prompt"><code class="name flex">
<span>def <span class="ident">genotype_prompt</span></span>(<span>self, bin_sizes=[], all=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def genotype_prompt(self, bin_sizes=[], all=False):
    done = False
    while not done:
        try:
            try:
                line = raw_input(&#34;&#34;)
            except NameError:
                line = input(&#34;&#34;)
        except EOFError:
            return
        if line is None or line == &#34;&#34;:
            done = True
        else:
            if all:
                self.genotype_all(bin_sizes, [line], interactive=True)
            else:
                self.genotype(bin_sizes, line, interactive=True)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.get_calls"><code class="name flex">
<span>def <span class="ident">get_calls</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_calls(self):
    bin_size = self.bin_size
    n = len(self.plot_files)
    ix = self.plot_files
    if self.annotate:
        annotator = Annotator(self.reference_genome)
    ret = []
    for caller in self.callers:
        if caller == &#34;rd_mean_shift&#34;:
            for i in range(n):
                io = self.io[ix[i]]
                chroms = io.rd_chromosomes()
                for c in chroms:
                    if (c in self.chrom) or len(self.chrom) == 0:
                        flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                        if io.signal_exists(c, bin_size, &#34;calls&#34;, flag):
                            calls = io.read_calls(c, bin_size, &#34;calls&#34;, flag)
                            for call in calls:
                                if in_interval(call[&#34;size&#34;], self.size_range) \
                                        and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                        and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                        and in_interval(call[&#34;Q0&#34;], self.Q0_range) \
                                        and in_interval(call[&#34;dG&#34;], self.dG_range):
                                    type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;

                                    row = [self.file_title(ix[i]), caller, type, c, call[&#34;start&#34;], call[&#34;end&#34;],
                                           call[&#34;size&#34;], call[&#34;cnv&#34;], call[&#34;p_val&#34;], call[&#34;p_val_2&#34;],
                                           call[&#34;p_val_3&#34;], call[&#34;p_val_4&#34;], call[&#34;Q0&#34;], call[&#34;pN&#34;], call[&#34;dG&#34;]]
                                    if self.annotate:
                                        row.append(annotator.get_info(&#34;%s:%d-%d&#34; % (c, call[&#34;start&#34;], call[&#34;end&#34;])))
                                    ret.append(row)
        elif caller == &#34;combined_mosaic&#34;:
            for i in range(n):
                io = self.io[ix[i]]
                chroms = io.rd_chromosomes()
                for c in chroms:
                    if (c in self.chrom) or len(self.chrom) == 0:
                        flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR | \
                               (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
                        if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                            calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)
                            for call in calls:
                                if in_interval(call[&#34;size&#34;], self.size_range) \
                                        and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                        and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                        and in_interval(call[&#34;Q0&#34;], self.Q0_range):

                                    if n &gt; 1:
                                        print(&#34;%s\t&#34; % self.file_title(ix[i]), end=&#34;&#34;)
                                    if len(self.callers) &gt; 1:
                                        print(&#34;%s\t&#34; % caller, end=&#34;&#34;)
                                    keys = [&#34;start&#34;, &#34;end&#34;, &#34;size&#34;, &#34;cnv&#34;, &#34;p_val&#34;, &#34;lh_del&#34;, &#34;lh_loh&#34;,
                                            &#34;lh_dup&#34;, &#34;Q0&#34;, &#34;pN&#34;, &#34;pNS&#34;, &#34;pP&#34;, &#34;bins&#34;, &#34;baf&#34;,
                                            &#34;rd_p_val&#34;, &#34;baf_p_val&#34;, &#34;segment&#34;, &#34;hets&#34;, &#34;homs&#34;]
                                    type = {-1: &#34;deletion&#34;, 0: &#34;cnnloh&#34;, 1: &#34;duplication&#34;}[call[&#34;type&#34;]]
                                    row = [self.file_title(i), caller, type, c] + [call[k] for k in keys]
                                    for m in range(2):
                                        row += call[&#34;models&#34;][m]

                                    if self.annotate:
                                        row.append(annotator.get_info(&#34;%s:%d-%d&#34; % (data[3], data[4], data[5])))
                                    ret.append(row)
    return ret</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.global_plot"><code class="name flex">
<span>def <span class="ident">global_plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def global_plot(self):
    chroms = []
    for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
        rd_chr = self.io[self.plot_files[0]].rd_chromosome_name(c)
        if (len(self.chrom) == 0 or (rd_chr in self.chrom) or (c in self.chrom)) and rd_chr is not None:
            if (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append((rd_chr, l))
    panels = self.panels
    bin_size = self.bin_size
    snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
        FLAG_USEHAP if self.snp_use_phase else 0)
    rd_flag = (FLAG_USEMASK if self.rd_use_mask else 0) | (FLAG_GC_CORR if self.rd_use_gc_corr else 0)
    n = len(self.plot_files)
    self.new_figure(panel_count=n)
    for ii in range(len(self.plot_files)):
        ix = self.plot_files[ii]
        self.new_subgrid(len(panels), hspace=0.05, wspace=0.05)
        io = self.io[ix]
        for i in range(len(panels)):
            ax = self.next_subpanel(sharex=True)
            if i == 0:
                ax.set_title(self.file_title(ix), position=(0.01, 0.9),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                             color=&#39;C0&#39;)

            if panels[i] == &#34;rd&#34;:
                start = 0
                xticks = [0]
                xticks_minor = []
                xticks_labels = []
                for c, l in chroms:
                    mean, stdev = io.rd_normal_level(bin_size, rd_flag | FLAG_GC_CORR)
                    his_p = io.get_signal(c, bin_size, &#34;RD&#34;, rd_flag)
                    pos = range(start, start + len(his_p))
                    if self.markersize == &#34;auto&#34;:
                        plt.plot(pos, his_p, ls=&#39;&#39;, marker=&#39;.&#39;, markersize=1)
                    else:
                        plt.plot(pos, his_p, ls=&#39;&#39;, marker=&#39;.&#39;, markersize=self.markersize)
                    xticks_minor.append(start + len(his_p) // 2)
                    xticks_labels.append(Genome.canonical_chrom_name(c))
                    start += l // bin_size + 1
                    xticks.append(start)

                ax.set_xlim([0, start])
                ax.xaxis.set_ticks(xticks)
                ax.xaxis.set_ticklabels([&#34;&#34;] * len(xticks))
                if i == (len(panels) - 1):
                    ax.xaxis.set_ticks(xticks_minor, minor=True)
                    ax.xaxis.set_ticklabels(xticks_labels, minor=True)
                else:
                    plt.setp(ax.get_xticklabels(which=&#34;both&#34;), visible=False)
                yticks = np.arange(self.rd_manhattan_range[0], self.rd_manhattan_range[1], 0.5)
                ax.yaxis.set_ticklabels([str(int(2 * t)) for t in yticks])
                ax.yaxis.set_ticks(yticks * mean)
                ax.set_ylabel(&#34;RD [CN]&#34;)
                ax.set_ylim([self.rd_manhattan_range[0] * mean, self.rd_manhattan_range[1] * mean])
                ax.grid()
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;snp&#34;:
                start = 0
                xticks = []
                xticks_minor = []
                xticks_labels = []
                pos_x = []
                for c, l in chroms:
                    pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c)
                    ix = 0
                    hpos = []
                    color = []
                    alpha = 0.7
                    baf = []
                    while ix &lt; len(pos):
                        if (nref[ix] + nalt[ix]) != 0 and ((not self.snp_use_id) or (flag[ix] &amp; 1)):
                            hpos.append(start + (pos[ix] / bin_size))
                            if gt[ix] % 4 != 2:
                                baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            else:
                                baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                            if self.snp_alpha_P:
                                alpha = None
                                color.append(
                                    colors.to_rgba(self.snp_colors[(gt[ix] % 4) * 2 + 1], (flag[ix] &gt;&gt; 1) * 0.4))
                            else:
                                color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                        ix += 1
                    if self.markersize == &#34;auto&#34;:
                        ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=0.1, alpha=alpha)
                    else:
                        ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=alpha)
                    xticks_minor.append(start + l // bin_size // 2)
                    xticks_labels.append(Genome.canonical_chrom_name(c))
                    start += l // bin_size + 1
                    xticks.append(start)
                ax.set_xlim([0, start])
                ax.xaxis.set_ticks(xticks)
                ax.xaxis.set_ticklabels([&#34;&#34;] * len(xticks))
                if i == (len(panels) - 1):
                    ax.xaxis.set_ticks(xticks_minor, minor=True)
                    ax.xaxis.set_ticklabels(xticks_labels, minor=True)
                else:
                    plt.setp(ax.get_xticklabels(minor=True), visible=False)
                ax.grid()
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0])
                ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
                ax.set_ylabel(&#34;BAF&#34;)
                ax.set_ylim([-0.05, 1.05])
                ax.yaxis.grid()
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;snv&#34; or panels[i][:4] == &#34;snv:&#34;:
                callset = &#34;default&#34;
                if panels[i][:4] == &#34;snv:&#34;:
                    callset = panels[i].split(&#34;:&#34;)[1]
                start = 0
                xticks = []
                xticks_minor = []
                xticks_labels = []
                pos_x = []
                for c, l in chroms:
                    pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c, callset=callset)
                    ix = 0
                    hpos = []
                    color = []
                    alpha = 0.7
                    baf = []
                    while ix &lt; len(pos):
                        if (nref[ix] + nalt[ix]) != 0 and ((not self.snp_use_id) or (flag[ix] &amp; 1)):
                            hpos.append(start + (pos[ix] / bin_size))
                            if gt[ix] % 4 != 2:
                                baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            else:
                                baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                            if self.snp_alpha_P:
                                alpha = None
                                color.append(
                                    colors.to_rgba(self.snp_colors[(gt[ix] % 4) * 2 + 1], (flag[ix] &gt;&gt; 1) * 0.4))
                            else:
                                color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                        ix += 1
                    if self.markersize == &#34;auto&#34;:
                        ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=0.1, alpha=alpha)
                    else:
                        ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=alpha)
                    xticks_minor.append(start + l // bin_size // 2)
                    xticks_labels.append(Genome.canonical_chrom_name(c))
                    start += l // bin_size + 1
                    xticks.append(start)
                ax.set_xlim([0, start])
                ax.xaxis.set_ticks(xticks)
                ax.xaxis.set_ticklabels([&#34;&#34;] * len(xticks))
                if i == (len(panels) - 1):
                    ax.xaxis.set_ticks(xticks_minor, minor=True)
                    ax.xaxis.set_ticklabels(xticks_labels, minor=True)
                else:
                    plt.setp(ax.get_xticklabels(minor=True), visible=False)
                ax.grid()
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0])
                ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
                ax.set_ylabel(&#34;BAF&#34;)
                ax.set_ylim([-0.05, 1.05])
                ax.yaxis.grid()
                self.fig.add_subplot(ax)


            elif panels[i] == &#34;likelihood&#34;:
                start = 0
                xticks = [0]
                xticks_minor = []
                xticks_labels = []
                gl = []
                for c, l in chroms:
                    likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
                    lh = list(likelihood)
                    size = l // bin_size + 1
                    if len(lh) &lt; size:
                        if len(lh)&gt;0:
                            lh.extend([lh[-1] for jj in range(size - len(lh))])
                        elif len(gl)&gt;0:
                            lh.extend([gl[-1] for jj in range(size - len(lh))])

                    gl.extend(lh)
                    xticks_minor.append(start + l // bin_size // 2)
                    xticks_labels.append(Genome.canonical_chrom_name(c))
                    start += l // bin_size + 1
                    xticks.append(start)

                img = np.array(gl).transpose()
                img[0, :] = 0
                img[-1, :] = 0
                ax.imshow(img, aspect=&#39;auto&#39;)
                ax.yaxis.set_ticks([0, img.shape[0] / 4, img.shape[0] / 2, 3 * img.shape[0] / 4, img.shape[0] - 1],
                                   minor=[])
                ax.yaxis.set_ticklabels([&#34;1&#34;, &#34;3/4&#34;, &#34;1/2&#34;, &#34;1/4&#34;, &#34;0&#34;])
                ax.set_ylabel(&#34;BAF&#34;)
                ax.set_xlim([0, start])
                ax.xaxis.set_ticks(xticks)
                ax.xaxis.set_ticklabels([&#34;&#34;] * len(xticks))
                if i == (len(panels) - 1):
                    ax.xaxis.set_ticks(xticks_minor, minor=True)
                    ax.xaxis.set_ticklabels(xticks_labels, minor=True)
                else:
                    plt.setp(ax.get_xticklabels(minor=True), visible=False)
                ax.xaxis.grid()
                self.fig.add_subplot(ax)

    self.fig_show(suffix=&#34;global&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.help"><code class="name flex">
<span>def <span class="ident">help</span></span>(<span>self, param)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def help(self, param):
    if param in self.param_help:
        print(self.param_help[param])
    else:
        print(&#34;\nUnknown parameter !\n&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.likelihood"><code class="name flex">
<span>def <span class="ident">likelihood</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def likelihood(self):
    bin_size = self.bin_size
    snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
        FLAG_USEHAP if self.snp_use_phase else 0)
    if self.reference_genome is None:
        _logger.warning(&#34;Missing reference genome required for gview.&#34;)
        return
    chroms = []
    if self.reference_genome is None:
        chroms = self.io[self.plot_file].snp_chromosomes()
    else:
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
            if self.io[self.plot_file].signal_exists(snp_chr, bin_size, &#34;SNP likelihood&#34;, snp_flag) and (
                    Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append(snp_chr)
    self.new_figure(panel_count=len(chroms))
    for c in chroms:
        likelihood = self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
        img = np.array(likelihood).transpose()
        ax = self.next_panel()
        ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                     color=&#39;C0&#39;)
        ax.imshow(img, aspect=&#39;auto&#39;)
        ax.xaxis.set_ticklabels([])
        ax.yaxis.set_ticklabels([])
        ax.xaxis.set_ticks(np.arange(0, likelihood.shape[0], 50), minor=[])
        ax.set_xlim([0, likelihood.shape[0]])
        if self.snp_call and (&#34;baf_mosaic&#34; in self.callers):
            likelihood = self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
            segments = segments_decode(
                self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
            call_pos = []
            call_i1 = []
            call_i2 = []
            call_c = []
            for s, lh in zip(segments, likelihood):
                i1, i2, p = likelihood_pixels_pval(lh)
                if i1 != i2 and len(s) &gt; self.min_segment_size:
                    alpha = -np.log(p + 1e-40) / self.contrast
                    if alpha &gt; 1:
                        alpha = 1
                    for pos in s:
                        call_pos.append(pos)
                        call_i1.append(min(i1, i2))
                        call_i2.append(max(i1, i2))
                        color = colors.to_rgb(self.lh_colors[0]) + (alpha,)
                        call_c.append(color)
            plt.scatter(call_pos, call_i1, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                        marker=self.lh_marker)
            plt.scatter(call_pos, call_i2, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                        marker=self.lh_marker)
        if self.snp_call and (&#34;combined_mosaic&#34; in self.callers):
            likelihood = self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood call 2d&#34;, snp_flag)
            segments = segments_decode(
                self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood segments 2d&#34;, snp_flag))
            call_pos = []
            call_i1 = []
            call_i2 = []
            call_c = []
            for s, lh in zip(segments, likelihood):
                i1, i2, p = likelihood_pixels_pval(lh)
                if i1 != i2 and len(s) &gt; self.min_segment_size:
                    alpha = -np.log(p + 1e-40) / self.contrast
                    if alpha &gt; 1:
                        alpha = 1
                    for pos in s:
                        call_pos.append(pos)
                        call_i1.append(min(i1, i2))
                        call_i2.append(max(i1, i2))
                        color = colors.to_rgb(self.lh_colors[1]) + (alpha,)
                        call_c.append(color)
            plt.scatter(call_pos, call_i1, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                        marker=self.lh_marker)
            plt.scatter(call_pos, call_i2, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                        marker=self.lh_marker)
    self.fig_show(suffix=&#34;likelihood&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.manhattan"><code class="name flex">
<span>def <span class="ident">manhattan</span></span>(<span>self, plot_type='rd')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def manhattan(self, plot_type=&#34;rd&#34;):
    bin_size = self.bin_size
    if self.reference_genome is None:
        _logger.warning(&#34;Missing reference genome required for manhattan.&#34;)
        return
    n = len(self.plot_files)
    ix = self.plot_files

    self.new_figure(panel_count=n, grid=(1, n), panel_size=(24, 2))
    for i in range(n):
        ax = self.next_panel()
        io = self.io[ix[i]]
        ax.set_title(self.file_title(ix[i]), position=(0.01, 1.01),
                     fontdict={&#39;verticalalignment&#39;: &#39;bottom&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})

        if plot_type == &#34;rd&#34;:
            chroms = []
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                rd_chr = io.rd_chromosome_name(c)
                if len(self.chrom) == 0 or (rd_chr in self.chrom) or (c in self.chrom):
                    if io.signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                            io.signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                            (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append((rd_chr, l))

            apos = 0
            xticks = [0]

            max_m, stdev = io.rd_normal_level(bin_size, FLAG_GC_CORR)
            for c, l in chroms:
                flag_rd = (FLAG_USEMASK if self.rd_use_mask else 0)
                his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                his_p_corr = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
                if self.rd_manhattan_call:
                    his_p_call = io.get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg = io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                     flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
                    his_p_mosaic_call = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                      flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg_2d = io.get_signal(c, bin_size, &#34;RD mosaic segments 2d&#34;,
                                                        flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg_2d = segments_decode(his_p_mosaic_seg_2d)
                    his_p_mosaic_call_2d = io.get_signal(c, bin_size, &#34;RD mosaic call 2d&#34;,
                                                         flag_rd | FLAG_GC_CORR)
                    his_p_mosaic = np.zeros_like(his_p) * np.nan
                    if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and (
                            &#34;rd_mosaic&#34; in self.callers):
                        for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                            for segi in seg:
                                his_p_mosaic[segi] = lev
                    his_p_mosaic_2d = np.zeros_like(his_p) * np.nan
                    if his_p_mosaic_call_2d is not None and len(
                            his_p_mosaic_call_2d) &gt; 0 and (&#34;combined_mosaic&#34; in self.callers):
                        for seg, lev in zip(list(his_p_mosaic_seg_2d), list(his_p_mosaic_call_2d[0])):
                            for segi in seg:
                                his_p_mosaic_2d[segi] = lev
                pos = range(apos, apos + len(his_p))
                ax.text(apos + len(his_p) // 2, max_m // 10, Genome.canonical_chrom_name(c),
                        fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                if self.markersize == &#34;auto&#34;:
                    plt.plot(pos, his_p_corr, ls=&#39;&#39;, marker=&#39;.&#39;)
                else:
                    plt.plot(pos, his_p_corr, ls=&#39;&#39;, marker=&#39;.&#39;, markersize=self.markersize)
                if self.rd_manhattan_call:
                    if his_p_call is not None and len(his_p_call) &gt; 0 and (&#34;rd_mean_shift&#34; in self.callers):
                        plt.step(pos, his_p_call, &#34;r&#34;)
                    if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and (
                            &#34;rd_mosaic&#34; in self.callers):
                        plt.plot(pos, his_p_mosaic, &#34;k&#34;)
                    if his_p_mosaic_call_2d is not None and len(
                            his_p_mosaic_call_2d) &gt; 0 and (&#34;combined_mosaic&#34; in self.callers):
                        plt.plot(pos, his_p_mosaic_2d, &#34;k&#34;)
                apos += len(his_p)
                xticks.append(apos)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks(np.arange(0, 15, 0.5) * max_m, minor=[])
            ax.xaxis.set_ticks(xticks, minor=[])
            ax.set_ylim([self.rd_manhattan_range[0] * max_m, self.rd_manhattan_range[1] * max_m])
            n_bins = apos
            ax.set_xlim([0, n_bins])
            ax.grid()

        elif plot_type == &#34;baf_mosaic&#34;:
            chroms = []
            snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                FLAG_USEHAP if self.snp_use_phase else 0)
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = io.snp_chromosome_name(c)
                if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                    if io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood call&#34;, snp_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood segments&#34;, snp_flag) and \
                            (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append((snp_chr, l))

            apos = 0
            xticks = [0]

            cix = 0
            cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
            for c, l in chroms:
                likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                segments = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
                call_pos = []
                call_baf = []
                call_c = []
                for s, lh in zip(segments, likelihood):
                    b, p = likelihood_baf_pval(lh)
                    if b &gt; 0 and len(s) &gt; self.min_segment_size:
                        alpha = -np.log(p + 1e-40) / self.contrast
                        if alpha &gt; 1:
                            alpha = 1
                        for pos in s:
                            call_pos.append(apos + pos)
                            call_baf.append(b)
                            color = cmap[cix % len(cmap)]
                            color = (color[0], color[1], color[2], alpha)
                            call_c.append(color)

                ax.text(apos + l // bin_size // 2, 0.4, Genome.canonical_chrom_name(c),
                        fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                plt.scatter(call_pos, call_baf, s=20, color=np.array(call_c), edgecolors=&#39;face&#39;, marker=&#39;|&#39;)
                apos += l // bin_size
                xticks.append(apos)
                cix += 1

            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks(np.arange(0, 0.5, 0.1), minor=[])
            ax.xaxis.set_ticks(xticks, minor=[])
            ax.set_ylim([0, 0.5])
            n_bins = apos
            ax.set_xlim([0, n_bins])
            ax.grid()

        elif plot_type == &#34;rd_mean_shift&#34;:
            chroms = []
            flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR

            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                rd_chr = io.rd_chromosome_name(c)
                if rd_chr is not None and len(self.chrom) == 0 or (rd_chr in self.chrom) or (c in self.chrom):
                    if (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append((rd_chr, l))

            apos = 0
            xticks = [0]

            cix = 0
            cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
            for c, l in chroms:
                call_pos = []
                call_conc = []
                call_c = []
                if io.signal_exists(c, bin_size, &#34;calls&#34;, flag):
                    calls = io.read_calls(c, bin_size, &#34;calls&#34;, flag)

                    for call in calls:
                        if in_interval(call[&#34;size&#34;], self.size_range) and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                and in_interval(call[&#34;Q0&#34;], self.Q0_range):
                            alpha = - np.log(call[&#34;p_val&#34;] + 1e-40) / self.contrast
                            if alpha &gt; 1:
                                alpha = 1
                            if alpha &lt; 0:
                                alpha = 0
                            for pos in range(int(call[&#34;start&#34;]) // bin_size, int(call[&#34;end&#34;]) // bin_size + 1):
                                call_pos.append(apos + pos)
                                level = call[&#34;cnv&#34;] * 2
                                if level &gt; 4:
                                    level = 4
                                call_conc.append(level)
                                if call[&#34;type&#34;] == 1:
                                    call_c.append((0, 1, 0, alpha))
                                elif call[&#34;type&#34;] == -1:
                                    call_c.append((1, 0, 0, alpha))
                                else:
                                    call_c.append((0, 0, 1, alpha))
                    ax.text(apos + l // bin_size // 2, 0.4, Genome.canonical_chrom_name(c),
                            fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                    plt.scatter(call_pos, call_conc, s=20, color=np.array(call_c), edgecolors=&#39;face&#39;, marker=&#39;|&#39;)
                    apos += l // bin_size
                    xticks.append(apos)
                    cix += 1

            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks(np.arange(0, 4.0, 1.0), minor=[])
            ax.xaxis.set_ticks(xticks, minor=[])
            ax.set_ylim([0, 4.0])
            n_bins = apos
            ax.set_xlim([0, n_bins])
            ax.grid()

        elif plot_type == &#34;combined_mosaic&#34;:
            chroms = []
            flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                FLAG_USEHAP if self.snp_use_phase else 0) | (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR

            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = io.snp_chromosome_name(c)
                if snp_chr is not None and len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                    if (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append((snp_chr, l))

            apos = 0
            xticks = [0]

            cix = 0
            cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
            for c, l in chroms:
                call_pos = []
                call_conc = []
                call_c = []
                if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                    calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)

                    for call in calls:
                        if call[&#34;bins&#34;] &gt; self.min_segment_size:
                            alpha = -np.log(call[&#34;p_val&#34;] + 1e-40) / self.contrast
                            if alpha &gt; 1:
                                alpha = 1
                            for pos in range(int(call[&#34;start&#34;]) // bin_size, int(call[&#34;end&#34;]) // bin_size + 1):
                                call_pos.append(apos + pos)
                                call_conc.append(call[&#34;models&#34;][0][4])
                                if call[&#34;type&#34;] == 1:
                                    call_c.append((0, 1, 0, alpha))
                                elif call[&#34;type&#34;] == -1:
                                    call_c.append((1, 0, 0, alpha))
                                else:
                                    call_c.append((0, 0, 1, alpha))

                    ax.text(apos + l // bin_size // 2, 0.4, Genome.canonical_chrom_name(c),
                            fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                    plt.scatter(call_pos, call_conc, s=20, color=np.array(call_c), edgecolors=&#39;face&#39;, marker=&#39;|&#39;)
                    apos += l // bin_size
                    xticks.append(apos)
                    cix += 1

            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks(np.arange(0, 1.0, 0.1), minor=[])
            ax.xaxis.set_ticks(xticks, minor=[])
            ax.set_ylim([0, 1.0])

            n_bins = apos
            ax.set_xlim([0, n_bins])
            ax.grid()

    self.fig_show(suffix=&#34;manhattan&#34; if plot_type == &#34;rd&#34; else &#34;snp_calls&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.multiple_regions"><code class="name flex">
<span>def <span class="ident">multiple_regions</span></span>(<span>self, regions)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def multiple_regions(self, regions):
    n = len(self.plot_files) * len(regions)
    self.new_figure(panel_count=n)
    j = 0
    for i in range(len(self.plot_files)):
        for r in regions:
            self.regions(self.plot_files[i], r)
            j += 1
    self.fig_show(suffix=&#34;regions&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, command)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def parse(self, command):
    current = &#34;regions&#34;
    regions = []

    for p in command:
        if p.isdigit() and (int(p) % 100) == 0:
            self.bin_size = int(p)
            if current == &#34;rd&#34;:
                self.rd()
            if current == &#34;baf&#34;:
                self.baf()
            if current == &#34;likelihood&#34;:
                self.likelihood()
            elif current == &#34;manhattan&#34;:
                self.global_plot()
            elif current == &#34;calls&#34;:
                if len(self.callers) &gt; 0:
                    self.manhattan(plot_type=self.callers[0])
            elif current == &#34;stat&#34;:
                self.stat(int(p))
            elif current == &#34;circular&#34;:
                self.circular()
            elif current == &#34;regions&#34;:
                self.multiple_regions(regions)
                regions = []
        elif p == &#34;rdstat&#34;:
            self.stat()
        elif p == &#34;snp&#34;:
            self.snp()
        elif p in [&#34;rd&#34;, &#34;baf&#34;, &#34;manhattan&#34;, &#34;calls&#34;, &#34;stat&#34;, &#34;regions&#34;, &#34;likelihood&#34;, &#34;circular&#34;]:
            current = p
        elif current == &#34;regions&#34;:
            regions.append(p)
        else:
            current = p</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.phased_baf"><code class="name flex">
<span>def <span class="ident">phased_baf</span></span>(<span>self, regions, callset=None, print=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def phased_baf(self, regions, callset=None, print=False):
    regions = regions.split(&#34; &#34;)
    n = len(regions)
    ret = []
    for i in range(n):
        regs = decode_region(regions[i])
        talt = 0
        tref = 0
        taltP = 0
        trefP = 0
        for c, (pos1, pos2) in regs:
            pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_file].read_snp(c, callset=callset)
            ix = 0
            while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0:
                    if gt[ix] == 5:
                        talt += nalt[ix]
                        tref += nref[ix]
                        if flag[ix] &amp; 2:
                            taltP += nalt[ix]
                            trefP += nref[ix]
                    elif gt[ix] == 6:
                        tref += nalt[ix]
                        talt += nref[ix]
                        if flag[ix] &amp; 2:
                            trefP += nalt[ix]
                            taltP += nref[ix]
                ix += 1
        baf = talt / (tref + talt)
        bafP = taltP / (trefP + taltP)
        ret.append([baf, bafP])
        if print:
            print(&#34;%s\t%f\t%f&#34; % (regions[i], baf, bafP))
    return ret</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.plot_command"><code class="name flex">
<span>def <span class="ident">plot_command</span></span>(<span>self, command)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_command(self, command):
    self.interactive = False
    self.parse(command)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.print_calls"><code class="name flex">
<span>def <span class="ident">print_calls</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def print_calls(self):
    bin_size = self.bin_size
    n = len(self.plot_files)
    ix = self.plot_files
    if self.annotate:
        annotator = Annotator(self.reference_genome)
    for caller in self.callers:
        if caller == &#34;rd_mean_shift&#34;:
            for i in range(n):
                io = self.io[ix[i]]
                chroms = io.rd_chromosomes()
                for c in chroms:
                    if (c in self.chrom) or len(self.chrom) == 0:
                        flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                        if io.signal_exists(c, bin_size, &#34;calls&#34;, flag):
                            calls = io.read_calls(c, bin_size, &#34;calls&#34;, flag)
                            for call in calls:
                                if in_interval(call[&#34;size&#34;], self.size_range) \
                                        and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                        and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                        and in_interval(call[&#34;Q0&#34;], self.Q0_range) \
                                        and in_interval(call[&#34;dG&#34;], self.dG_range):
                                    type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;
                                    if n &gt; 1:
                                        print(&#34;%s\t&#34; % self.file_title(i), end=&#34;&#34;)
                                    if len(self.callers) &gt; 1:
                                        print(&#34;%s\t&#34; % caller, end=&#34;&#34;)
                                    print(&#34;%s\t%s:%d-%d\t%d\t%.4f\t%e\t%e\t%e\t%e\t%.4f\t%.4f\t%d\t&#34; % (
                                        type, c, call[&#34;start&#34;], call[&#34;end&#34;], call[&#34;size&#34;], call[&#34;cnv&#34;],
                                        call[&#34;p_val&#34;],
                                        call[&#34;p_val_2&#34;], call[&#34;p_val_3&#34;], call[&#34;p_val_4&#34;], call[&#34;Q0&#34;], call[&#34;pN&#34;],
                                        call[&#34;dG&#34;]), end=&#34;&#34;)
                                    if self.annotate:
                                        print(&#34;\t%s&#34; % annotator.get_info(
                                            &#34;%s:%d-%d&#34; % (c, call[&#34;start&#34;], call[&#34;end&#34;])))
                                    else:
                                        print()
                                    if self.plot:
                                        plot_start = call[&#34;start&#34;] - call[&#34;size&#34;]
                                        if plot_start &lt; 0:
                                            plot_start = 0
                                        plot_end = call[&#34;end&#34;] + call[&#34;size&#34;]
                                        self.multiple_regions([&#34;%s:%d-%d&#34; % (c, plot_start, plot_end)])
        elif caller == &#34;combined_mosaic&#34;:
            for i in range(n):
                io = self.io[ix[i]]
                chroms = io.rd_chromosomes()
                for c in chroms:
                    if (c in self.chrom) or len(self.chrom) == 0:
                        flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR | \
                               (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
                        if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                            calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)
                            for call in calls:
                                if in_interval(call[&#34;size&#34;], self.size_range) \
                                        and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                        and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                        and in_interval(call[&#34;Q0&#34;], self.Q0_range):
                                    type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;
                                    if n &gt; 1:
                                        print(&#34;%s\t&#34; % self.file_title(i), end=&#34;&#34;)
                                    if len(self.callers) &gt; 1:
                                        print(&#34;%s\t&#34; % caller, end=&#34;&#34;)
                                    keys = [&#34;start&#34;, &#34;end&#34;, &#34;size&#34;, &#34;cnv&#34;, &#34;p_val&#34;, &#34;lh_del&#34;, &#34;lh_loh&#34;,
                                            &#34;lh_dup&#34;, &#34;Q0&#34;, &#34;pN&#34;, &#34;pNS&#34;, &#34;pP&#34;, &#34;bins&#34;, &#34;baf&#34;,
                                            &#34;rd_p_val&#34;, &#34;baf_p_val&#34;, &#34;segment&#34;, &#34;hets&#34;, &#34;homs&#34;]
                                    type = {-1: &#34;deletion&#34;, 0: &#34;cnnloh&#34;, 1: &#34;duplication&#34;}[call[&#34;type&#34;]]
                                    data = [type, c] + [call[k] for k in keys]
                                    for m in range(2):
                                        data += call[&#34;models&#34;][m]

                                    print((&#34;%s\t%s:%d-%d\t%d\t%.4f\t%e\t%e\t%e\t%e&#34; + \
                                           &#34;\t%.4f\t%.4f\t%.4f\t%.4f\t&#34; + &#34;%d\t%d\t%.4f\t%e\t%e\t%d\t%d\t%d\t&#34; + \
                                           &#34;CN%d/CN%d\t%e\t%.4f\t%d\tCN%d/CN%d\t%e\t%.4f&#34;) % tuple(data), end=&#34;&#34;)
                                    if self.annotate:
                                        print(&#34;\t%s&#34; % annotator.get_info(&#34;%s:%d-%d&#34; % (data[1], data[2], data[3])))
                                    else:
                                        print()
                                    if self.plot:
                                        plot_start = call[&#34;start&#34;] - call[&#34;size&#34;]
                                        if plot_start &lt; 0:
                                            plot_start = 0
                                        plot_end = call[&#34;end&#34;] + call[&#34;size&#34;]
                                        self.multiple_regions([&#34;%s:%d-%d&#34; % (c, plot_start, plot_end)])</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.print_calls_file"><code class="name flex">
<span>def <span class="ident">print_calls_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">    def print_calls_file(self):
        format = self.print_filename.split(&#34;.&#34;)[-1]
        calls = self.get_calls()
        if self.print_filename == &#34;&#34;:
            for call in calls:
                print(*call, sep=&#34;\t&#34;)
        elif format == &#34;tsv&#34;:
            with open(self.print_filename, &#39;w&#39;) as f:
                for call in calls:
                    print(*call, sep=&#34;\t&#34;, file=f)
        elif format == &#34;xlsx&#34;:
            import xlsxwriter
            workbook = xlsxwriter.Workbook(self.print_filename)
            files_callers = []
            sheets = {}
            rix = {}
            for call in calls:
                caller = call[1]
                fc = call[0] + &#34; (&#34; + caller + &#34;)&#34;
                sfc = call[0][:25] + &#34; &#34; + ({&#34;rd_mean_shift&#34;: &#34;ms&#34;, &#34;combined_mosaic&#34;: &#34;2d&#34;}[caller])
                if fc not in files_callers:
                    sheets[fc] = workbook.add_worksheet(sfc)
                    rix[fc] = 0
                    files_callers.append(fc)
            for call in calls:
                caller = call[1]
                fc = call[0] + &#34; (&#34; + caller + &#34;)&#34;
                cix = 0
                for f in call[2:]:
                    sheets[fc].write(rix[fc], cix, f)
                    cix += 1
                rix[fc] += 1
            workbook.close()
        elif format == &#34;vcf&#34;:
            samples = []
            for call in calls:
                sample = call[0]
                if sample not in samples:
                    samples.append(sample)
            header = &#34;&#34;&#34;##fileformat=VCFv4.1
##fileDate={date}
##reference={rg}
##source=CNVpytor
##INFO=&lt;ID=END,Number=1,Type=Integer,Description=&#34;End position of the variant described in this record&#34;&gt;
##INFO=&lt;ID=IMPRECISE,Number=0,Type=Flag,Description=&#34;Imprecise structural variation&#34;&gt;
##INFO=&lt;ID=SVLEN,Number=1,Type=Integer,Description=&#34;Difference in length between REF and ALT alleles&#34;&gt;
##INFO=&lt;ID=SVTYPE,Number=1,Type=String,Description=&#34;Type of structural variant&#34;&gt;
##INFO=&lt;ID=pytorRD,Number=1,Type=Float,Description=&#34;Normalized RD&#34;&gt;
##INFO=&lt;ID=pytorP1,Number=1,Type=Float,Description=&#34;e-val by t-test&#34;&gt;
##INFO=&lt;ID=pytorP2,Number=1,Type=Float,Description=&#34;e-val by Gaussian tail&#34;&gt;
##INFO=&lt;ID=pytorP3,Number=1,Type=Float,Description=&#34;e-val by t-test (middle)&#34;&gt;
##INFO=&lt;ID=pytorP4,Number=1,Type=Float,Description=&#34;e-val by Gaussian tail (middle)&#34;&gt;
##INFO=&lt;ID=pytorQ0,Number=1,Type=Float,Description=&#34;Fraction of reads with 0 mapping quality&#34;&gt;
##INFO=&lt;ID=pytorPN,Number=1,Type=Integer,Description=&#34;Fraction of N bases&#34;&gt;
##INFO=&lt;ID=pytorDG,Number=1,Type=Integer,Description=&#34;Distance to nearest gap in reference genome&#34;&gt;
##INFO=&lt;ID=pytorCL,Number=1,Type=Integer,Description=&#34;Caller method&#34;&gt;
##INFO=&lt;ID=SAMPLES,Number=.,Type=String,Description=&#34;Sample genotyped to have the variant&#34;&gt;
##ALT=&lt;ID=DEL,Description=&#34;Deletion&#34;&gt;
##ALT=&lt;ID=DUP,Description=&#34;Duplication&#34;&gt;
##ALT=&lt;ID=LOH,Description=&#34;Copy number neutral loss of heterozygosity&#34;&gt;
##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=&#34;Genotype&#34;&gt;;
##FORMAT=&lt;ID=CN,Number=1,Type=Integer,Description=&#34;Copy number genotype for imprecise events&#34;&gt;
#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\t{samples}&#34;&#34;&#34;
            if self.reference_genome:
                rg = self.reference_genome[&#34;name&#34;]
            else:
                rg = &#34;unknown&#34;
            header = header.format(date=datetime.date.today().strftime(&#34;%Y-%m-%d&#34;), rg=rg, samples=&#34;\t&#34;.join(samples))
            ii = 0
            with open(self.print_filename, &#39;w&#39;) as f:
                print(header, file=f)
                for call in calls:
                    ii += 1
                    id = &#34;CNVpytor_&#34; + {&#34;deletion&#34;: &#34;del&#34;, &#34;duplication&#34;: &#34;dup&#34;, &#34;cnnloh&#34;: &#34;loh&#34;}[call[2]] + str(ii)
                    alt = {&#34;deletion&#34;: &#34;&lt;DEL&gt;&#34;, &#34;duplication&#34;: &#34;&lt;DUP&gt;&#34;, &#34;cnnloh&#34;: &#34;&lt;LOH&gt;&#34;}[call[2]]
                    info = &#34;END=&#34; + str(int(call[5])) + &#34;;IMPRECISE;SVLEN=&#34; + str(int(call[6])) + &#34;;SVTYPE=&#34; + alt[1:4]
                    info += &#34;;pytorRD=&#34; + str(call[7])
                    info += &#34;;pytorP1=&#34; + str(call[8])
                    info += &#34;;pytorP2=&#34; + str(call[9])
                    info += &#34;;pytorP3=&#34; + str(call[10])
                    info += &#34;;pytorP4=&#34; + str(call[11])
                    info += &#34;;pytorQ0=&#34; + str(call[12])
                    info += &#34;;pytorPN=&#34; + str(call[13])
                    info += &#34;;pytorDG=&#34; + str(call[14])
                    info += &#34;;pytorCL=&#34; + call[1]
                    format = &#34;GT:CN&#34;
                    row = [call[3], int(call[4]), id, &#34;.&#34;, alt, &#34;.&#34;, &#34;PASS&#34;, info, format]
                    for sample in samples:
                        if sample == call[0]:
                            if call[2] == &#34;deletion&#34; and call[7] &lt; 0.25:
                                row.append(&#34;1/1:0&#34;)
                            elif call[2] == &#34;deletion&#34; and call[7] &gt; 0.25:
                                row.append(&#34;0/1:0&#34;)
                            elif call[2] == &#34;duplication&#34; and call[7] &lt;= 1.75:
                                row.append(&#34;0/1:2&#34;)
                            elif call[2] == &#34;duplication&#34; and call[7] &gt; 1.75 and call[7] &lt;= 2.25:
                                row.append(&#34;1/1:2&#34;)
                            elif call[2] == &#34;duplication&#34; and call[7] &gt; 2.25:
                                row.append(&#34;./1:%.2f&#34; % call[7])
                            else:
                                row.append(&#34;./.:.&#34;)
                        else:
                            row.append(&#34;./.:.&#34;)
                    print(*row, sep=&#34;\t&#34;, file=f)
        if self.plot:
            for call in calls:
                plot_start = call[4] - call[6]
                if plot_start &lt; 0:
                    plot_start = 0
                plot_end = call[5] + call[6]
                self.multiple_regions([&#34;%s:%d-%d&#34; % (c, plot_start, plot_end)])</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.print_simple_joint_calls"><code class="name flex">
<span>def <span class="ident">print_simple_joint_calls</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def print_simple_joint_calls(self):

    bin_size = self.bin_size
    n = len(self.plot_files)
    if n == 0:
        return
    ix = self.plot_files
    format = self.print_filename.split(&#34;.&#34;)[-1]
    if format == &#34;tsv&#34;:
        f = open(self.print_filename, &#39;w&#39;)
    elif format == &#34;xlsx&#34;:
        import xlsxwriter
        if os.path.exists(self.print_filename):
            os.remove(self.print_filename)
        workbook = xlsxwriter.Workbook(self.print_filename)
        sheet = workbook.add_worksheet(&#34;merged_calls&#34;)
        header = [&#34;TYPE&#34;, &#34;REGION&#34;, &#34;SIZE&#34;]
        for i in range(n):
            header.append(self.file_title(ix[i]))
        if self.annotate:
            header.append(&#34;GENES&#34;)
        styleh = workbook.add_format({&#39;bold&#39;: True, &#39;font_color&#39;: &#39;white&#39;})
        styleh.set_pattern(1)  # This is optional when using a solid fill.
        styleh.set_bg_color(&#39;#555555&#39;)
        styleh2 = workbook.add_format({&#39;bold&#39;: True, &#39;font_color&#39;: &#39;white&#39;})
        styleh2.set_pattern(1)  # This is optional when using a solid fill.
        styleh2.set_bg_color(&#39;#555555&#39;)
        styleh2.set_rotation(75)
        style_r = workbook.add_format()
        style_r.set_pattern(1)  # This is optional when using a solid fill.
        style_r.set_bg_color(&#39;red&#39;)
        style_g = workbook.add_format()
        style_g.set_pattern(1)  # This is optional when using a solid fill.
        style_g.set_bg_color(&#39;green&#39;)
        style_size = workbook.add_format({&#39;num_format&#39;: &#39;#,##0&#39;})
        style_cn = workbook.add_format({&#39;num_format&#39;: &#39;0&#39;})
        style_cn_b = workbook.add_format({&#39;num_format&#39;: &#39;0&#39;, &#39;bold&#39;: True})
        sheet.set_column(0, 0, 10)
        sheet.set_column(1, 1, 22)
        sheet.set_column(2, 2, 10)
        if self.annotate:
            sheet.set_column(len(header) - 1, len(header) - 1, 100)

        for col, val in enumerate(header):
            if col &gt; 2 and col &lt; len(header) - int(self.annotate):
                sheet.write(0, col, val, styleh2)
            else:
                sheet.write(0, col, val, styleh)
        ri = 0
    if self.annotate:
        annotator = Annotator(self.reference_genome)
    chroms = self.io[ix[0]].rd_chromosomes()
    for c in chroms:
        if (c in self.chrom) or len(self.chrom) == 0:
            flag = (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
            calls = [list(filter(lambda call: in_interval(call[&#34;size&#34;], self.size_range) \
                                              and in_interval(call[&#34;p_val&#34;], self.p_range) \
                                              and in_interval(call[&#34;pN&#34;], self.pN_range) \
                                              and in_interval(call[&#34;Q0&#34;], self.Q0_range) \
                                              and in_interval(call[&#34;dG&#34;], self.dG_range),
                                 self.io[ix[i]].read_calls(c, bin_size, &#34;calls&#34;, flag))) for i in range(n)]
            pointers = [0] * n
            while any([pointers[i] &lt; len(calls[i]) for i in range(n)]):
                starts = [calls[i][pointers[i]][&#34;start&#34;] if pointers[i] &lt; len(calls[i]) else np.inf for i in
                          range(n)]
                mini = starts.index(min(starts))
                maxend = 0
                toupdate = []
                minend = calls[mini][pointers[mini]][&#34;end&#34;]
                maxstart = 0
                files = []
                types = []
                cns = []
                for i in range(n):
                    if (pointers[i] &lt; len(calls[i])) and ((min(calls[i][pointers[i]][&#34;end&#34;],
                                                               calls[mini][pointers[mini]][&#34;end&#34;]) -
                                                           calls[i][pointers[i]][&#34;start&#34;]) &gt; (
                                                                  0.5 * calls[mini][pointers[mini]][&#34;size&#34;])) \
                            and ((min(calls[i][pointers[i]][&#34;end&#34;],
                                      calls[mini][pointers[mini]][&#34;end&#34;]) -
                                  calls[i][pointers[i]][&#34;start&#34;]) &gt; (
                                         0.5 * (calls[i][pointers[i]][&#34;end&#34;] - calls[i][pointers[i]][&#34;start&#34;]))):
                        toupdate.append(i)
                        call = calls[i][pointers[i]]
                        if call[&#34;end&#34;] &gt; maxend:
                            maxend = call[&#34;end&#34;]
                        if call[&#34;end&#34;] &lt; minend:
                            minend = call[&#34;end&#34;]
                        if call[&#34;start&#34;] &gt; maxstart:
                            maxstart = call[&#34;start&#34;]
                        type = &#34;duplication&#34; if call[&#34;type&#34;] == 1 else &#34;deletion&#34;
                        types.append(type)
                        files.append(i)
                        cns.append(int(call[&#34;cnv&#34;] * 2))
                type = max(set(types), key=types.count)
                data = [type, c, maxstart, minend, minend - maxstart + 1]
                genotypes = [
                    self.genotype([bin_size], &#34;%s:%d-%d&#34; % (c, maxstart, minend), file_index=ix[i], p_val=True)[0]
                    for i
                    in range(n)]
                copynumbers = [c[3] for c in genotypes]
                if np.all([np.abs(c - np.round(c)) &lt; 0.25 for c in copynumbers]) or True:
                    if self.print_filename == &#34;&#34;:
                        print((&#34;%s\t%s:%d-%d\t%d&#34; + n * &#34;\t%.2f&#34;) % tuple(data + copynumbers), end=&#34;&#34;)
                        print(&#34;\t%s&#34; % str(files), end=&#34;&#34;)
                        if self.annotate:
                            print(&#34;\t%s&#34; % annotator.get_info(&#34;%s:%d-%d&#34; % (c, maxstart, minend)))
                        else:
                            print()
                    elif format == &#34;tsv&#34;:
                        print((&#34;%s\t%s:%d-%d\t%d&#34; + n * &#34;\t%.2f&#34;) % tuple(data + copynumbers), end=&#34;&#34;, file=f)
                        print(&#34;\t%s&#34; % str(files), end=&#34;&#34;, file=f)
                        if self.annotate:
                            print(&#34;\t%s&#34; % annotator.get_info(&#34;%s:%d-%d&#34; % (c, maxstart, minend)), file=f)
                        else:
                            print(file=f)
                    elif format == &#34;xlsx&#34;:
                        ri += 1
                        if type == &#34;deletion&#34;:
                            sheet.write(ri, 0, data[0], style_r)
                        else:
                            sheet.write(ri, 0, data[0], style_g)
                        sheet.write(ri, 1, &#34;%s:%d-%d&#34; % (c, maxstart, minend))
                        sheet.write(ri, 2, data[4], style_size)
                        for col, val in enumerate(copynumbers):
                            if col in files:
                                sheet.write(ri, 3 + col, val, style_cn_b)
                            else:
                                sheet.write(ri, 3 + col, val, style_cn)
                        if self.annotate:
                            sheet.write(ri, 3 + len(copynumbers),
                                        annotator.get_info(&#34;%s:%d-%d&#34; % (c, maxstart, minend)))

                    if self.plot:
                        plot_start = maxstart - (minend - maxstart)
                        if plot_start &lt; 0:
                            plot_start = 0
                        plot_end = minend + (minend - maxstart)
                        self.multiple_regions([&#34;%s:%d-%d&#34; % (c, plot_start, plot_end)])
                for i in toupdate:
                    pointers[i] += 1
    if format == &#34;tsv&#34;:
        f.close()
    elif format == &#34;xlsx&#34;:
        sheet.conditional_format(1, 3, ri, len(header) - int(self.annotate), {&#39;type&#39;: &#39;3_color_scale&#39;,
                                                                              &#39;min_color&#39;: &#34;#FF0000&#34;,
                                                                              &#39;mid_color&#39;: &#34;#FFFFFF&#34;,
                                                                              &#39;max_color&#39;: &#34;#00FF00&#34;,
                                                                              &#39;min_type&#39;: &#39;num&#39;,
                                                                              &#39;min_value&#39;: 0,
                                                                              &#39;mid_type&#39;: &#39;num&#39;,
                                                                              &#39;mid_value&#39;: 2,
                                                                              &#39;max_type&#39;: &#39;num&#39;,
                                                                              &#39;max_value&#39;: 4
                                                                              })
        workbook.close()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.prompt"><code class="name flex">
<span>def <span class="ident">prompt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def prompt(self):
    self.interactive = True

    chromosomes = set({})
    for f in self.io:
        chromosomes = chromosomes.union(set(f.rd_chromosomes()))
        chromosomes = chromosomes.union(set(f.snp_chromosomes()))
    for c in chromosomes:
        self.command_tree[c] = None
    self.command_tree[&#34;set&#34;][&#34;style&#34;] = dict(zip(plt.style.available, [None] * len(plt.style.available)))
    if os.path.exists(self.cnvpytor_dir+&#34;/history&#34;):
        readline.read_history_file(self.cnvpytor_dir+&#34;/history&#34;)

    readline.parse_and_bind(&#34;tab: complete&#34;)
    completer = PromptCompleter(self.command_tree)
    readline.set_completer(completer.complete)
    quit = False
    try:
        while not quit:
            prompt_str = &#34;&#34;
            if os.isatty(sys.stdin.fileno()):
                prompt_str = &#34;cnvpytor&gt; &#34;
            else:
                self.interactive = False
            try:
                line = raw_input(prompt_str)
            except NameError:
                line = input(prompt_str)

            if line[0] == &#34;#&#34; or line[0] == &#34;&#34;:
                continue

            if self.save_history and self.interactive:
                readline.set_history_length(self.history_file_size)
                readline.write_history_file(self.cnvpytor_dir+&#34;/history&#34;)

            pre = line.split(&#34;&gt;&#34;)
            f = pre[0].strip().split(&#34; &#34;)
            n = len(f)
            if len(line) == 0:
                continue
            elif f[0] == &#34;quit&#34; or f[0] == &#34;exit&#34;:
                quit = True
            elif line[0] == &#34;|&#34;:
                try:
                    eval(compile(line[1:], &#39;&lt;string&gt;&#39;, &#39;single&#39;))
                except Exception as e:
                    print(traceback.format_exc())
            elif f[0] == &#34;save&#34;:
                if n &gt; 1:
                    try:
                        plt.savefig(f[1])
                    except ValueError:
                        _logger.warning(&#34;File extension should be: .jpg, .png, .svg, .eps or .pdf&#34;)
                    except:
                        _logger.warning(&#34;Figure is not saved due to an error!&#34;)

            elif f[0] in [&#34;draw&#34;, &#34;repaint&#34;, &#34;update&#34;]:
                if n == 1:
                    self.fig.canvas.draw()
            elif f[0] == &#34;ls&#34;:
                self.ls()
            elif f[0] == &#34;meta&#34;:
                self.meta()
            elif f[0] == &#34;show&#34;:
                if n == 1:
                    self.show()
            elif f[0] == &#34;set&#34;:
                if n &gt; 1:
                    self.set(f[1], f[2:])
            elif f[0] == &#34;help&#34; and n &gt; 1:
                self.help(f[1])
            elif f[0] == &#34;help&#34; and n == 1:
                self.help(&#34;help&#34;)
            elif f[0] == &#34;unset&#34;:
                if n &gt; 1:
                    self.unset(f[1])
            elif f[0] == &#34;genotype&#34;:
                if n &gt; 1:
                    self.genotype_all([self.bin_size], f[1:], interactive=True)
            elif f[0] == &#34;snv&#34;:
                if n == 2:
                    self.snp(callset=f[1])
                elif n == 1:
                    self.snp(callset=&#34;default&#34;)
            elif f[0] == &#34;compare&#34;:
                if n == 3:
                    self.compare(f[1], f[2], plot=self.plot)
                elif n == 4:
                    self.compare(f[1], f[2], n_bins=int(f[3]), plot=self.plot)
            elif f[0] == &#34;info&#34;:
                if n &gt; 1:
                    self.info(list(map(binsize_type, f[1:])))
            elif f[0] == &#34;print&#34;:
                if f[1] == &#34;calls&#34;:
                    if self.print_filename == &#34;&#34;:
                        self.print_calls()
                    else:
                        self.print_calls_file()
                elif f[1] == &#34;joint_calls&#34;:
                    self.print_simple_joint_calls()

            else:
                try:
                    if f[0] not in [&#34;rdstat&#34;, &#34;snp&#34;]:
                        self.parse(f + [str(self.bin_size)])
                    else:
                        self.parse(f)
                    if len(pre) &gt; 1:
                        fns = pre[1].strip().split(&#34; &#34;)
                        if fns[0] != &#34;&#34;:
                            plt.savefig(fns[0], dpi=200)
                except Exception as e:
                    print(traceback.format_exc())
    except (EOFError, KeyboardInterrupt):
        print()
        return</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.rd"><code class="name flex">
<span>def <span class="ident">rd</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rd(self):
    bin_size = self.bin_size
    if self.reference_genome is None:
        _logger.warning(&#34;Missing reference genome required for gview.&#34;)
        return
    chroms = []
    for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
        rd_chr = self.io[self.plot_file].rd_chromosome_name(c)
        if self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
            chroms.append((rd_chr, l))
    self.new_figure(panel_count=len(chroms))
    for c, l in chroms:
        flag_rd = FLAG_USEMASK if self.rd_use_mask else 0
        mean, stdev = self.io[self.plot_file].rd_normal_level(bin_size, flag_rd | FLAG_GC_CORR)
        his_p = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
        his_p_corr = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
        his_p_seg = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD partition&#34;, flag_rd | FLAG_GC_CORR)
        his_p_call = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
        his_p_mosaic_seg = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                              flag_rd | FLAG_GC_CORR)
        his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
        his_p_mosaic_call = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                               flag_rd | FLAG_GC_CORR)
        his_p_mosaic_seg_2d = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic segments 2d&#34;,
                                                                 flag_rd | FLAG_GC_CORR)
        his_p_mosaic_seg_2d = segments_decode(his_p_mosaic_seg_2d)
        his_p_mosaic_call_2d = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic call 2d&#34;,
                                                                  flag_rd | FLAG_GC_CORR)
        his_p_mosaic = np.zeros_like(his_p) * np.nan
        if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call and (
                &#34;rd_mosaic&#34; in self.callers):
            for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                for segi in seg:
                    his_p_mosaic[segi] = lev
        his_p_mosaic_2d = np.zeros_like(his_p) * np.nan
        if his_p_mosaic_call_2d is not None and len(his_p_mosaic_call_2d) &gt; 0 and self.rd_call and (
                &#34;combined_mosaic&#34; in self.callers):
            for seg, lev in zip(list(his_p_mosaic_seg_2d), list(his_p_mosaic_call_2d[0])):
                for segi in seg:
                    his_p_mosaic_2d[segi] = lev
        ax = self.next_panel()
        ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                     color=&#39;C0&#39;)
        ax.xaxis.set_ticklabels([])
        ax.yaxis.set_ticklabels([])
        ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // bin_size, 10e6 // bin_size), minor=[])
        if (self.rd_range[1] - self.rd_range[0]) &lt; 30:
            ax.yaxis.set_ticks(np.arange(int(self.rd_range[0]), int(self.rd_range[1] + 1), 1) * mean / 2,
                               minor=[])
        ax.set_ylim([self.rd_range[0] * mean / 2, self.rd_range[1] * mean / 2])
        n_bins = l // bin_size
        ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
        ax.grid()
        if self.rd_raw:
            plt.step(his_p, self.rd_colors[0])
        if self.rd_corrected:
            plt.step(his_p_corr, self.rd_colors[1])
        if his_p_seg is not None and len(his_p_seg) &gt; 0 and self.rd_partition:
            plt.step(his_p_seg, self.rd_colors[2])
        if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call:
            plt.step(his_p_call, self.rd_colors[3])
        if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call and (
                &#34;rd_mosaic&#34; in self.callers):
            plt.step(his_p_mosaic, self.rd_colors[4])
        if his_p_mosaic_call_2d is not None and len(his_p_mosaic_call_2d) &gt; 0 and self.rd_call and (
                &#34;combined_mosaic&#34; in self.callers):
            plt.step(his_p_mosaic_2d, self.rd_colors[5])
    self.fig_show(suffix=&#34;rd&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.rd_baf"><code class="name flex">
<span>def <span class="ident">rd_baf</span></span>(<span>self, hist=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rd_baf(self, hist=True):
    plt.clf()
    plt.rcParams[&#34;font.size&#34;] = 8
    self.fig = plt.figure(1, figsize=(12, 8), facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    n = len(self.plot_files)
    ix = self.plot_files
    if self.grid == &#34;auto&#34;:
        sx, sy = self._panels_shape(n)
    else:
        sx, sy = tuple(self.grid)
    grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
    bin_size = self.bin_size
    for i in range(n):
        ax = self.fig.add_subplot(grid[i])
        io = self.io[ix[i]]

        chroms = []
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0)
        rd_flag = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            snp_chr = io.snp_chromosome_name(c)
            if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                if io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood call&#34;, snp_flag) and \
                        io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood segments&#34;, snp_flag) and \
                        io.signal_exists(snp_chr, bin_size, &#34;RD mosaic call&#34;, rd_flag) and \
                        io.signal_exists(snp_chr, bin_size, &#34;RD mosaic segments&#34;, rd_flag) and \
                        Genome.is_autosome(c):
                    chroms.append((snp_chr, l))
        x = []
        y = []
        for c, l in chroms:
            flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO

            likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
            segments_baf = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
            rd = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;, rd_flag)
            segments_rd = segments_decode(io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;, rd_flag))

            mbaf = {}
            mrd = {}
            for s, lh in zip(segments_baf, likelihood):
                b, p = likelihood_baf_pval(lh)
                for pos in s:
                    mbaf[pos] = 0.5 - b
            for s, r in zip(segments_rd, rd[0]):
                for pos in s:
                    mrd[pos] = r
            for p in mbaf:
                if p in mrd:
                    x.append(mbaf[p])
                    y.append(mrd[p])

        if hist:
            from matplotlib.colors import LogNorm
            ax.hist2d(x, y, bins=[np.arange(0, 0.51, 0.01), np.arange(0, max(y), max(y) / 100.)], norm=LogNorm())
        else:
            ax.scatter(x, y, marker=&#34;.&#34;, alpha=0.5)

    if self.output_filename != &#34;&#34;:
        plt.savefig(self._image_filename(&#34;rd_baf&#34;), dpi=150)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.rd_baf_call_models"><code class="name flex">
<span>def <span class="ident">rd_baf_call_models</span></span>(<span>self, maxcn=10)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rd_baf_call_models(self, maxcn=10):
    bin_size = self.bin_size
    n = len(self.plot_files)
    ix = self.plot_files
    self.new_figure(panel_count=n)

    for i in range(n):
        ax = self.next_panel()
        io = self.io[ix[i]]
        ax.set_title(self.file_title(ix[i]), position=(0.1, 0.1),
                     fontdict={&#39;verticalalignment&#39;: &#39;bottom&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})

        chroms = []
        flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
            FLAG_USEHAP if self.snp_use_phase else 0) | (FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR

        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            snp_chr = io.snp_chromosome_name(c)
            if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                if (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                    chroms.append((snp_chr, l))

        x = np.linspace(0, 1, 1000)
        master_lh = {}
        for cn in range(maxcn, -1, -1):
            for h1 in range(cn // 2 + 1):
                h2 = cn - h1
                mrd = 2 - 2 * x + x * cn
                np.seterr(divide=&#39;ignore&#39;)
                mbaf = 0.5 - (1 - x + x * h1) / (2 - 2 * x + (h1 + h2) * x)
                plt.plot(mbaf, mrd, &#34;-&#34;, label=&#34;%d: %d/%d&#34; % (cn, h1, h2), zorder=6 - cn)

        cix = 0
        cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
        for c, l in chroms:
            call_rd = []
            call_baf = []
            call_label = []
            if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)

                for call in calls:
                    if call[&#34;bins&#34;] &gt; self.min_segment_size:
                        call_rd.append(call[&#34;cnv&#34;] * 2)
                        call_baf.append(call[&#34;baf&#34;])
                        call_label.append(c + &#34;:&#34; + str(call[&#34;start&#34;]) + &#34;-&#34; + str(call[&#34;end&#34;]))

            plt.scatter(call_baf, call_rd, s=20, edgecolors=&#39;face&#39;, marker=&#39;.&#39;)
            cix += 1

        ax.set_xlabel(&#34;|Î”BAF|&#34;)
        ax.set_ylabel(&#34;Relative RD level&#34;)

        ax.legend()

        ax.set_ylim([0, maxcn])
        ax.set_xlim([-0.02, 0.5])
        ax.grid()

    self.fig_show(suffix=&#34;models&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.rd_diff"><code class="name flex">
<span>def <span class="ident">rd_diff</span></span>(<span>self, file1, file2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rd_diff(self, file1, file2):
    bin_size = self.bin_size
    if self.reference_genome is None:
        _logger.warning(&#34;Missing reference genome required for gview.&#34;)
        return
    chroms = []
    for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
        rd_chr = self.io[self.plot_file].rd_chromosome_name(c)
        if self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
            chroms.append((rd_chr, l))
    self.new_figure(panel_count=len(chroms))
    for c, l in chroms:
        flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
        stat1 = self.io[file1].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
        stat2 = self.io[file2].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
        if stat1 is None:
            _logger.error(
                &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[file1].filename))
            return
        if stat2 is None:
            _logger.error(
                &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[file2].filename))
            return
        flag_rd = (FLAG_USEMASK if self.rd_use_mask else 0)
        his_p_corr1 = self.io[file1].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
        his_p_corr2 = self.io[file2].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
        ax = self.next_panel()
        ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                     color=&#39;C0&#39;)
        ax.xaxis.set_ticklabels([])
        ax.yaxis.set_ticklabels([])
        if (self.rd_range[1] - self.rd_range[0]) &lt; 30:
            ax.yaxis.set_ticks(np.arange(int(self.rd_range[0]), int(self.rd_range[1] + 1), 1) * mean / 2,
                               minor=[])
        ax.yaxis.set_ticks(np.arange(0, 2, 0.25), minor=[])
        ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // bin_size, 10e6 // bin_size), minor=[])
        ax.set_ylim([0, 1])
        n_bins = l // bin_size
        ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
        ax.grid()

        plt.step(np.abs(his_p_corr1 / stat1[4] - his_p_corr2 / stat2[4]), &#34;k&#34;)
    self.fig_show(suffix=&#34;rd_diff&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.region_rd_stat"><code class="name flex">
<span>def <span class="ident">region_rd_stat</span></span>(<span>self, region, n_bins=21, plot=False, legend=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def region_rd_stat(self, region, n_bins=21, plot=False, legend=True):
    n = len(self.plot_files)
    ix = self.plot_files
    if plot:
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        if self.grid == &#34;auto&#34;:
            sx, sy = self._panels_shape(n)
        else:
            sx, sy = tuple(self.grid)
        self.fig = plt.figure(1, dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(3 * sy)
            self.fig.set_figwidth(4 * sx)
        grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
    for i in range(n):
        io = self.io[ix[i]]
        if plot:
            ax = self.fig.add_subplot(grid[i])
            ax.set_title(self.file_title(ix[i]), position=(0.01, 1.07),
                         fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
        regs = decode_region(region)
        data = []
        for c, (pos1, pos2) in regs:
            flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
            his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
            bin1 = (pos1 - 1) // self.bin_size
            bin2 = (pos2 - 1) // self.bin_size
            data += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])

        data = np.array(data)
        dmin = np.min(data)
        dmax = np.max(data)
        p1 = np.percentile(data, 1)
        p99 = np.percentile(data, 99)
        data = data[data &gt; p1]
        data = data[data &lt; p99]
        mean = np.mean(data)
        std = np.std(data)

        rd_min = mean - 5 * std
        rd_max = mean + 5 * std
        bins = np.linspace(rd_min, rd_max, n_bins)

        hist, binsr = np.histogram(data, bins=bins)

        fitn, fitm, fits = fit_normal(bins[:-1], hist)[0]

        print(&#34;%s\t%s\t%.4f\t%.4f\t%e\t%e\t%.4f\t%.4f\t%.4f\t%.4f&#34; % (
            io.filename, region, fitm, fits, dmin, dmax, p1, p99, mean, std))

        if plot:
            x = np.linspace(bins[0], bins[-1], 1001)
            plt.plot(x, normal(x, fitn, fitm, fits), &#34;g-&#34;, label=region)
            plt.plot(bins[:-1], hist, &#34;b*&#34;)
            if legend:
                plt.legend()

    if plot:
        if self.output_filename != &#34;&#34;:
            plt.savefig(self._image_filename(&#34;comp&#34;), dpi=200)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.regions"><code class="name flex">
<span>def <span class="ident">regions</span></span>(<span>self, ix, region)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def regions(self, ix, region):
    panels = self.panels
    bin_size = self.bin_size
    snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
        FLAG_USEHAP if self.snp_use_phase else 0)
    self.new_subgrid(len(panels), hspace=0.05, wspace=0.1)
    r = decode_region(region, max_size=1000000000)
    io = self.io[ix]
    for i in range(len(panels)):
        ax = self.next_subpanel(sharex=True)
        if i == 0 and self.title:
            ax.set_title(self.file_title(ix) + &#34;: &#34; + region, position=(0.01, 0.9),
                         fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)

        if panels[i] == &#34;rd&#34;:
            g_p = [0]
            g_p_corr = [0]
            g_p_seg = [0]
            g_p_call = [0]
            g_p_call_mosaic = [0]
            g_p_call_mosaic_2d = [0]
            mean, stdev = 0, 0
            borders = []
            pos_x = []
            for c, (pos1, pos2) in r:
                if pos2 == 1000000000:
                    pos2 = io.get_chromosome_length(c)
                    if pos2 is None:
                        pos2 = 1000000000
                flag_rd = 0
                if self.rd_use_mask:
                    flag_rd = FLAG_USEMASK
                mean, stdev = io.rd_normal_level(bin_size, flag_rd | FLAG_GC_CORR)
                his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                his_p_corr = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
                his_p_seg = io.get_signal(c, bin_size, &#34;RD partition&#34;, flag_rd | FLAG_GC_CORR)
                his_p_call = io.get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
                his_p_mosaic_seg = io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                 flag_rd | FLAG_GC_CORR)
                his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
                his_p_mosaic_call = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                  flag_rd | FLAG_GC_CORR)
                his_p_mosaic_seg_2d = io.get_signal(c, bin_size, &#34;RD mosaic segments 2d&#34;,
                                                    flag_rd | FLAG_GC_CORR)
                his_p_mosaic_seg_2d = segments_decode(his_p_mosaic_seg_2d)
                his_p_mosaic_call_2d = io.get_signal(c, bin_size, &#34;RD mosaic call 2d&#34;,
                                                     flag_rd | FLAG_GC_CORR)
                his_p_mosaic = np.zeros_like(his_p) * np.nan
                if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and (&#34;rd_mosaic&#34; in self.callers):
                    for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                        for segi in seg:
                            his_p_mosaic[segi] = lev
                his_p_mosaic_2d = np.zeros_like(his_p) * np.nan
                if his_p_mosaic_call_2d is not None and len(his_p_mosaic_call_2d) &gt; 0 and (
                        &#34;combined_mosaic&#34; in self.callers):
                    for seg, lev in zip(list(his_p_mosaic_seg_2d), list(his_p_mosaic_call_2d[0])):
                        for segi in seg:
                            his_p_mosaic_2d[segi] = lev
                start_bin = (pos1 - 1) // bin_size
                end_bin = pos2 // bin_size
                bins = len(list(his_p[start_bin:end_bin]))
                pos_x.extend(range(pos1, pos2 + bin_size, bin_size)[0:bins])

                g_p.extend(list(his_p[start_bin:end_bin]))
                g_p_corr.extend(list(his_p_corr[start_bin:end_bin]))
                if his_p_seg is not None and len(his_p_seg) &gt; 0 and self.rd_partition:
                    g_p_seg.extend(list(his_p_seg[start_bin:end_bin]))
                if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call and (
                        &#34;rd_mean_shift&#34; in self.callers):
                    g_p_call.extend(list(his_p_call[start_bin:end_bin]))
                if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call and (
                        &#34;rd_mosaic&#34; in self.callers):
                    g_p_call_mosaic.extend(list(his_p_mosaic[start_bin:end_bin]))
                if his_p_mosaic_call_2d is not None and len(his_p_mosaic_call_2d) &gt; 0 and self.rd_call and (
                        &#34;combined_mosaic&#34; in self.callers):
                    g_p_call_mosaic_2d.extend(list(his_p_mosaic_2d[start_bin:end_bin]))
                borders.append(len(g_p) - 1)

            def format_func(value, tick_number):
                ix = int(value)
                if ix + 1 &lt; len(pos_x):
                    p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                    return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                elif ix &lt; len(pos_x):
                    p = pos_x[ix]
                    return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                else:
                    return &#34;&#34;

            l = len(g_p)
            if i == len(panels) - 1:
                ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                ax.xaxis.grid()
            else:
                plt.setp(ax.get_xticklabels(), visible=False)

            if (self.rd_range[1] - self.rd_range[0]) &lt; 30:
                ax.yaxis.set_ticks(np.arange(int(self.rd_range[0]), int(self.rd_range[1] + 1), 1) * mean / 2,
                                   minor=[])
                ax.yaxis.set_ticklabels([str(i) for i in range(int(self.rd_range[0]), int(self.rd_range[1] + 1))])
            ax.set_ylim([self.rd_range[0] * mean / 2, self.rd_range[1] * mean / 2])
            ax.set_ylabel(&#34;Read depth&#34;)
            ax.yaxis.grid()

            if self.rd_raw:
                ax.step(g_p, self.rd_colors[0], label=&#34;raw&#34;)
            if self.rd_corrected:
                ax.step(g_p_corr, self.rd_colors[1], label=&#34;GC corrected&#34;)
            if len(g_p_seg) &gt; 1:
                plt.step(g_p_seg, self.rd_colors[2], label=&#34;partitioning&#34;)
            if len(g_p_call) &gt; 1:
                plt.step(g_p_call, self.rd_colors[3], label=&#34;cnv calls&#34;)
            if len(g_p_call_mosaic) &gt; 1:
                plt.step(g_p_call_mosaic, self.rd_colors[4], label=&#34;mosaic cnv calls&#34;)
            if len(g_p_call_mosaic_2d) &gt; 1:
                plt.step(g_p_call_mosaic_2d, self.rd_colors[5], label=&#34;combined cnv calls&#34;)
            for i in borders[:-1]:
                ax.axvline(i, color=&#34;g&#34;, lw=1)
            if self.legend:
                ax.legend(loc=&#39;upper center&#39;, bbox_to_anchor=(0.5, -0.05), shadow=True, ncol=2)
            self.fig.add_subplot(ax)

        elif panels[i] == &#34;snp&#34;:
            borders = []
            hpos = []
            baf = []
            color = []
            alpha = 0.7
            start_pos = 0
            pos_x = []
            for c, (pos1, pos2) in r:
                if pos2 == 1000000000:
                    pos2 = io.get_chromosome_length(c)
                    if pos2 is None:
                        pos2 = 1000000000
                pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c)
                ix = 0
                mdp = 0
                while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                    if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0 and ((not self.snp_use_id) or (flag[ix] &amp; 1)):
                        hpos.append((start_pos + pos[ix] - pos1) / bin_size)
                        if pos[ix] - pos1 &gt; mdp:
                            mdp = pos[ix] - pos1
                        if gt[ix] % 4 != 2:
                            baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                        else:
                            baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                        if self.snp_alpha_P:
                            alpha = None
                            color.append(
                                colors.to_rgba(self.snp_colors[(gt[ix] % 4) * 2 + 1], (flag[ix] &gt;&gt; 1) * 0.4))
                        else:
                            color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                    ix += 1
                start_pos += pos2 - pos1
                pos_x.extend(range(pos1, pos2 + bin_size, bin_size))
                borders.append(start_pos / bin_size)

            def format_func(value, tick_number):
                ix = int(value)
                if ix + 1 &lt; len(pos_x):
                    p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                    return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                elif ix &lt; len(pos_x):
                    p = pos_x[ix]
                    return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                else:
                    return &#34;&#34;

            l = len(pos_x)
            if i == len(panels) - 1:
                ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                ax.xaxis.grid()
            else:
                plt.setp(ax.get_xticklabels(), visible=False)

            # ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
            ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
            ax.set_ylabel(&#34;Allele frequency&#34;)
            l = max(hpos)
            ax.set_ylim([-0.05, 1.05])
            # ax.set_xlim([0, borders[-1]])
            ax.yaxis.grid()
            if self.markersize == &#34;auto&#34;:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=alpha)
            else:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=alpha)

            for i in borders[:-1]:
                ax.axvline(i, color=&#34;g&#34;, lw=1)
            self.fig.add_subplot(ax)

        elif panels[i] == &#34;snv&#34; or panels[i][:4] == &#34;snv:&#34;:
            callset = &#34;default&#34;
            if panels[i][:4] == &#34;snv:&#34;:
                callset = panels[i].split(&#34;:&#34;)[1]
            borders = []
            hpos = []
            baf = []
            color = []
            alpha = 0.7
            start_pos = 0
            pos_x = []
            for c, (pos1, pos2) in r:
                if pos2 == 1000000000:
                    pos2 = io.get_chromosome_length(c)
                    if pos2 is None:
                        pos2 = 1000000000
                pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c, callset=callset)
                ix = 0
                mdp = 0
                while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                    if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0:
                        hpos.append((start_pos + pos[ix] - pos1) / bin_size)
                        if pos[ix] - pos1 &gt; mdp:
                            mdp = pos[ix] - pos1
                        if gt[ix] % 4 != 2:
                            baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                        else:
                            baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                        if self.snp_alpha_P:
                            alpha = None
                            color.append(
                                colors.to_rgba(self.snp_colors[(gt[ix] % 4) * 2 + 1], (flag[ix] &gt;&gt; 1) * 0.4))
                        else:
                            color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                    ix += 1
                start_pos += pos2 - pos1
                pos_x.extend(range(pos1, pos2 + bin_size, bin_size))
                borders.append(start_pos / bin_size)

            def format_func(value, tick_number):
                ix = int(value)
                if ix + 1 &lt; len(pos_x):
                    p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                    return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                elif ix &lt; len(pos_x):
                    p = pos_x[ix]
                    return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                else:
                    return &#34;&#34;

            l = len(pos_x)
            if i == len(panels) - 1:
                ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
            else:
                plt.setp(ax.get_xticklabels(), visible=False)
            ax.xaxis.grid()
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
            ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
            ax.set_ylabel(&#34;Allele frequency&#34;)
            ax.set_ylim([0., 1.])
            ax.yaxis.grid()
            if self.markersize == &#34;auto&#34;:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=alpha)
            else:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=alpha)

            for i in borders[:-1]:
                ax.axvline(i, color=&#34;g&#34;, lw=1)
            self.fig.add_subplot(ax)

        elif panels[i] == &#34;baf&#34;:
            g_baf, g_maf, g_i1, g_i2 = [0], [0], [0], [0]
            borders = []
            pos_x = []

            for c, (pos1, pos2) in r:
                if pos2 == 1000000000:
                    pos2 = io.get_chromosome_length(c)
                    if pos2 is None:
                        pos2 = 1000000000

                flag_snp = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                    FLAG_USEHAP if self.snp_use_phase else 0)
                baf = io.get_signal(c, bin_size, &#34;SNP baf&#34;, flag_snp)
                maf = io.get_signal(c, bin_size, &#34;SNP maf&#34;, flag_snp)
                i1 = io.get_signal(c, bin_size, &#34;SNP i1&#34;, flag_snp)
                i2 = io.get_signal(c, bin_size, &#34;SNP i2&#34;, flag_snp)

                start_bin = (pos1 - 1) // bin_size
                end_bin = pos2 // bin_size
                bins = len(list(baf[start_bin:end_bin]))
                pos_x.extend(range(pos1, pos2 + bin_size, bin_size)[0:bins])

                g_baf.extend(list(baf[start_bin:end_bin]))
                g_maf.extend(list(maf[start_bin:end_bin]))
                g_i1.extend(list(i1[start_bin:end_bin]))
                g_i2.extend(list(i2[start_bin:end_bin]))
                borders.append(len(g_baf) - 1)

            def format_func(value, tick_number):
                ix = int(value)
                if ix + 1 &lt; len(pos_x):
                    p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                    return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                elif ix &lt; len(pos_x):
                    p = pos_x[ix]
                    return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                else:
                    return &#34;&#34;

            l = len(g_baf)
            if i == len(panels) - 1:
                ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                ax.xaxis.grid()

            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
            ax.yaxis.set_ticklabels([&#34;0&#34;, &#34;1/4&#34;, &#34;1/2&#34;, &#34;3/4&#34;, &#34;1&#34;])
            ax.set_ylabel(&#34;Allele frequency&#34;)

            ax.set_ylim([0, 1])
            # ax.set_xlim([-l * 0.0, l * 1.0])

            ax.yaxis.grid()
            # ax.xaxis.grid()
            ax.step(g_baf, self.baf_colors[0], label=&#34;BAF&#34;)
            ax.step(g_maf, self.baf_colors[1], label=&#34;MAF&#34;)
            ax.step(g_i1, self.baf_colors[2], label=&#34;I1&#34;)
            if self.legend:
                ax.legend()
            for i in borders[:-1]:
                ax.axvline(i, color=&#34;g&#34;, lw=1)
            self.fig.add_subplot(ax)

        elif panels[i] == &#34;likelihood&#34;:
            borders = []
            gl = []
            call_pos = []
            call_i1 = []
            call_i2 = []
            call_c = []
            call_pos_2d = []
            call_i1_2d = []
            call_i2_2d = []
            call_c_2d = []
            tlen = 0
            tlen_2d = 0
            pos_x = []
            for c, (pos1, pos2) in r:
                if pos2 == 1000000000:
                    pos2 = io.get_chromosome_length(c)
                    if pos2 is None:
                        pos2 = 1000000000
                likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
                start_bin = (pos1 - 1) // bin_size
                end_bin = pos2 // bin_size
                bins = len(list(likelihood[start_bin:end_bin]))
                pos_x.extend(range(pos1, pos2 + bin_size, bin_size)[0:bins])
                gl.extend(list(likelihood[start_bin:end_bin]))
                borders.append(len(gl) - 1)
                if self.snp_call and (&#34;baf_mosaic&#34; in self.callers):
                    likelihood_call = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                    segments = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))

                    for s, lh in zip(segments, likelihood_call):
                        i1, i2, p = likelihood_pixels_pval(lh)
                        if i1 != i2 and len(s) &gt; self.min_segment_size:
                            alpha = -np.log(p + 1e-40) / self.contrast
                            if alpha &gt; 1:
                                alpha = 1
                            for pos in s:
                                if pos &gt;= start_bin and pos &lt; end_bin:
                                    call_pos.append(pos - start_bin + tlen)
                                    call_i1.append(min(i1, i2))
                                    call_i2.append(max(i1, i2))
                                    color = colors.to_rgb(self.lh_colors[0]) + (alpha,)
                                    call_c.append(color)
                    tlen += end_bin - start_bin
                if self.snp_call and (&#34;combined_mosaic&#34; in self.callers):
                    likelihood_call = io.get_signal(c, bin_size, &#34;SNP likelihood call 2d&#34;, snp_flag)
                    segments = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments 2d&#34;, snp_flag))

                    for s, lh in zip(segments, likelihood_call):
                        i1, i2, p = likelihood_pixels_pval(lh)
                        if i1 != i2 and len(s) &gt; self.min_segment_size:
                            alpha = -np.log(p + 1e-40) / self.contrast
                            if alpha &gt; 1:
                                alpha = 1
                            for pos in s:
                                if pos &gt;= start_bin and pos &lt; end_bin:
                                    call_pos_2d.append(pos - start_bin + tlen_2d)
                                    call_i1_2d.append(min(i1, i2))
                                    call_i2_2d.append(max(i1, i2))
                                    color = colors.to_rgb(self.lh_colors[1]) + (alpha,)
                                    call_c_2d.append(color)
                    tlen_2d += end_bin - start_bin

            def format_func(value, tick_number):
                ix = int(value)
                if ix + 1 &lt; len(pos_x):
                    p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                    return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                elif ix &lt; len(pos_x):
                    p = pos_x[ix]
                    return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                else:
                    return &#34;&#34;

            img = np.array(gl).transpose()
            l = img.shape[1]
            if i == len(panels) - 1:
                ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                # ax.xaxis.grid()
            else:
                plt.setp(ax.get_xticklabels(), visible=False)

            ax.imshow(img, aspect=&#39;auto&#39;)
            # ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticks([0, img.shape[0] / 4, img.shape[0] / 2, 3 * img.shape[0] / 4, img.shape[0] - 1],
                               minor=[])
            ax.yaxis.set_ticklabels([&#34;1&#34;, &#34;3/4&#34;, &#34;1/2&#34;, &#34;1/4&#34;, &#34;0&#34;])
            ax.set_ylabel(&#34;Allele frequency&#34;)
            # ax.xaxis.set_ticks(np.arange(0, len(gl), 50), minor=[])
            # ax.set_xlim([-0.5, img.shape[1] - 0.5])
            if self.snp_call and (&#34;baf_mosaic&#34; in self.callers):
                plt.scatter(call_pos, call_i1, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                            marker=self.lh_marker)
                plt.scatter(call_pos, call_i2, s=self.lh_markersize, color=np.array(call_c), edgecolors=&#39;face&#39;,
                            marker=self.lh_marker)
            if self.snp_call and (&#34;combined_mosaic&#34; in self.callers):
                plt.scatter(call_pos_2d, call_i1_2d, s=self.lh_markersize, color=np.array(call_c_2d),
                            edgecolors=&#39;face&#39;, marker=self.lh_marker)
                plt.scatter(call_pos_2d, call_i2_2d, s=self.lh_markersize, color=np.array(call_c_2d),
                            edgecolors=&#39;face&#39;, marker=self.lh_marker)

            for i in borders[:-1]:
                ax.axvline(i + 0.5, color=&#34;g&#34;, lw=1)
            self.fig.add_subplot(ax)

        elif panels[i] == &#34;CN&#34;:
            borders = []
            gh1 = []
            gh2 = []
            tlen = 0
            tlen_2d = 0
            for c, (pos1, pos2) in r:
                if pos2 == 1000000000:
                    pos2 = io.get_chromosome_length(c)
                    if pos2 is None:
                        pos2 = 1000000000

                his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                start_bin = (pos1 - 1) // bin_size
                end_bin = pos2 // bin_size
                if end_bin &gt; len(his_p):
                    end_bin = len(his_p)
                h1 = np.array([0] * (end_bin - start_bin))
                h2 = np.array([0] * (end_bin - start_bin))
                h1[his_p != 0] = 1
                h2[his_p != 0] = 1

                flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                    FLAG_USEHAP if self.snp_use_phase else 0) | (
                           FLAG_USEMASK if self.rd_use_mask else 0) | FLAG_GC_CORR
                flag_rd = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
                if io.signal_exists(c, bin_size, &#34;calls combined&#34;, flag):
                    calls = io.read_calls(c, bin_size, &#34;calls combined&#34;, flag)
                    segments = io.get_signal(c, bin_size, &#34;RD mosaic segments 2d&#34;, flag_rd)
                    segments = segments_decode(segments)

                    for call in calls:
                        for b in segments[int(call[&#34;segment&#34;])]:
                            if b &lt; end_bin and b &gt;= start_bin:
                                h1[b - start_bin] = call[&#34;models&#34;][0][1]
                                h2[b - start_bin] = call[&#34;models&#34;][0][2]
                gh1.extend(list(h1))
                gh2.extend(list(h2))
                borders.append(len(gh1) - 1)
            x = range(len(gh1))
            plt.gca().get_xaxis().get_major_formatter().set_useOffset(False)
            plt.stackplot(x, gh1, gh2, baseline=&#39;sym&#39;)

            def format_func(value, tick_number):
                ix = int(value)
                if ix + 1 &lt; len(pos_x):
                    p = pos_x[ix] + (pos_x[ix + 1] - pos_x[ix]) * (value - ix)
                    return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                elif ix &lt; len(pos_x):
                    p = pos_x[ix]
                    return &#34;{0} Mbp&#34;.format(int(p / 100) / 10000)
                else:
                    return &#34;&#34;

            l = len(gh1)
            if i == len(panels) - 1:
                ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
                ax.xaxis.set_major_locator(plt.MaxNLocator(5))
                ax.set_xlim([-l * 0.0, (l - 1) * 1.0])
                ax.xaxis.grid()

            for i in borders[:-1]:
                ax.axvline(i + 0.5, color=&#34;g&#34;, lw=1)
            self.fig.add_subplot(ax)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show(self):
    print(&#34;\nParameters&#34;)
    for key in sorted(self.params.keys()):
        print(&#34;    * %s: %s&#34; % (key, str(self.params[key])))
        if key == &#34;plot_files&#34;:
            for i in range(len(self.io)):
                print(&#34;            %d: %s&#34; % (i, self.io[i].filename))
    print()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.single_cell_allelic_dropout"><code class="name flex">
<span>def <span class="ident">single_cell_allelic_dropout</span></span>(<span>self, callset=None, res=1000, n_bins=100, threshold=0.1, snp_threshold=0.01, neigh=False, plot=False, stdout=True, title=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Function used to identify regions without allelic dropout in the case of single cell amplification.
It requires baf data for bin size. It will filter out all bins with at least one SNP bellow snp_threshold and
all bins with collective maximum baf likelihood bellow threshold parameter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>callset</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Name of callset if not default.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>int</code></dt>
<dd>Resolution in bins used to calculate percentage of dropouts in region.</dd>
<dt><strong><code>n_bins</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of bins in histograms.</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>Collective threshold of AF for allelic dropout</dd>
<dt><strong><code>snp_threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>Single SNP threshold of AF for allelic dropout</dd>
<dt><strong><code>neigh</code></strong> :&ensp;<code>bool</code></dt>
<dd>Remove neighbouring bins also.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>bool</code></dt>
<dd>Make plots.</dd>
<dt><strong><code>stdout</code></strong> :&ensp;<code>bool</code></dt>
<dd>Print out good regions</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def single_cell_allelic_dropout(self, callset=None, res=1000, n_bins=100, threshold=0.1, snp_threshold=0.01,
                                neigh=False, plot=False, stdout=True, title=None):
    &#34;&#34;&#34;
    Function used to identify regions without allelic dropout in the case of single cell amplification.
    It requires baf data for bin size. It will filter out all bins with at least one SNP bellow snp_threshold and
    all bins with collective maximum baf likelihood bellow threshold parameter.

    Parameters
    ----------
    callset : str or None
        Name of callset if not default.
    res : int
        Resolution in bins used to calculate percentage of dropouts in region.
    n_bins : int
        Number of bins in histograms.
    threshold : float
        Collective threshold of AF for allelic dropout
    snp_threshold : float
        Single SNP threshold of AF for allelic dropout
    neigh : bool
        Remove neighbouring bins also.
    plot : bool
        Make plots.
    stdout : bool
        Print out good regions

    &#34;&#34;&#34;

    if plot:
        self.new_figure(panel_count=2, panel_size=(16, 6), title=title)
        ax = self.next_panel()
        bafG = []
        baf = []
        cpos = 0
        sizeG = []
        sizeB = []
    for c in self.io[self.plot_file].snp_chromosomes():
        if len(self.chrom) == 0 or (c in self.chrom):
            snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                FLAG_USEHAP if self.snp_use_phase else 0)
            i1 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP i1&#34;, snp_flag)
            pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_file].read_snp(c, callset=callset)
            c00 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP bin count 0|0&#34;, snp_flag)
            c11 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP bin count 1|1&#34;, snp_flag)
            homs = c00 + c11
            c01 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP bin count 0|1&#34;, snp_flag)
            c10 = self.io[self.plot_file].get_signal(c, self.bin_size, &#34;SNP bin count 1|0&#34;, snp_flag)
            hets = c01 + c10
            count = c01 + c10 + c00 + c11
            mask = np.zeros_like(i1)
            density = np.zeros(len(mask) // res)
            # mask[hets == 0] = 1
            mask[hets == 0] = 2
            mask[i1 &gt; (0.5 - threshold)] = 1
            for ix in range(len(pos)):
                if (nref[ix] + nalt[ix]) != 0 and ((gt[ix] % 4) in [1, 2]):
                    b = 1.0 * nalt[ix] / (nref[ix] + nalt[ix])
                    if (b &lt; snp_threshold) or (b &gt; (1 - snp_threshold)):
                        mask[(pos[ix] - 1) // self.bin_size] = 1

            if neigh:
                ada = mask == 1
                ada1 = np.roll(ada, 1)
                ada2 = np.roll(ada, -1)
                ada1[0] = False
                ada2[-1] = False
                mask[ada1] = 1
                mask[ada2] = 1
            ix = 0
            while ix &lt; len(mask):
                if mask[ix] == 2:
                    adan = 0
                    if ix &gt; 0 and mask[ix - 1] == 1:
                        adan = 1
                    jx = ix
                    while jx &lt; len(mask) and mask[jx] == 2:
                        jx += 1
                    if jx &lt; len(mask) and mask[jx] == 1:
                        adan = 1
                    mask[ix:jx] = adan
                    ix = jx
                else:
                    ix += 1
            ix = 0
            ojx = 0
            while ix &lt; len(mask):
                if mask[ix] == 0:
                    jx = ix
                    while jx &lt; len(mask) and mask[jx] == 0:
                        jx += 1
                    if stdout:
                        print(&#34;%s\t%d\t%d&#34; % (c, ix * self.bin_size + 1, jx * self.bin_size))
                    sizeG.append((jx - ix) * self.bin_size)
                    if ix &gt; ojx:
                        sizeB.append((ix - ojx) * self.bin_size)
                    ojx = jx
                    ix = jx
                else:
                    ix += 1
            if plot:
                for ix in range(len(density)):
                    density[ix] = np.mean(mask[res * ix:res * (ix + 1)])
                ax.plot(np.arange(cpos, cpos + len(density)) * res, density)
                cpos += len(density)
                for ix in range(len(pos)):
                    if (nref[ix] + nalt[ix]) != 0 and ((gt[ix] % 4) in [1, 2]):
                        baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                        if mask[(pos[ix] - 1) // self.bin_size] == 0:
                            bafG.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
    ax.set_xlabel(&#34;Position in genome [bins]&#34;)
    ax.set_ylabel(&#34;Percentage of allelic dropout&#34;)
    ax.grid(True)
    if plot:
        self.new_subgrid(2, grid=&#34;horizontal&#34;, hspace=0.05, wspace=0.2)
        ax = self.next_subpanel()
        ms = 5 * max(np.mean(sizeG), np.mean(sizeB))
        ax.hist(sizeB, bins=np.arange(1, ms, self.bin_size), histtype=&#34;step&#34;, log=True,
                label=&#34;Allelic dropout regions&#34;, linewidth=3)
        ax.hist(sizeG, bins=np.arange(1, ms, self.bin_size), histtype=&#34;step&#34;, log=True,
                label=&#34;Region with both alleles&#34;, linewidth=3)
        ax.legend()
        ax.grid(True)
        ax.set_xlabel(&#34;Size [bp]&#34;)
        ax.set_ylabel(&#34;Number of regions&#34;)
        self.fig.add_subplot(ax)

        ax = self.next_subpanel()
        ax.hist(baf, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)),
                label=&#34;All heterozygous variants&#34;)
        ax.hist(bafG, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)),
                label=&#34;Region with both alleles&#34;)
        ax.legend()
        ax.grid(True)
        ax.set_xlabel(&#34;VAF&#34;)
        ax.set_ylabel(&#34;Distribution&#34;)
        self.fig.add_subplot(ax)

        self.fig_show(suffix=&#34;allelic_dropout&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.snp"><code class="name flex">
<span>def <span class="ident">snp</span></span>(<span>self, plot_gt=None, plot_pmask=None, callset=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def snp(self, plot_gt=None, plot_pmask=None, callset=None):
    if plot_pmask is None:
        plot_pmask = [0, 1]
    if plot_gt is None:
        plot_gt = [0, 1, 2, 3]
    chroms = []
    if self.reference_genome is None:
        chroms = self.io[self.plot_file].snp_chromosomes()
    else:
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
            if callset is None:
                if self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP pos&#34;, 0) and \
                        self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP desc&#34;, 0) and \
                        self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP counts&#34;, 0) and \
                        self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP qual&#34;, 0) and \
                        (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                    chroms.append(snp_chr)
            else:
                if self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP pos&#34;, 0, name=callset) and \
                        self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP desc&#34;, 0,
                                                              name=callset) and \
                        self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP counts&#34;, 0,
                                                              name=callset) and \
                        self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP qual&#34;, 0,
                                                              name=callset) and \
                        (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                    chroms.append(snp_chr)
    self.new_figure(panel_count=len(chroms))
    for c in chroms:
        pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_file].read_snp(c, callset=callset)
        hpos = []
        baf = []
        color = []
        qlpha = 0.7
        for i in range(len(pos)):
            if (nref[i] + nalt[i]) != 0:
                if (gt[i] % 4 in plot_gt) and ((flag[i] &gt;&gt; 1) in plot_pmask):
                    hpos.append(pos[i])
                    if gt[i] % 4 != 2:
                        baf.append(1.0 * nalt[i] / (nref[i] + nalt[i]))
                    else:
                        baf.append(1.0 * nref[i] / (nref[i] + nalt[i]))
                    if self.snp_alpha_P:
                        alpha = None
                        color.append(colors.to_rgba(self.snp_colors[(gt[i] % 4) * 2 + 1], (flag[i] &gt;&gt; 1) * 0.4))
                    else:
                        color.append(self.snp_colors[(gt[i] % 4) * 2 + (flag[i] &gt;&gt; 1)])

        ax = self.next_panel()
        ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                     color=&#39;C0&#39;)
        ax.xaxis.set_ticklabels([])
        ax.yaxis.set_ticklabels([])
        ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], minor=[])
        l = max(pos)
        ax.xaxis.set_ticks(np.arange(0, (l + 10e6), 10e6), minor=[])
        ax.set_ylim([0., 1.])
        ax.set_xlim([-0.05 * l, 1.05 * l])
        ax.grid()
        if self.markersize == &#34;auto&#34;:
            ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=0.7)
        else:
            ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=0.7)
    self.fig_show(suffix=&#34;snp&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.snp_compare"><code class="name flex">
<span>def <span class="ident">snp_compare</span></span>(<span>self, regions, ix1, ix2, callset=None, n_bins=100, titles=None, test_loh=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def snp_compare(self, regions, ix1, ix2, callset=None, n_bins=100, titles=None, test_loh=False):
    regions = regions.split(&#34; &#34;)
    n = len(regions)
    self.new_figure(panel_count=n)
    for i in range(n):
        ax = self.next_panel()
        if titles is None:
            ax.set_title(regions[i], position=(0.01, 1.07),
                         fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
        else:
            ax.set_title(titles[i], position=(0.01, 1.07),
                         fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
        regs = decode_region(regions[i])
        oval = []
        for c, (pos_start, pos_end) in regs:
            pos1, ref1, alt1, nref1, nalt1, gt1, flag1, qual1 = self.io[ix1].read_snp(c, callset=callset)
            pos2, ref2, alt2, nref2, nalt2, gt2, flag2, qual2 = self.io[ix2].read_snp(c, callset=callset)

            counts1 = {}
            counts2 = {}
            ix = 0
            while ix &lt; len(pos1) and pos1[ix] &lt;= pos_end:
                if pos1[ix] &gt;= pos_start and (nref1[ix] + nalt1[ix]) != 0:
                    counts1[pos1[ix]] = (nref1[ix] / np.sqrt(nref1[ix] ** 2 + nalt1[ix] ** 2),
                                         nalt1[ix] / np.sqrt(nref1[ix] ** 2 + nalt1[ix] ** 2))
                ix += 1
            ix = 0
            xx = []
            yy = []
            cc = []
            hist1 = []
            hist2 = []
            while ix &lt; len(pos2) and pos2[ix] &lt;= pos_end:
                if pos2[ix] &gt;= pos_start and (nref2[ix] + nalt2[ix]) != 0:
                    counts2[pos2[ix]] = (nref2[ix], nalt2[ix])
                ix += 1
            for p in counts1:
                if p in counts2:
                    xx.append(p)
                    yy.append(counts1[p][1] / (counts1[p][0] + counts1[p][1]))
                    cc.append(&#34;green&#34;)
                    xx.append(p)
                    yy.append(counts2[p][1] / (counts2[p][0] + counts2[p][1]))
                    cc.append(&#34;blue&#34;)
                    if counts2[p][1] / (counts2[p][0] + counts2[p][1]) &gt; 0.8:
                        t = counts1[p][1] / (counts1[p][0] + counts1[p][1])
                        if t &gt; 0.2 and t &lt; 0.8:
                            hist1.append(t)
                    else:
                        t = counts1[p][1] / (counts1[p][0] + counts1[p][1])
                        if t &gt; 0.2 and t &lt; 0.8:
                            hist2.append(t)
                else:
                    xx.append(p)
                    yy.append(counts1[p][1] / (counts1[p][0] + counts1[p][1]))
                    cc.append(&#34;red&#34;)
                    t = counts1[p][1] / (counts1[p][0] + counts1[p][1])
                    if t &gt; 0.2 and t &lt; 0.8:
                        hist2.append(t)
            for p in counts2:
                if not (p in counts1):
                    xx.append(p)
                    yy.append(counts2[p][1] / (counts2[p][0] + counts2[p][1]))
                    cc.append(&#34;orange&#34;)

        if test_loh:
            ax.hist(hist1, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)), histtype=&#39;step&#39;)
            ax.hist(hist2, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)), histtype=&#39;step&#39;)
            print(&#34;H1:&#34;, np.mean(hist1), np.std(hist1), len(hist1))
            print(&#34;H2:&#34;, np.mean(hist2), np.std(hist2), len(hist2))
            ax.set_xlabel(&#34;baf&#34;)
            ax.set_ylabel(&#34;distribnution&#34;)
        else:
            ax.scatter(xx, yy, marker=&#34;.&#34;, s=0.1, c=cc)
            # ax.hist(oval, bins=np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1)))
            ax.set_xlabel(&#34;position&#34;)
            ax.set_ylabel(&#34;baf&#34;)

    self.fig_show(suffix=&#34;snp_dist&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.snp_dist"><code class="name flex">
<span>def <span class="ident">snp_dist</span></span>(<span>self, regions, callset=None, n_bins=100, gt_plot=[0, 1, 2, 3], titles=None, beta_distribution=False, log_scale=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def snp_dist(self, regions, callset=None, n_bins=100, gt_plot=[0, 1, 2, 3], titles=None, beta_distribution=False,
             log_scale=False):
    nf = len(self.plot_files)
    regions = regions.split(&#34; &#34;)
    nr = len(regions)
    n = nf * nr
    self.new_figure(panel_count=n)
    for ii in range(nf):
        for i in range(nr):
            ax = self.next_panel()
            if titles is None:
                ax.set_title(self.file_title(self.plot_files[ii]) + &#34;: &#34; + regions[i], position=(0.01, 1.10),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            else:
                ax.set_title(titles[i], position=(0.01, 1.10),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            regs = decode_region(regions[i])
            baf = []
            bafP = []
            bafNP = []
            mean_rd = 0
            for c, (pos1, pos2) in regs:
                pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_files[ii]].read_snp(c,
                                                                                                  callset=callset)
                ix = 0
                while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                    if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0 and ((gt[ix] % 4) in gt_plot):
                        if gt[ix] % 4 != 2:
                            baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            if flag[ix] &amp; 2:
                                bafP.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                                mean_rd += nref[ix] + nalt[ix]
                            else:
                                bafNP.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                        else:
                            baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                            if flag[ix] &amp; 2:
                                bafP.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                                mean_rd += nref[ix] + nalt[ix]
                            else:
                                bafNP.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                    ix += 1
            mean_rd /= len(bafP)
            x_bins = np.arange(0, 1.0 + 1. / (n_bins + 1), 1. / (n_bins + 1))
            ax.hist(baf, bins=x_bins, label=&#34;All heterozygous variants&#34;)
            ax.hist(bafP, bins=x_bins, label=&#34;P bases only&#34;)
            # ax.hist(bafNP, bins=x_bins, label=&#34;non-P bases only&#34;, histtype=u&#39;step&#39;)
            if log_scale:
                plt.yscale(&#39;log&#39;, nonposy=&#39;clip&#39;)

            if beta_distribution:
                xx = np.linspace(0.2, 0.8, 200)
                ax.plot(xx, beta.pdf(xx, mean_rd / 2, mean_rd / 2) * len(bafP) / n_bins, c=&#34;black&#34;,
                        label=&#34;Beta distribution&#34;)
            ax.legend(bbox_to_anchor=(0, 1.02, 1, 0.2), loc=&#34;lower left&#34;, mode=&#34;expand&#34;, borderaxespad=0, ncol=3)
            ax.set_xlabel(&#34;VAF&#34;)
            ax.set_ylabel(&#34;Distribution&#34;)

    self.fig_show(suffix=&#34;snp_dist&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.stat"><code class="name flex">
<span>def <span class="ident">stat</span></span>(<span>self, his_bin_size=100, return_image=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def stat(self, his_bin_size=100, return_image=False):
    plt.clf()
    auto = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_AUTO)
    sex = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_SEX)
    mt = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_MT) and (his_bin_size &lt; 1001)
    if not (auto or sex or mt):
        return
    cond = [auto, sex, mt]
    stat_list = []
    n_cols = sum(map(int, cond))
    ix = 1
    plt.rcParams[&#34;font.size&#34;] = 8
    self.fig = plt.figure(1, figsize=(4 * n_cols, 8), dpi=90, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    for t, c, flag in zip([&#34;Autosomes&#34;, &#34;X/Y&#34;, &#34;Mitochondria&#34;], cond, [FLAG_AUTO, FLAG_SEX, FLAG_MT]):
        if c:
            stat = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD stat&#34;, flag)
            stat_list.append(stat)
            max_rd = int(stat[0])
            bin_size = int(stat[1])
            n_bins = int(stat[2])
            lim_rd = int(max(2 * stat[4], stat[4] + 3 * stat[5]))
            _logger.info(&#34;RD stat for %s: %.2f +- %.2f&#34; % (t, stat[4], stat[5]))
            if t == &#34;Mitochondria&#34; and auto:
                _logger.info(&#34;RD stat for %s - number of mitochondria per cell: %.2f +- %.2f&#34; % (
                    t, 2 * stat[4] / stat_list[0][4],
                    2 * stat[5] / stat_list[0][4] + stat_list[0][5] * stat[4] / (
                            stat_list[0][4] * stat_list[0][4])))
            his_p = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD p dist&#34;, flag)
            his_u = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD u dist&#34;, flag)
            his_rd_gc = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD GC dist&#34;, flag)
            gc_corr = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;GC corr&#34;, flag)
            ax = plt.subplot(2, n_cols, ix)
            ax.set_xlabel(&#34;RD&#34;)
            ax.set_ylabel(&#34;GC [%]&#34;)
            ax.xaxis.set_ticklabels([])
            ax.set_title(t)
            his_rd_gc[0][0] = 0
            ax.imshow(his_rd_gc[:lim_rd // bin_size, :].T, aspect=&#34;auto&#34;, interpolation=&#39;nearest&#39;, origin=&#39;lower&#39;)
            ax.plot(gc_corr * stat[4] / bin_size, range(101), &#34;w-&#34;)

            ax = plt.subplot(2, n_cols, ix + n_cols)
            ax.set_ylabel(&#34;Normalised distribution&#34;)
            ax.set_xlabel(&#34;RD&#34;)
            ax.set_xlim([0, lim_rd])
            # ax.set_ylim([0, 1.1])
            bins = range(0, max_rd, bin_size)
            x = np.arange(0, max_rd // bin_size * bin_size, 0.1 * bin_size)
            plt.plot(x, normal(x, 1, stat[4], stat[5]), &#34;g-&#34;)
            x = np.array(bins)
            plt.plot(x[:len(his_u)], his_u / stat[3], &#34;y*&#34;)
            plt.plot(x[:len(his_p)], his_p / stat[3], &#34;b*&#34;)
            ix += 1
    plt.subplots_adjust(bottom=0.08, top=0.95, wspace=0.25, hspace=0, left=0.05 * 3 / n_cols, right=0.95)
    if return_image:
        self.fig.canvas.draw()
        import PIL
        pil_image = PIL.Image.frombytes(&#39;RGB&#39;, self.fig.canvas.get_width_height(),
                                        self.fig.canvas.tostring_rgb())
        return pil_image
    elif self.output_filename != &#34;&#34;:
        plt.savefig(self._image_filename(&#34;stat&#34;), dpi=150)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cnvpytor.viewer.Show" href="#cnvpytor.viewer.Show">Show</a></b></code>:
<ul class="hlist">
<li><code><a title="cnvpytor.viewer.Show.info" href="#cnvpytor.viewer.Show.info">info</a></code></li>
<li><code><a title="cnvpytor.viewer.Show.ls" href="#cnvpytor.viewer.Show.ls">ls</a></code></li>
<li><code><a title="cnvpytor.viewer.Show.meta" href="#cnvpytor.viewer.Show.meta">meta</a></code></li>
</ul>
</li>
<li><code><b><a title="cnvpytor.viewer.Figure" href="#cnvpytor.viewer.Figure">Figure</a></b></code>:
<ul class="hlist">
<li><code><a title="cnvpytor.viewer.Figure.bin_size_f" href="viewparams.html#cnvpytor.viewparams.ViewParams.bin_size_f">bin_size_f</a></code></li>
<li><code><a title="cnvpytor.viewer.Figure.fig_show" href="#cnvpytor.viewer.Figure.fig_show">fig_show</a></code></li>
<li><code><a title="cnvpytor.viewer.Figure.get_panel" href="#cnvpytor.viewer.Figure.get_panel">get_panel</a></code></li>
<li><code><a title="cnvpytor.viewer.Figure.new_figure" href="#cnvpytor.viewer.Figure.new_figure">new_figure</a></code></li>
<li><code><a title="cnvpytor.viewer.Figure.next_panel" href="#cnvpytor.viewer.Figure.next_panel">next_panel</a></code></li>
<li><code><a title="cnvpytor.viewer.Figure.next_polar_panel" href="#cnvpytor.viewer.Figure.next_polar_panel">next_polar_panel</a></code></li>
<li><code><a title="cnvpytor.viewer.Figure.next_subpanel" href="#cnvpytor.viewer.Figure.next_subpanel">next_subpanel</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cnvpytor" href="index.html">cnvpytor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cnvpytor.viewer.anim_plot_likelihood" href="#cnvpytor.viewer.anim_plot_likelihood">anim_plot_likelihood</a></code></li>
<li><code><a title="cnvpytor.viewer.anim_plot_rd" href="#cnvpytor.viewer.anim_plot_rd">anim_plot_rd</a></code></li>
<li><code><a title="cnvpytor.viewer.anim_plot_rd_likelihood" href="#cnvpytor.viewer.anim_plot_rd_likelihood">anim_plot_rd_likelihood</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cnvpytor.viewer.Figure" href="#cnvpytor.viewer.Figure">Figure</a></code></h4>
<ul class="two-column">
<li><code><a title="cnvpytor.viewer.Figure.fig_show" href="#cnvpytor.viewer.Figure.fig_show">fig_show</a></code></li>
<li><code><a title="cnvpytor.viewer.Figure.get_panel" href="#cnvpytor.viewer.Figure.get_panel">get_panel</a></code></li>
<li><code><a title="cnvpytor.viewer.Figure.new_figure" href="#cnvpytor.viewer.Figure.new_figure">new_figure</a></code></li>
<li><code><a title="cnvpytor.viewer.Figure.new_subgrid" href="#cnvpytor.viewer.Figure.new_subgrid">new_subgrid</a></code></li>
<li><code><a title="cnvpytor.viewer.Figure.next_panel" href="#cnvpytor.viewer.Figure.next_panel">next_panel</a></code></li>
<li><code><a title="cnvpytor.viewer.Figure.next_polar_panel" href="#cnvpytor.viewer.Figure.next_polar_panel">next_polar_panel</a></code></li>
<li><code><a title="cnvpytor.viewer.Figure.next_subpanel" href="#cnvpytor.viewer.Figure.next_subpanel">next_subpanel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cnvpytor.viewer.Reader" href="#cnvpytor.viewer.Reader">Reader</a></code></h4>
</li>
<li>
<h4><code><a title="cnvpytor.viewer.Show" href="#cnvpytor.viewer.Show">Show</a></code></h4>
<ul class="">
<li><code><a title="cnvpytor.viewer.Show.info" href="#cnvpytor.viewer.Show.info">info</a></code></li>
<li><code><a title="cnvpytor.viewer.Show.ls" href="#cnvpytor.viewer.Show.ls">ls</a></code></li>
<li><code><a title="cnvpytor.viewer.Show.meta" href="#cnvpytor.viewer.Show.meta">meta</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cnvpytor.viewer.Viewer" href="#cnvpytor.viewer.Viewer">Viewer</a></code></h4>
<ul class="">
<li><code><a title="cnvpytor.viewer.Viewer.baf" href="#cnvpytor.viewer.Viewer.baf">baf</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.callmap" href="#cnvpytor.viewer.Viewer.callmap">callmap</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.circular" href="#cnvpytor.viewer.Viewer.circular">circular</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.compare" href="#cnvpytor.viewer.Viewer.compare">compare</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.compare_baf" href="#cnvpytor.viewer.Viewer.compare_baf">compare_baf</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.compare_rd_dist" href="#cnvpytor.viewer.Viewer.compare_rd_dist">compare_rd_dist</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.denovo_calls" href="#cnvpytor.viewer.Viewer.denovo_calls">denovo_calls</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.dispersion" href="#cnvpytor.viewer.Viewer.dispersion">dispersion</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.file_title" href="#cnvpytor.viewer.Viewer.file_title">file_title</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.genotype" href="#cnvpytor.viewer.Viewer.genotype">genotype</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.genotype_all" href="#cnvpytor.viewer.Viewer.genotype_all">genotype_all</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.genotype_prompt" href="#cnvpytor.viewer.Viewer.genotype_prompt">genotype_prompt</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.get_calls" href="#cnvpytor.viewer.Viewer.get_calls">get_calls</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.global_plot" href="#cnvpytor.viewer.Viewer.global_plot">global_plot</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.help" href="#cnvpytor.viewer.Viewer.help">help</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.likelihood" href="#cnvpytor.viewer.Viewer.likelihood">likelihood</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.manhattan" href="#cnvpytor.viewer.Viewer.manhattan">manhattan</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.multiple_regions" href="#cnvpytor.viewer.Viewer.multiple_regions">multiple_regions</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.parse" href="#cnvpytor.viewer.Viewer.parse">parse</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.phased_baf" href="#cnvpytor.viewer.Viewer.phased_baf">phased_baf</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.plot_command" href="#cnvpytor.viewer.Viewer.plot_command">plot_command</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.print_calls" href="#cnvpytor.viewer.Viewer.print_calls">print_calls</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.print_calls_file" href="#cnvpytor.viewer.Viewer.print_calls_file">print_calls_file</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.print_simple_joint_calls" href="#cnvpytor.viewer.Viewer.print_simple_joint_calls">print_simple_joint_calls</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.prompt" href="#cnvpytor.viewer.Viewer.prompt">prompt</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.rd" href="#cnvpytor.viewer.Viewer.rd">rd</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.rd_baf" href="#cnvpytor.viewer.Viewer.rd_baf">rd_baf</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.rd_baf_call_models" href="#cnvpytor.viewer.Viewer.rd_baf_call_models">rd_baf_call_models</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.rd_diff" href="#cnvpytor.viewer.Viewer.rd_diff">rd_diff</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.region_rd_stat" href="#cnvpytor.viewer.Viewer.region_rd_stat">region_rd_stat</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.regions" href="#cnvpytor.viewer.Viewer.regions">regions</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.set_style" href="#cnvpytor.viewer.Viewer.set_style">set_style</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.show" href="#cnvpytor.viewer.Viewer.show">show</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.single_cell_allelic_dropout" href="#cnvpytor.viewer.Viewer.single_cell_allelic_dropout">single_cell_allelic_dropout</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.snp" href="#cnvpytor.viewer.Viewer.snp">snp</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.snp_compare" href="#cnvpytor.viewer.Viewer.snp_compare">snp_compare</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.snp_dist" href="#cnvpytor.viewer.Viewer.snp_dist">snp_dist</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.stat" href="#cnvpytor.viewer.Viewer.stat">stat</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>