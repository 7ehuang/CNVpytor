<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>cnvpytor.viewer API documentation</title>
<meta name="description" content="cnvpytor.viewer â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cnvpytor.viewer</code></h1>
</header>
<section id="section-intro">
<p>cnvpytor.viewer</p>
<p>Class Viewer: ploting CNVpytor data</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34; cnvpytor.viewer

Class Viewer: ploting CNVpytor data
&#34;&#34;&#34;
from __future__ import absolute_import, print_function, division

from .io import *
from .utils import *
from .genome import *
from .viewparams import ViewParams, HelpDescription
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.colors as colors

import numpy as np
import logging
import readline
import traceback

_logger = logging.getLogger(&#34;cnvpytor.viewer&#34;)


class Reader:
    def __init__(self, files):
        self.io = [IO(f, ro=True) for f in files]


class Export(Reader):
    def jbrowse(self):
        pass

    def cnvnator(self):
        pass


class Show(Reader):
    def ls(self):
        for i in self.io:
            i.ls()

    def meta(self):
        for i in self.io:
            i.read_meta_attribute()

    def info(self, bin_sizes):
        bin_sizes = [100] + bin_sizes
        labels = [&#34;FILE&#34;, &#34;RL&#34;, &#34;dRL[%]&#34;, &#34;FL&#34;, &#34;dFL[%]&#34;]
        for bs in bin_sizes:
            labels.append(&#34;RD_AUTO_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_AUTO_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_GC_AUTO_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_GC_AUTO_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_XY_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_XY_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_GC_XY_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_GC_XY_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            if bs &lt;= 500:
                labels.append(&#34;RD_MT_&#34; + binsize_format(bs))
                labels.append(&#34;dRD_MT_&#34; + binsize_format(bs) + &#34;[%]&#34;)
                labels.append(&#34;RD_GC_MT_&#34; + binsize_format(bs))
                labels.append(&#34;dRD_CG_MT_&#34; + binsize_format(bs) + &#34;[%]&#34;)
        print((&#34;{:25}{:&gt;20}{:&gt;20}{:&gt;20}{:&gt;20}&#34; + &#34;{:&gt;20}&#34; * (len(labels) - 5)).format(*tuple(labels)))
        for i in self.io:
            rfd = i.get_signal(None, None, &#34;read frg dist&#34;)
            rd = np.sum(rfd, axis=1)
            fd = np.sum(rfd, axis=0)
            mrl = np.sum(rd * np.arange(rd.size)) / np.sum(rd)
            mfl = np.sum(fd * np.arange(fd.size)) / np.sum(fd)
            mrl2 = np.sum(rd * np.arange(rd.size) * np.arange(rd.size)) / np.sum(rd)
            mfl2 = np.sum(fd * np.arange(fd.size) * np.arange(fd.size)) / np.sum(fd)
            sdr = 100. * np.sqrt(mrl2 - mrl * mrl) / mrl
            sdf = 100. * np.sqrt(mfl2 - mfl * mfl) / mfl
            print(&#34;{:25}{:20.2f}{:20.2f}{:20.2f}{:20.2f}&#34;.format(i.filename, mrl, sdr, mfl, sdf), end=&#34;&#34;)
            for bs in bin_sizes:
                for flag in [FLAG_AUTO, FLAG_SEX, FLAG_MT]:
                    if bs &lt;= 500 or not flag == FLAG_MT:
                        if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=flag):
                            stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=flag)
                            if stat[4] &gt; 0:
                                stat[5] /= stat[4] / 100.
                            print(&#34;{:20.2f}{:20.2f}&#34;.format(stat[4], stat[5]), end=&#34;&#34;)
                        else:
                            print(&#34;{:&gt;20}{:&gt;20}&#34;.format(&#34;-&#34;, &#34;-&#34;), end=&#34;&#34;)
                        if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=(flag | FLAG_GC_CORR)):
                            stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=(flag | FLAG_GC_CORR))
                            if stat[4] &gt; 0:
                                stat[5] /= stat[4] / 100.
                            print(&#34;{:20.2f}{:20.2f}&#34;.format(stat[4], stat[5]), end=&#34;&#34;)
                        else:
                            print(&#34;{:&gt;20}{:&gt;20}&#34;.format(&#34;-&#34;, &#34;-&#34;), end=&#34;&#34;)
            print()


class Viewer(Show, ViewParams, HelpDescription):

    def __init__(self, files, params):
        _logger.debug(&#34;Viewer class init: files [%s], params %s.&#34; % (&#34;, &#34;.join(files), str(params)))
        ViewParams.__init__(self, params)
        Show.__init__(self, files)
        self.io_gc = self.io[0]
        self.io_mask = self.io[0]
        self.reference_genome = None
        self.interactive = False
        self.plot_files = list(range(len(files)))
        self.fig = None
        if self.io[0].signal_exists(None, None, &#34;reference genome&#34;):
            rg_name = np.array(self.io[0].get_signal(None, None, &#34;reference genome&#34;)).astype(&#34;str&#34;)[0]
            self.reference_genome = Genome.reference_genomes[rg_name]
            if &#34;mask_file&#34; in Genome.reference_genomes[rg_name]:
                self.io_mask = IO(Genome.reference_genomes[rg_name][&#34;mask_file&#34;], ro=True, buffer=True)
            if &#34;gc_file&#34; in Genome.reference_genomes[rg_name]:
                self.io_gc = IO(Genome.reference_genomes[rg_name][&#34;gc_file&#34;], ro=True, buffer=True)

    def parse(self, command):
        current = &#34;regions&#34;
        regions = []

        for p in command:
            if p.isdigit() and (int(p) % 100) == 0:
                if current == &#34;rd&#34;:
                    self.rd(int(p), self.rd_use_mask)
                if current == &#34;baf&#34;:
                    self.baf(int(p), self.rd_use_mask)
                if current == &#34;likelihood&#34;:
                    self.likelihood(int(p))
                elif current == &#34;manhattan&#34;:
                    self.manhattan(int(p), use_mask=self.rd_use_mask)
                elif current == &#34;calls&#34;:
                    self.manhattan(int(p), use_mask=self.rd_use_mask, plot_type=&#34;calls&#34;)
                elif current == &#34;stat&#34;:
                    self.stat(int(p))
                elif current == &#34;circular&#34;:
                    self.circular(int(p), self.chrom, self.rd_use_mask)
                elif current == &#34;regions&#34;:
                    self.multiple_regions(int(p), regions, panels=self.panels)
                    regions = []
            elif p == &#34;rdstat&#34;:
                self.stat()
            elif p == &#34;snp&#34;:
                self.snp()
            elif p in [&#34;rd&#34;, &#34;baf&#34;, &#34;manhattan&#34;, &#34;calls&#34;, &#34;stat&#34;, &#34;regions&#34;, &#34;likelihood&#34;, &#34;circular&#34;]:
                current = p
            elif current == &#34;regions&#34;:
                regions.append(p)
            else:
                current = p

    def plot(self, command):
        self.interactive = False
        self.parse(command)

    def prompt(self):
        self.interactive = True

        for p in self.params:
            self.command_tree[&#34;set&#34;][p] = None
            if type(self.params[p]) == type(True):
                self.command_tree[&#34;unset&#34;][p] = None
        for c in self.param_help:
            self.command_tree[&#34;help&#34;][c] = None
        chromosomes = set({})
        for f in self.io:
            chromosomes = chromosomes.union(set(f.rd_chromosomes()))
            chromosomes = chromosomes.union(set(f.snp_chromosomes()))
        for c in chromosomes:
            self.command_tree[c] = None
        self.command_tree[&#34;set&#34;][&#34;style&#34;] = dict(zip(plt.style.available, [None] * len(plt.style.available)))

        readline.parse_and_bind(&#34;tab: complete&#34;)
        completer = PromptCompleter(self.command_tree)
        readline.set_completer(completer.complete)
        quit = False
        try:
            while not quit:
                try:
                    line = raw_input(&#34;cnvpytor&gt; &#34;)
                except NameError:
                    line = input(&#34;cnvpytor&gt; &#34;)

                pre = line.split(&#34;&gt;&#34;)
                f = pre[0].strip().split(&#34; &#34;)
                n = len(f)
                if len(line) == 0:
                    continue
                elif f[0] == &#34;quit&#34;:
                    quit = True
                elif line[0] == &#34;|&#34;:
                    try:
                        eval(compile(line[1:], &#39;&lt;string&gt;&#39;, &#39;single&#39;))
                    except Exception as e:
                        print(traceback.format_exc())
                elif f[0] == &#34;save&#34; and n &gt; 1:
                    plt.savefig(f[1])
                elif f[0] in [&#34;draw&#34;, &#34;repaint&#34;, &#34;update&#34;] and n == 1:
                    self.fig.canvas.draw()
                elif f[0] == &#34;ls&#34;:
                    self.ls()
                elif f[0] == &#34;show&#34;:
                    if n == 1:
                        self.show()
                elif f[0] == &#34;set&#34; and n &gt; 1:
                    self.set(f[1], f[2:])
                elif f[0] == &#34;help&#34; and n &gt; 1:
                    self.help(f[1])
                elif f[0] == &#34;help&#34; and n == 1:
                    self.help(&#34;help&#34;)
                elif f[0] == &#34;unset&#34; and n &gt; 1:
                    self.unset(f[1])
                elif f[0] == &#34;genotype&#34; and n &gt; 1:
                    for ni in range(1, n):
                        self.genotype([self.bin_size], f[ni])
                elif f[0] == &#34;compare&#34; and n == 3:
                    self.compare(f[1], f[2], plot=True)
                elif f[0] == &#34;snv&#34; and n == 2:
                    self.snp(callset=f[1])
                elif f[0] == &#34;snv&#34; and n == 1:
                    self.snp(callset=&#34;default&#34;)
                elif f[0] == &#34;compare&#34; and n == 4:
                    self.compare(f[1], f[2], n_bins=int(f[3]), plot=True)
                elif f[0] == &#34;info&#34; and n &gt; 1:
                    self.info(list(map(binsize_type,f[1:])))
                else:
                    try:
                        if f[0] not in [&#34;rdstat&#34;, &#34;snp&#34;]:
                            self.parse(f + [str(self.bin_size)])
                        else:
                            self.parse(f)
                        if len(pre) &gt; 1:
                            fns = pre[1].strip().split(&#34; &#34;)
                            if fns[0] != &#34;&#34;:
                                plt.savefig(fns[0], dpi=200)
                    except Exception as e:
                        print(traceback.format_exc())
        except (EOFError, KeyboardInterrupt):
            print()
            return

    def help(self, param):
        if param in self.param_help:
            print(self.param_help[param])
        else:
            print(&#34;\nUnknown parameter !\n&#34;)

    @staticmethod
    def set_style(style):
        if style in plt.style.available:
            plt.style.use(&#34;default&#34;)
            plt.style.use(style)

    def image_filename(self, sufix):
        parts = self.output_filename.split(&#34;.&#34;)
        if parts[-1] != &#34;png&#34; and parts[-1] != &#34;pdf&#34; and parts[-1] != &#34;jpg&#34; and parts[-1] != &#34;eps&#34; and parts[
            -1] != &#34;svg&#34;:
            _logger.warning(&#34;File extension should be: .jpg, .png, .svg, .eps or .pdf&#34;)
            exit(0)
        parts[-1] = sufix + &#34;.&#34; + parts[-1]
        return &#34;.&#34;.join(parts)

    def show(self):
        print(&#34;\nParameters&#34;)
        for key in sorted(self.params.keys()):
            print(&#34;    * %s: %s&#34; % (key, str(self.params[key])))
            if key == &#34;plot_files&#34;:
                for i in range(len(self.io)):
                    print(&#34;            %d: %s&#34; % (i, self.io[i].filename))
        print()

    def stat(self, his_bin_size=100, return_image=False):
        plt.clf()
        auto = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_AUTO)
        sex = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_SEX)
        mt = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_MT) and (his_bin_size &lt; 1001)
        if not (auto or sex or mt):
            return
        cond = [auto, sex, mt]
        stat_list = []
        n_cols = sum(map(int, cond))
        ix = 1
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, figsize=(4 * n_cols, 8), dpi=90, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        for t, c, flag in zip([&#34;Autosomes&#34;, &#34;X/Y&#34;, &#34;Mitochondria&#34;], cond, [FLAG_AUTO, FLAG_SEX, FLAG_MT]):
            if c:
                stat = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD stat&#34;, flag)
                stat_list.append(stat)
                max_rd = int(stat[0])
                bin_size = int(stat[1])
                n_bins = int(stat[2])
                lim_rd = int(max(2 * stat[4], stat[4] + 3 * stat[5]))
                _logger.info(&#34;RD stat for %s: %.2f +- %.2f&#34; % (t, stat[4], stat[5]))
                if t == &#34;Mitochondria&#34; and auto:
                    _logger.info(&#34;RD stat for %s - number of miochondria per cell: %.2f +- %.2f&#34; % (
                        t, 2 * stat[4] / stat_list[0][4],
                        2 * stat[5] / stat_list[0][4] + stat_list[0][5] * stat[4] / (
                                stat_list[0][4] * stat_list[0][4])))
                his_p = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD p dist&#34;, flag)
                his_u = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD u dist&#34;, flag)
                his_rd_gc = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD GC dist&#34;, flag)
                gc_corr = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;GC corr&#34;, flag)
                ax = plt.subplot(2, n_cols, ix)
                ax.set_xlabel(&#34;RD&#34;)
                ax.set_ylabel(&#34;GC [%]&#34;)
                ax.xaxis.set_ticklabels([])
                ax.set_title(t)
                his_rd_gc[0][0] = 0
                ax.imshow(his_rd_gc[:lim_rd // bin_size, :].T, aspect=&#34;auto&#34;, interpolation=&#39;nearest&#39;, origin=&#39;lower&#39;)
                ax.plot(gc_corr * stat[4] / bin_size, range(101), &#34;w-&#34;)

                ax = plt.subplot(2, n_cols, ix + n_cols)
                ax.set_ylabel(&#34;Normalised distribution&#34;)
                ax.set_xlabel(&#34;RD&#34;)
                ax.set_xlim([0, lim_rd])
                # ax.set_ylim([0, 1.1])
                bins = range(0, max_rd, bin_size)
                x = np.arange(0, max_rd // bin_size * bin_size, 0.1 * bin_size)
                plt.plot(x, normal(x, 1, stat[4], stat[5]), &#34;g-&#34;)
                x = np.array(bins)
                plt.plot(x[:len(his_u)], his_u / stat[3], &#34;y*&#34;)
                plt.plot(x[:len(his_p)], his_p / stat[3], &#34;b*&#34;)
                ix += 1
        plt.subplots_adjust(bottom=0.08, top=0.95, wspace=0.25, hspace=0, left=0.05 * 3 / n_cols, right=0.95)
        if return_image:
            self.fig.canvas.draw()
            import PIL
            pil_image = PIL.Image.frombytes(&#39;RGB&#39;, self.fig.canvas.get_width_height(),
                                            self.fig.canvas.tostring_rgb())
            return pil_image
        elif self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;stat&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def rd(self, bin_size, use_mask):
        plt.clf()
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        plt.rcParams[&#34;font.size&#34;] = 8
        chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            rd_chr = self.io[self.plot_file].rd_chromosome_name(c)
            if self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                    self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                    (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append((rd_chr, l))
        sx, sy = self.panels_shape(len(chroms))
        self.fig = plt.figure(1, figsize=(sx, sy), dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(8)
            self.fig.set_figwidth(12)
        ix = 1
        for c, l in chroms:
            flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
            stat = self.io[self.plot_file].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
            if stat is None:
                _logger.error(
                    &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[self.plot_file].filename))
                exit(0)
            flag_rd = 0
            if use_mask:
                flag_rd = FLAG_USEMASK
            his_p = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
            his_p_corr = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            his_p_seg = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD partition&#34;, flag_rd | FLAG_GC_CORR)
            his_p_call = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
            his_p_mosaic_seg = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                                  flag_rd | FLAG_GC_CORR)
            his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
            his_p_mosaic_call = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                                   flag_rd | FLAG_GC_CORR)
            his_p_mosaic = np.zeros_like(his_p) * np.nan
            if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                    for segi in seg:
                        his_p_mosaic[segi] = lev
            ax = plt.subplot(sx, sy, ix)
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks(np.arange(0, 3, 0.5) * stat[4], [])
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // bin_size, 10e6 // bin_size), [])
            ax.set_ylim([0, max(3. * stat[4], stat[4] + 5. * stat[5])])
            n_bins = l // bin_size
            ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
            ax.grid()

            plt.step(his_p, &#34;grey&#34;)
            plt.step(his_p_corr, &#34;k&#34;)
            if his_p_seg is not None and len(his_p_seg) &gt; 0 and self.rd_partition:
                plt.step(his_p_seg, &#34;r&#34;)
            if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call:
                plt.step(his_p_call, &#34;g&#34;)
            if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                plt.step(his_p_mosaic, &#34;b&#34;)
            ix += 1
        plt.subplots_adjust(bottom=0., top=1., wspace=0, hspace=0, left=0., right=1.)
        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;gview&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def rd_diff(self, bin_size, use_mask, file1, file2):
        plt.clf()
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        plt.rcParams[&#34;font.size&#34;] = 8
        chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            rd_chr = self.io[self.plot_file].rd_chromosome_name(c)
            if self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                    self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                    (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append((rd_chr, l))
        sx, sy = self.panels_shape(len(chroms))
        self.fig = plt.figure(1, figsize=(sx, sy), dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(8)
            self.fig.set_figwidth(12)
        ix = 1
        for c, l in chroms:
            flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
            stat1 = self.io[file1].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
            stat2 = self.io[file2].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
            if stat1 is None:
                _logger.error(
                    &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[file1].filename))
                return
            if stat2 is None:
                _logger.error(
                    &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[file2].filename))
                return
            flag_rd = 0
            if use_mask:
                flag_rd = FLAG_USEMASK
            his_p_corr1 = self.io[file1].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            his_p_corr2 = self.io[file2].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            ax = plt.subplot(sx, sy, ix)
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks(np.arange(0, 2, 0.25), [])
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // bin_size, 10e6 // bin_size), [])
            ax.set_ylim([0, 1])
            n_bins = l // bin_size
            ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
            ax.grid()

            plt.step(np.abs(his_p_corr1 / stat1[4] - his_p_corr2 / stat2[4]), &#34;k&#34;)
            ix += 1
        plt.subplots_adjust(bottom=0., top=1., wspace=0, hspace=0, left=0., right=1.)
        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;gview&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def likelihood(self, bin_size):
        plt.clf()
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        plt.rcParams[&#34;font.size&#34;] = 8
        chroms = []
        if self.reference_genome is None:
            chroms = self.io[self.plot_file].snp_chromosomes()
        else:
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
                if self.io[self.plot_file].signal_exists(snp_chr, bin_size, &#34;SNP likelihood&#34;, snp_flag) and (
                        Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                    chroms.append(snp_chr)
        sx, sy = self.panels_shape(len(chroms))
        self.fig = plt.figure(1, figsize=(sx, sy), dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(8)
            self.fig.set_figwidth(12)
        ix = 1
        for c in chroms:
            likelihood = self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
            img = np.array(likelihood).transpose()
            ax = plt.subplot(sx, sy, ix)
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.imshow(img, aspect=&#39;auto&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.xaxis.set_ticks(np.arange(0, likelihood.shape[0], 50), [])
            ix += 1
        plt.subplots_adjust(bottom=0., top=1., wspace=0, hspace=0, left=0., right=1.)
        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;gview&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def snp(self, size=10, plot_gt=None, plot_pmask=None, callset=None):
        if plot_pmask is None:
            plot_pmask = [0, 1]
        if plot_gt is None:
            plot_gt = [0, 1, 2, 3]
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, figsize=(12, 8), dpi=90, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(8)
            self.fig.set_figwidth(12)
        chroms = []
        if self.reference_genome is None:
            chroms = self.io[self.plot_file].snp_chromosomes()
        else:
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
                if callset is None:
                    if self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP pos&#34;, 0) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP desc&#34;, 0) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP counts&#34;, 0) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP qual&#34;, 0) and \
                            (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append(snp_chr)
                else:
                    if self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP pos&#34;, 0, name=callset) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP desc&#34;, 0, name=callset) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP counts&#34;, 0, name=callset) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP qual&#34;, 0, name=callset) and \
                            (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append(snp_chr)
        sx, sy = self.panels_shape(len(chroms))
        ix = 1
        for c in chroms:
            pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_file].read_snp(c, callset=callset)
            hpos = []
            baf = []
            color = []
            for i in range(len(pos)):
                if (nref[i] + nalt[i]) != 0:
                    if (gt[i] % 4 in plot_gt) and ((flag[i] &gt;&gt; 1) in plot_pmask):
                        hpos.append(pos[i])
                        if gt[i] % 4 != 2:
                            baf.append(1.0 * nalt[i] / (nref[i] + nalt[i]))
                        else:
                            baf.append(1.0 * nref[i] / (nref[i] + nalt[i]))
                        color.append(self.snp_colors[(gt[i] % 4) * 2 + (flag[i] &gt;&gt; 1)])

            ax = plt.subplot(sx, sy, ix)
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], [])
            l = max(pos)
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6), 10e6), [])
            ax.set_ylim([0., 1.])
            ax.set_xlim([-0.05 * l, 1.05 * l])
            ax.grid()
            if self.markersize == &#34;auto&#34;:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=0.7)
            else:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=0.7)
            ix += 1
        plt.subplots_adjust(bottom=0., top=1., wspace=0, hspace=0, left=0., right=1.)
        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;gview&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()


    @staticmethod
    def panels_shape(n):
        sx, sy = 1, 1
        if n == 2:
            sx = 2
        elif n in [3, 4]:
            sx, sy = 2, 2
        elif n in [5, 6]:
            sx, sy = 3, 2
        elif n in [7, 8, 9]:
            sx, sy = 3, 3
        elif n in [10, 11, 12]:
            sx, sy = 4, 3
        elif n in [13, 14, 15, 16]:
            sx, sy = 4, 4
        elif n in [17, 18, 19, 20]:
            sx, sy = 5, 4
        elif n in [21, 22, 23, 24]:
            sx, sy = 6, 4
        else:
            while sx * sy &lt; n:
                sx += 1
                sy = int(2. * sx / 3 + 1.)
        return sx, sy

    def manhattan(self, bin_size, use_mask=False, plot_type=&#34;rd&#34;):
        plt.clf()
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        n = len(self.plot_files)
        ix = self.plot_files

        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(1.5 * n)
            self.fig.set_figwidth(12)
        grid = gridspec.GridSpec(n, 1, wspace=0.2, hspace=0.2)
        for i in range(n):
            ax = self.fig.add_subplot(grid[i])
            io = self.io[ix[i]]
            ax.set_title(io.filename, position=(0.01, 1.07),
                         fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})

            if plot_type == &#34;rd&#34;:
                chroms = []
                for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                    rd_chr = io.rd_chromosome_name(c)
                    if len(self.chrom) == 0 or (rd_chr in self.chrom) or (c in self.chrom):
                        if io.signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                                io.signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                            chroms.append((rd_chr, l))

                apos = 0
                xticks = [0]

                max_m = 0
                for c, l in chroms:
                    flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
                    stat = io.get_signal(None, bin_size, &#34;RD stat&#34;, flag)
                    if stat[4] &gt; max_m:
                        max_m = stat[4]
                    flag_rd = 0
                    if use_mask:
                        flag_rd = FLAG_USEMASK
                    his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                    his_p_corr = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
                    if self.rd_manhattan_call:
                        his_p_call = io.get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
                        his_p_mosaic_seg = io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                         flag_rd | FLAG_GC_CORR)
                        his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
                        his_p_mosaic_call = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                          flag_rd | FLAG_GC_CORR)
                        his_p_mosaic = np.zeros_like(his_p) * np.nan
                        if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                            for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                                for segi in seg:
                                    his_p_mosaic[segi] = lev
                    pos = range(apos, apos + len(his_p))
                    ax.text(apos + len(his_p) // 2, stat[4] // 10, Genome.canonical_chrom_name(c),
                            fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                    if self.markersize == &#34;auto&#34;:
                        plt.plot(pos, his_p_corr, ls=&#39;&#39;, marker=&#39;.&#39;)
                    else:
                        plt.plot(pos, his_p_corr, ls=&#39;&#39;, marker=&#39;.&#39;, markersize=self.markersize)
                    if self.rd_manhattan_call:
                        if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call:
                            plt.step(pos, his_p_call, &#34;r&#34;)
                        if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                            plt.plot(pos, his_p_mosaic, &#34;k&#34;)
                    apos += len(his_p)
                    xticks.append(apos)
                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks(np.arange(0, 15, 0.5) * max_m, [])
                ax.xaxis.set_ticks(xticks, [])
                ax.set_ylim([self.rd_manhattan_range[0] * max_m, self.rd_manhattan_range[1] * max_m])
            else:
                chroms = []
                snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
                for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                    snp_chr = io.snp_chromosome_name(c)
                    if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                        if io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood call&#34;, snp_flag) and \
                                io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood segments&#34;, snp_flag) and \
                                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                            chroms.append((snp_chr, l))

                apos = 0
                xticks = [0]

                cix = 0
                cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
                for c, l in chroms:
                    flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO

                    likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                    segments = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
                    call_pos = []
                    call_baf = []
                    call_c = []
                    for s, lh in zip(segments, likelihood):
                        b, p = likelihood_baf_pval(lh)
                        if b &gt; 0 and len(s) &gt; self.min_segment_size:
                            alpha = -np.log(p + 1e-40) / self.contrast
                            if alpha &gt; 1:
                                alpha = 1
                            for pos in s:
                                call_pos.append(apos + pos)
                                call_baf.append(b)
                                color = cmap[cix % len(cmap)]
                                color = (color[0], color[1], color[2], alpha)
                                call_c.append(color)

                    ax.text(apos + l // bin_size // 2, 0.4, Genome.canonical_chrom_name(c),
                            fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                    plt.scatter(call_pos, call_baf, s=20, color=np.array(call_c), edgecolors=&#39;face&#39;, marker=&#39;|&#39;)
                    # plt.plot(call_pos, call_baf, color=np.array(call_c), ls=&#39;&#39;, marker=&#39;.&#39;)
                    apos += l // bin_size
                    xticks.append(apos)
                    cix += 1

                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks(np.arange(0, 0.5, 0.1), [])
                ax.xaxis.set_ticks(xticks, [])
                ax.set_ylim([0, 0.5])

            n_bins = apos
            ax.set_xlim([0, n_bins])
            ax.grid()
        plt.subplots_adjust(bottom=0.05, top=0.95, wspace=0, hspace=0, left=0.05, right=0.95)

        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;manhattan&#34; if plot_type == &#34;rd&#34; else &#34;snp_calls&#34;), dpi=200)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def multiple_regions(self, bin_size, regions, panels=[&#34;rd&#34;], sep_color=&#34;g&#34;):
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, figsize=(12, 8), facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        grid = gridspec.GridSpec(len(self.io), len(regions), wspace=0.2, hspace=0.2)
        ix = 0
        for i in self.io:
            for r in regions:
                self.regions(i, grid[ix], bin_size, r, panels=panels, sep_color=sep_color)
                ix += 1
        plt.subplots_adjust(bottom=0.05, top=0.95, wspace=0, hspace=0, left=0.05, right=0.95)

        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;regions&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def regions(self, io, element, bin_size, region, panels=[&#34;rd&#34;], sep_color=&#34;g&#34;):
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
        grid = gridspec.GridSpecFromSubplotSpec(len(panels), 1, subplot_spec=element, wspace=0, hspace=0.1)
        r = decode_region(region)
        for i in range(len(panels)):
            ax = self.fig.add_subplot(grid[i])
            if i == 0:
                ax.set_title(io.filename + &#34;: &#34; + region, position=(0.01, 0.9),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                             color=&#39;C0&#39;)

            if panels[i] == &#34;rd&#34;:
                g_p = []
                g_p_corr = []
                g_p_seg = []
                g_p_call = []
                g_p_call_mosaic = []
                mean, stdev = 0, 0
                borders = []
                for c, (pos1, pos2) in r:
                    flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
                    flag_rd = 0
                    if self.rd_use_mask:
                        flag_rd = FLAG_USEMASK
                    stat = io.get_signal(None, bin_size, &#34;RD stat&#34;, flag)
                    mean = stat[4]
                    stdev = stat[5]
                    his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                    his_p_corr = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_seg = io.get_signal(c, bin_size, &#34;RD partition&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_call = io.get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg = io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                     flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
                    his_p_mosaic_call = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                      flag_rd | FLAG_GC_CORR)
                    his_p_mosaic = np.zeros_like(his_p) * np.nan
                    if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                        for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                            for segi in seg:
                                his_p_mosaic[segi] = lev

                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    g_p.extend(list(his_p[start_bin:end_bin]))
                    g_p_corr.extend(list(his_p_corr[start_bin:end_bin]))
                    if his_p_seg is not None and len(his_p_seg) &gt; 0 and self.rd_partition:
                        g_p_seg.extend(list(his_p_seg[start_bin:end_bin]))
                    if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call:
                        g_p_call.extend(list(his_p_call[start_bin:end_bin]))
                    if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                        g_p_call_mosaic.extend(list(his_p_mosaic[start_bin:end_bin]))
                    borders.append(len(g_p) - 1)

                # ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                l = len(g_p)
                # ax.xaxis.set_ticks(np.arange(0, l, 10), [])
                ax.yaxis.set_ticks(np.arange(0, 3, 0.5) * mean, [])
                ax.set_ylim([0, max(3. * mean, mean + 5. * stdev)])
                ax.set_xlim([-l * 0.0, l * 1.0])

                ax.yaxis.grid()
                ax.step(g_p, &#34;grey&#34;)
                ax.step(g_p_corr, &#34;k&#34;)
                if len(g_p_seg) &gt; 0:
                    plt.step(g_p_seg, &#34;r&#34;)
                if len(g_p_call) &gt; 0:
                    plt.step(g_p_call, &#34;g&#34;)
                if len(g_p_call_mosaic) &gt; 0:
                    plt.step(g_p_call_mosaic, &#34;b&#34;)
                for i in borders[:-1]:
                    ax.axvline(i, color=sep_color, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;snp&#34;:
                borders = []
                hpos = []
                baf = []
                color = []
                start_pos = 0
                for c, (pos1, pos2) in r:
                    pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c)
                    ix = 0
                    mdp = 0
                    while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                        if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0:
                            hpos.append(start_pos + pos[ix] - pos1)
                            if pos[ix] - pos1 &gt; mdp:
                                mdp = pos[ix] - pos1
                            if gt[ix] % 4 != 2:
                                baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            else:
                                baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                            color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                        ix += 1
                    start_pos += mdp
                    borders.append(start_pos)

                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], [])
                l = max(hpos)
                # ax.xaxis.set_ticks(np.arange(0, (l + 10e6), 10e6), [])
                ax.set_ylim([0., 1.])
                ax.set_xlim([0, borders[-1]])
                ax.yaxis.grid()
                if self.markersize == &#34;auto&#34;:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=0.7)
                else:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=0.7)

                for i in borders[:-1]:
                    ax.axvline(i, color=sep_color, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;snv&#34; or panels[i][:4] == &#34;snv:&#34;:
                callset = &#34;default&#34;
                if panels[i][:4] == &#34;snv:&#34;:
                    callset=panels[i].split(&#34;:&#34;)[1]
                borders = []
                hpos = []
                baf = []
                color = []
                start_pos = 0
                for c, (pos1, pos2) in r:
                    pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c,callset=callset)
                    ix = 0
                    mdp = 0
                    while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                        if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0:
                            hpos.append(start_pos + pos[ix] - pos1)
                            if pos[ix] - pos1 &gt; mdp:
                                mdp = pos[ix] - pos1
                            if gt[ix] % 4 != 2:
                                baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            else:
                                baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                            color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                        ix += 1
                    start_pos += mdp
                    borders.append(start_pos)

                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], [])
                l = max(hpos)
                # ax.xaxis.set_ticks(np.arange(0, (l + 10e6), 10e6), [])
                ax.set_ylim([0., 1.])
                ax.set_xlim([0, borders[-1]])
                ax.yaxis.grid()
                if self.markersize == &#34;auto&#34;:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=0.7)
                else:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=0.7)

                for i in borders[:-1]:
                    ax.axvline(i, color=sep_color, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;baf&#34;:
                g_baf, g_maf, g_i1, g_i2 = [], [], [], []
                borders = []
                for c, (pos1, pos2) in r:
                    flag_snp = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                        FLAG_USEHAP if self.snp_use_phase else 0)
                    baf = io.get_signal(c, bin_size, &#34;SNP baf&#34;, flag_snp)
                    maf = io.get_signal(c, bin_size, &#34;SNP maf&#34;, flag_snp)
                    i1 = io.get_signal(c, bin_size, &#34;SNP i1&#34;, flag_snp)
                    i2 = io.get_signal(c, bin_size, &#34;SNP i2&#34;, flag_snp)

                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    g_baf.extend(list(baf[start_bin:end_bin]))
                    g_maf.extend(list(maf[start_bin:end_bin]))
                    g_i1.extend(list(i1[start_bin:end_bin]))
                    g_i2.extend(list(i2[start_bin:end_bin]))
                    borders.append(len(g_baf) - 1)

                # ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                l = len(g_baf)
                # ax.xaxis.set_ticks(np.arange(0, l, 10), [])
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], [])
                ax.set_ylim([0, 1])
                ax.set_xlim([-l * 0.0, l * 1.0])

                ax.yaxis.grid()
                ax.step(g_baf, &#34;grey&#34;)
                ax.step(g_maf, &#34;k&#34;)
                ax.step(g_i1, &#34;r&#34;)
                for i in borders[:-1]:
                    ax.axvline(i, color=sep_color, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;likelihood&#34;:
                borders = []
                gl = []
                for c, (pos1, pos2) in r:
                    likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    gl.extend(list(likelihood[start_bin:end_bin]))
                    borders.append(len(gl) - 1)
                img = np.array(gl).transpose()
                ax.imshow(img, aspect=&#39;auto&#39;)
                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.xaxis.set_ticks(np.arange(0, len(gl), 50), [])

                for i in borders[:-1]:
                    ax.axvline(i, color=sep_color, lw=1)
                self.fig.add_subplot(ax)

    def circular(self, bin_size, chroms=[], use_mask_rd=True):
        n = len(self.plot_files)
        ix = self.plot_files
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
        rd_flag = FLAG_GC_CORR | (FLAG_USEMASK if use_mask_rd else 0)
        if self.grid == &#34;auto&#34;:
            sx, sy = self.panels_shape(n)
        else:
            sx, sy = self.grid
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(sy * 8)
            self.fig.set_figwidth(sx * 8)
        grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        for i in range(n):
            ax = self.fig.add_subplot(grid[i], projection=&#39;polar&#39;)
            ax.set_theta_zero_location(&#34;N&#34;)
            ax.set_theta_direction(-1)
            io = self.io[ix[i]]
            plot_len = 0
            plot_chroms = []
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                rd_chr = io.rd_chromosome_name(c)
                if rd_chr is not None and (len(chroms) == 0 or (rd_chr in chroms) or (c in chroms)) and (
                        Genome.is_autosome(c) or Genome.is_sex_chrom(c)
                ) and io.signal_exists(rd_chr, bin_size, &#34;SNP maf&#34;, snp_flag) and io.signal_exists(
                    rd_chr, bin_size, &#34;RD&#34;, rd_flag):
                    plot_chroms.append((rd_chr, l))
                    plot_len += l // bin_size + 1
            rd_mean = io.get_signal(None, bin_size, &#34;RD stat&#34;, FLAG_AUTO)[4]
            tl = 0
            dt = 2.0 * np.pi / plot_len
            theta = np.arange(0, 2.0 * np.pi, dt)
            angles = []
            labels = []
            for j in range(len(plot_chroms)):
                c, l = plot_chroms[j]
                rd_color = self.palette1[j % len(self.palette1)]
                snp_color = self.palette2[j % len(self.palette2)]
                rd = io.get_signal(c, bin_size, &#34;RD&#34;, rd_flag)
                maf = io.get_signal(c, bin_size, &#34;SNP maf&#34;, snp_flag)
                plt.polar(theta[tl:tl + maf.size], 1 - maf, color=snp_color, linewidth=0.3)
                plt.fill_between(theta[tl:tl + maf.size], 1 - maf, np.ones_like(maf), color=snp_color, alpha=0.8)
                plt.polar(theta[tl:tl + rd.size], rd / (3. * rd_mean), color=rd_color, linewidth=0.3)
                plt.fill_between(theta[tl:tl + rd.size], np.ones_like(rd) / 10., rd / (3. * rd_mean), color=rd_color,
                                 alpha=0.8)
                # ax.text(theta[tl + maf.size // 3], 0.8, c, fontsize=8)
                labels.append(Genome.canonical_chrom_name(c))
                angles.append(180 * theta[tl + rd.size // 2] / np.pi)
                tl += l // bin_size + 1
            ax.set_rmax(0.9)
            ax.set_rticks([])
            ax.set_thetagrids(angles, labels=labels, fontsize=10, weight=&#34;bold&#34;, color=&#34;black&#34;)
            ax.set_title(io.filename.split(&#34;/&#34;)[-1], loc=&#34;left&#34;, fontsize=10, weight=&#34;bold&#34;, color=&#34;black&#34;)
            ax.grid(False)
        plt.subplots_adjust(bottom=0.05, top=0.95, wspace=0.2, hspace=0.2, left=0.05, right=0.95)
        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;circular&#34;), dpi=200)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def rd_baf(self, hist=True):
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, figsize=(12, 8), facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        n = len(self.plot_files)
        ix = self.plot_files
        if self.grid == &#34;auto&#34;:
            sx, sy = self.panels_shape(n)
        else:
            sx, sy = tuple(self.grid)
        grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        bin_size = self.bin_size
        for i in range(n):
            ax = self.fig.add_subplot(grid[i])
            io = self.io[ix[i]]


            chroms = []
            snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
            rd_flag = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = io.snp_chromosome_name(c)
                if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                    if io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood call&#34;, snp_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood segments&#34;, snp_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;RD mosaic call&#34;, rd_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;RD mosaic segments&#34;, rd_flag) and \
                            Genome.is_autosome(c):
                        chroms.append((snp_chr, l))
            x=[]
            y=[]
            for c, l in chroms:
                flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO

                likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                segments_baf = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
                rd = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;, rd_flag)
                segments_rd = segments_decode(io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;, rd_flag))

                mbaf={}
                mrd={}
                for s, lh in zip(segments_baf, likelihood):
                    b, p = likelihood_baf_pval(lh)
                    for pos in s:
                        mbaf[pos]=0.5-b
                for s, r in zip(segments_rd, rd[0]):
                    for pos in s:
                        mrd[pos]=r
                for p in mbaf:
                    if p in mrd:
                        x.append(mbaf[p])
                        y.append(mrd[p])

            if hist:
                from matplotlib.colors import LogNorm
                ax.hist2d(x,y,bins=[np.arange(0,0.51,0.01),np.arange(0,max(y),max(y)/100.)],norm=LogNorm())
            else:
                ax.scatter(x,y,marker=&#34;.&#34;,alpha=0.5)

        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;regions&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def dispersion(self, legend=True):
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(8)
            self.fig.set_figwidth(12)
        grid = gridspec.GridSpec(1, 2, wspace=0.2, hspace=0.2)

        ax = self.fig.add_subplot(grid[0])
        for i in self.io:
            bin_sizes = sorted(set([int(x[1]) for x in i.chromosomes_bin_sizes_with_signal(&#34;RD&#34;)]))
            rd = []
            drd = []
            for bs in bin_sizes:
                if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO):
                    stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO)
                    rd.append(stat[4])
                    drd.append(stat[5])
            ax.set_yscale(&#34;log&#34;)
            ax.set_xscale(&#34;log&#34;)
            ax.grid(True)
            ax.set_xlabel(&#34;mean RD&#34;)
            ax.set_ylabel(&#34;stdev RD&#34;)
            if legend:
                ax.legend(loc=&#34;upper left&#34;)
            ax.plot(rd, drd, &#34;*-&#34;, label=i.filename)

        ax = self.fig.add_subplot(grid[1])
        for i in self.io:
            bin_sizes = sorted(set([int(x[1]) for x in i.chromosomes_bin_sizes_with_signal(&#34;RD&#34;)]))
            rd = []
            drd = []
            for bs in bin_sizes:
                if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO | FLAG_GC_CORR):
                    stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO | FLAG_GC_CORR)
                    rd.append(stat[4])
                    drd.append(stat[5])
            ax.set_yscale(&#34;log&#34;)
            ax.set_xscale(&#34;log&#34;)
            ax.grid(True)
            ax.set_xlabel(&#34;mean RD (GC corr)&#34;)
            ax.set_ylabel(&#34;stdev RD (GC corr)&#34;)
            if legend:
                ax.legend(loc=&#34;upper left&#34;)
            ax.plot(rd, drd, &#34;*-&#34;, label=i.filename)

        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;dispersion&#34;), dpi=200)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def compare(self, region1, region2, n_bins=21, plot=False, legend=True):
        n = len(self.plot_files)
        ix = self.plot_files
        if plot:
            plt.clf()
            plt.rcParams[&#34;font.size&#34;] = 8
            if self.grid == &#34;auto&#34;:
                sx, sy = self.panels_shape(n)
            else:
                sx, sy = tuple(self.grid)
            self.fig = plt.figure(1, dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
            if self.output_filename != &#34;&#34;:
                self.fig.set_figheight(3 * sy)
                self.fig.set_figwidth(4 * sx)
            grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        for i in range(n):
            io = self.io[ix[i]]
            if plot:
                ax = self.fig.add_subplot(grid[i])
                ax.set_title(io.filename, position=(0.01, 1.07),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            stat = io.get_signal(None, self.bin_size, &#34;RD stat&#34;, FLAG_AUTO)
            regs1 = decode_region(region1)
            regs2 = decode_region(region2)
            data1 = []
            data2 = []
            for c, (pos1, pos2) in regs1:
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size
                data1 += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])
            for c, (pos1, pos2) in regs2:
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size
                data2 += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])

            data1 = np.array(data1)
            p1_1 = np.percentile(data1, 1)
            p99_1 = np.percentile(data1, 99)
            data1 = data1[data1 &gt; p1_1]
            data1 = data1[data1 &lt; p99_1]
            mean1 = np.mean(data1)
            std1 = np.std(data1)

            data2 = np.array(data2)
            p1_2 = np.percentile(data2, 1)
            p99_2 = np.percentile(data2, 99)
            data2 = data2[data2 &gt; p1_2]
            data2 = data2[data2 &lt; p99_2]
            mean2 = np.mean(data2)
            std2 = np.std(data2)

            rd_min = min(mean1 - 5 * std1, mean2 - 5 * std2)
            rd_max = max(mean1 + 5 * std1, mean2 + 5 * std2)
            bins = np.linspace(rd_min, rd_max, n_bins)

            hist1, binsr = np.histogram(data1, bins=bins)
            hist2, binsr = np.histogram(data2, bins=bins)

            fitn1, fitm1, fits1 = fit_normal(bins[:-1], hist1)[0]
            fitn2, fitm2, fits2 = fit_normal(bins[:-1], hist2)[0]

            pval = t_test_2_samples(fitm1, fits1, sum(hist1), fitm2, fits2, sum(hist2))

            print(&#34;%s\t%s\t%s\t%.4f\t%.4f\t%.4f\t%.4f\t%e\t%.4f\t%.4f&#34; % (
                io.filename, region1, region2, fitm1, fits1, fitm2, fits2, pval, fitm1 / fitm2,
                fitm1 / fitm2 * (fits1 / fitm1 / np.sqrt(sum(hist1)) + fits2 / fitm2 / np.sqrt(sum(hist2)))))

            if plot:
                x = np.linspace(bins[0], bins[-1], 1001)
                plt.plot(x, normal(x, fitn1, fitm1, fits1), &#34;g-&#34;, label=region1)
                plt.plot(x, normal(x, fitn2, fitm2, fits2), &#34;b-&#34;, label=region2)
                plt.plot(bins[:-1], hist1, &#34;g*&#34;)
                plt.plot(bins[:-1], hist2, &#34;b*&#34;)
                if legend:
                    plt.legend()

        if plot:
            if self.output_filename != &#34;&#34;:
                plt.savefig(self.image_filename(&#34;comp&#34;), dpi=200)
                plt.close(self.fig)
            elif self.interactive:
                plt.show(block=False)
                plt.draw()
            else:
                plt.show()

    def genotype(self, bin_sizes, region):
        regs = decode_region(region)
        for c, (pos1, pos2) in regs:
            print(c + &#34;:&#34; + str(pos1) + &#34;:&#34; + str(pos2), end=&#34;&#34;)
            for bs in bin_sizes:
                flag_rd = FLAG_GC_CORR if self.rd_use_gc_corr else o
                stat = self.io[self.plot_file].get_signal(c, bs, &#34;RD stat&#34;, flag_rd)
                his_p = self.io[self.plot_file].get_signal(c, bs, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // bs
                bin2 = (pos2 - 1) // bs
                rc = 0
                if bin1 == bin2:
                    rc = (pos2 - pos1 + 1) * his_p[bin1] / bs
                else:
                    rc += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] / bs
                    rc += (pos2 - bin2 * bs) * his_p[bin1] / bs
                    for ix in range(bin1 + 1, bin2):
                        rc += his_p[ix]
                print(&#34;\t%f&#34; % rc * stat[4] * (pos2 - pos1 + 1) / bs, end=&#34;&#34;)
        print()

    def genotype_prompt(self, bin_sizes=[]):
        done = False
        while not done:
            try:
                try:
                    line = raw_input(&#34;&#34;)
                except NameError:
                    line = input(&#34;&#34;)
            except EOFError:
                return
            if line is None or line == &#34;&#34;:
                done = True
            else:
                self.genotype(bin_sizes, line)


def anim_plot_likelihood(likelihood, segments, n, res, iter, prefix, maxp, minp):
    mm = [[0] * res] * n
    for i in range(len(segments)):
        for b in segments[i]:
            mm[b] = list(likelihood[i])
    fig = plt.figure(1, figsize=(16, 9), dpi=120, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    fig.suptitle(
        &#34;Iter: &#34; + str(iter) + &#34;   /   Segments: &#34; + str(len(segments)) + &#34;   /   Overlap interval: (&#34; + (
                &#39;%.4f&#39; % minp) + &#34;,&#34; + (
                &#39;%.4f&#39; % maxp) + &#34;)&#34;, fontsize=&#39;large&#39;)
    plt.subplot(211)
    plt.ylabel(&#34;BAF&#34;)
    plt.imshow(np.transpose(np.array(mm)), aspect=&#39;auto&#39;)
    plt.tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    plt.yticks([0, 50.5, 101, 151.5, 201], (&#34;1.00&#34;, &#34;0.75&#34;, &#34;0.50&#34;, &#34;0.25&#34;, &#34;0.00&#34;))
    # plt.grid(True,color=&#34;w&#34;)
    plt.subplot(212)
    plt.xlabel(&#34;BAF&#34;)
    plt.ylabel(&#34;Likelihood&#34;)
    plt.xticks([0, 0.25, 0.50, 0.75, 1.0])
    plt.grid(True, color=&#34;b&#34;)
    for i in range(len(likelihood)):
        plt.plot(np.linspace(1. / (res + 1), 1. - 1. / (res + 1), res), likelihood[i])
    plt.savefig(prefix + &#34;_&#34; + str(iter).zfill(4), dpi=150)
    plt.close(fig)


def anim_plot_rd(level, error, segments, n, iter, prefix, maxp, minp, mean):
    rd = [np.nan] * n
    for i in range(len(segments)):
        for b in segments[i]:
            rd[b] = level[i]

    fig = plt.figure(1, figsize=(16, 9), dpi=120, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    fig.suptitle(
        &#34;Iter: &#34; + str(iter) + &#34;   /   Segments: &#34; + str(len(segments)) + &#34;   /   Overlap interval: (&#34; + (
                &#39;%.4f&#39; % minp) + &#34;,&#34; + (
                &#39;%.4f&#39; % maxp) + &#34;)&#34;, fontsize=&#39;large&#39;)
    plt.subplot(211)
    plt.ylabel(&#34;RD&#34;)
    plt.step(range(n), rd, &#34;k&#34;)
    plt.tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    plt.yticks(np.arange(0, 3, 0.5) * mean, [])
    plt.ylim([0, 3 * mean])
    plt.grid(True, color=&#34;grey&#34;)

    plt.subplot(212)
    plt.xlabel(&#34;RD&#34;)
    plt.ylabel(&#34;Likelihood&#34;)
    plt.xticks(np.arange(0, 3, 0.5) * mean, [])
    plt.xlim([0, 3 * mean])
    plt.grid(True, color=&#34;grey&#34;)
    for i in range(len(level)):
        xx = np.linspace(0, 3 * mean, 300)
        yy = normal(xx, 1, level[i], error[i])
        plt.plot(xx, yy)
    plt.savefig(prefix + &#34;_&#34; + str(iter).zfill(4), dpi=150)
    plt.close(fig)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cnvpytor.viewer.anim_plot_likelihood"><code class="name flex">
<span>def <span class="ident">anim_plot_likelihood</span></span>(<span>likelihood, segments, n, res, iter, prefix, maxp, minp)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def anim_plot_likelihood(likelihood, segments, n, res, iter, prefix, maxp, minp):
    mm = [[0] * res] * n
    for i in range(len(segments)):
        for b in segments[i]:
            mm[b] = list(likelihood[i])
    fig = plt.figure(1, figsize=(16, 9), dpi=120, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    fig.suptitle(
        &#34;Iter: &#34; + str(iter) + &#34;   /   Segments: &#34; + str(len(segments)) + &#34;   /   Overlap interval: (&#34; + (
                &#39;%.4f&#39; % minp) + &#34;,&#34; + (
                &#39;%.4f&#39; % maxp) + &#34;)&#34;, fontsize=&#39;large&#39;)
    plt.subplot(211)
    plt.ylabel(&#34;BAF&#34;)
    plt.imshow(np.transpose(np.array(mm)), aspect=&#39;auto&#39;)
    plt.tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    plt.yticks([0, 50.5, 101, 151.5, 201], (&#34;1.00&#34;, &#34;0.75&#34;, &#34;0.50&#34;, &#34;0.25&#34;, &#34;0.00&#34;))
    # plt.grid(True,color=&#34;w&#34;)
    plt.subplot(212)
    plt.xlabel(&#34;BAF&#34;)
    plt.ylabel(&#34;Likelihood&#34;)
    plt.xticks([0, 0.25, 0.50, 0.75, 1.0])
    plt.grid(True, color=&#34;b&#34;)
    for i in range(len(likelihood)):
        plt.plot(np.linspace(1. / (res + 1), 1. - 1. / (res + 1), res), likelihood[i])
    plt.savefig(prefix + &#34;_&#34; + str(iter).zfill(4), dpi=150)
    plt.close(fig)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.anim_plot_rd"><code class="name flex">
<span>def <span class="ident">anim_plot_rd</span></span>(<span>level, error, segments, n, iter, prefix, maxp, minp, mean)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def anim_plot_rd(level, error, segments, n, iter, prefix, maxp, minp, mean):
    rd = [np.nan] * n
    for i in range(len(segments)):
        for b in segments[i]:
            rd[b] = level[i]

    fig = plt.figure(1, figsize=(16, 9), dpi=120, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    fig.suptitle(
        &#34;Iter: &#34; + str(iter) + &#34;   /   Segments: &#34; + str(len(segments)) + &#34;   /   Overlap interval: (&#34; + (
                &#39;%.4f&#39; % minp) + &#34;,&#34; + (
                &#39;%.4f&#39; % maxp) + &#34;)&#34;, fontsize=&#39;large&#39;)
    plt.subplot(211)
    plt.ylabel(&#34;RD&#34;)
    plt.step(range(n), rd, &#34;k&#34;)
    plt.tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    plt.yticks(np.arange(0, 3, 0.5) * mean, [])
    plt.ylim([0, 3 * mean])
    plt.grid(True, color=&#34;grey&#34;)

    plt.subplot(212)
    plt.xlabel(&#34;RD&#34;)
    plt.ylabel(&#34;Likelihood&#34;)
    plt.xticks(np.arange(0, 3, 0.5) * mean, [])
    plt.xlim([0, 3 * mean])
    plt.grid(True, color=&#34;grey&#34;)
    for i in range(len(level)):
        xx = np.linspace(0, 3 * mean, 300)
        yy = normal(xx, 1, level[i], error[i])
        plt.plot(xx, yy)
    plt.savefig(prefix + &#34;_&#34; + str(iter).zfill(4), dpi=150)
    plt.close(fig)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cnvpytor.viewer.Export"><code class="flex name class">
<span>class <span class="ident">Export</span></span>
<span>(</span><span>files)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Export(Reader):
    def jbrowse(self):
        pass

    def cnvnator(self):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cnvpytor.viewer.Reader" href="#cnvpytor.viewer.Reader">Reader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cnvpytor.viewer.Export.cnvnator"><code class="name flex">
<span>def <span class="ident">cnvnator</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cnvnator(self):
    pass</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Export.jbrowse"><code class="name flex">
<span>def <span class="ident">jbrowse</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def jbrowse(self):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cnvpytor.viewer.Reader"><code class="flex name class">
<span>class <span class="ident">Reader</span></span>
<span>(</span><span>files)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Reader:
    def __init__(self, files):
        self.io = [IO(f, ro=True) for f in files]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cnvpytor.viewer.Export" href="#cnvpytor.viewer.Export">Export</a></li>
<li><a title="cnvpytor.viewer.Show" href="#cnvpytor.viewer.Show">Show</a></li>
</ul>
</dd>
<dt id="cnvpytor.viewer.Show"><code class="flex name class">
<span>class <span class="ident">Show</span></span>
<span>(</span><span>files)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Show(Reader):
    def ls(self):
        for i in self.io:
            i.ls()

    def meta(self):
        for i in self.io:
            i.read_meta_attribute()

    def info(self, bin_sizes):
        bin_sizes = [100] + bin_sizes
        labels = [&#34;FILE&#34;, &#34;RL&#34;, &#34;dRL[%]&#34;, &#34;FL&#34;, &#34;dFL[%]&#34;]
        for bs in bin_sizes:
            labels.append(&#34;RD_AUTO_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_AUTO_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_GC_AUTO_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_GC_AUTO_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_XY_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_XY_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_GC_XY_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_GC_XY_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            if bs &lt;= 500:
                labels.append(&#34;RD_MT_&#34; + binsize_format(bs))
                labels.append(&#34;dRD_MT_&#34; + binsize_format(bs) + &#34;[%]&#34;)
                labels.append(&#34;RD_GC_MT_&#34; + binsize_format(bs))
                labels.append(&#34;dRD_CG_MT_&#34; + binsize_format(bs) + &#34;[%]&#34;)
        print((&#34;{:25}{:&gt;20}{:&gt;20}{:&gt;20}{:&gt;20}&#34; + &#34;{:&gt;20}&#34; * (len(labels) - 5)).format(*tuple(labels)))
        for i in self.io:
            rfd = i.get_signal(None, None, &#34;read frg dist&#34;)
            rd = np.sum(rfd, axis=1)
            fd = np.sum(rfd, axis=0)
            mrl = np.sum(rd * np.arange(rd.size)) / np.sum(rd)
            mfl = np.sum(fd * np.arange(fd.size)) / np.sum(fd)
            mrl2 = np.sum(rd * np.arange(rd.size) * np.arange(rd.size)) / np.sum(rd)
            mfl2 = np.sum(fd * np.arange(fd.size) * np.arange(fd.size)) / np.sum(fd)
            sdr = 100. * np.sqrt(mrl2 - mrl * mrl) / mrl
            sdf = 100. * np.sqrt(mfl2 - mfl * mfl) / mfl
            print(&#34;{:25}{:20.2f}{:20.2f}{:20.2f}{:20.2f}&#34;.format(i.filename, mrl, sdr, mfl, sdf), end=&#34;&#34;)
            for bs in bin_sizes:
                for flag in [FLAG_AUTO, FLAG_SEX, FLAG_MT]:
                    if bs &lt;= 500 or not flag == FLAG_MT:
                        if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=flag):
                            stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=flag)
                            if stat[4] &gt; 0:
                                stat[5] /= stat[4] / 100.
                            print(&#34;{:20.2f}{:20.2f}&#34;.format(stat[4], stat[5]), end=&#34;&#34;)
                        else:
                            print(&#34;{:&gt;20}{:&gt;20}&#34;.format(&#34;-&#34;, &#34;-&#34;), end=&#34;&#34;)
                        if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=(flag | FLAG_GC_CORR)):
                            stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=(flag | FLAG_GC_CORR))
                            if stat[4] &gt; 0:
                                stat[5] /= stat[4] / 100.
                            print(&#34;{:20.2f}{:20.2f}&#34;.format(stat[4], stat[5]), end=&#34;&#34;)
                        else:
                            print(&#34;{:&gt;20}{:&gt;20}&#34;.format(&#34;-&#34;, &#34;-&#34;), end=&#34;&#34;)
            print()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cnvpytor.viewer.Reader" href="#cnvpytor.viewer.Reader">Reader</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cnvpytor.viewer.Viewer" href="#cnvpytor.viewer.Viewer">Viewer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cnvpytor.viewer.Show.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, bin_sizes)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def info(self, bin_sizes):
    bin_sizes = [100] + bin_sizes
    labels = [&#34;FILE&#34;, &#34;RL&#34;, &#34;dRL[%]&#34;, &#34;FL&#34;, &#34;dFL[%]&#34;]
    for bs in bin_sizes:
        labels.append(&#34;RD_AUTO_&#34; + binsize_format(bs))
        labels.append(&#34;dRD_AUTO_&#34; + binsize_format(bs) + &#34;[%]&#34;)
        labels.append(&#34;RD_GC_AUTO_&#34; + binsize_format(bs))
        labels.append(&#34;dRD_GC_AUTO_&#34; + binsize_format(bs) + &#34;[%]&#34;)
        labels.append(&#34;RD_XY_&#34; + binsize_format(bs))
        labels.append(&#34;dRD_XY_&#34; + binsize_format(bs) + &#34;[%]&#34;)
        labels.append(&#34;RD_GC_XY_&#34; + binsize_format(bs))
        labels.append(&#34;dRD_GC_XY_&#34; + binsize_format(bs) + &#34;[%]&#34;)
        if bs &lt;= 500:
            labels.append(&#34;RD_MT_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_MT_&#34; + binsize_format(bs) + &#34;[%]&#34;)
            labels.append(&#34;RD_GC_MT_&#34; + binsize_format(bs))
            labels.append(&#34;dRD_CG_MT_&#34; + binsize_format(bs) + &#34;[%]&#34;)
    print((&#34;{:25}{:&gt;20}{:&gt;20}{:&gt;20}{:&gt;20}&#34; + &#34;{:&gt;20}&#34; * (len(labels) - 5)).format(*tuple(labels)))
    for i in self.io:
        rfd = i.get_signal(None, None, &#34;read frg dist&#34;)
        rd = np.sum(rfd, axis=1)
        fd = np.sum(rfd, axis=0)
        mrl = np.sum(rd * np.arange(rd.size)) / np.sum(rd)
        mfl = np.sum(fd * np.arange(fd.size)) / np.sum(fd)
        mrl2 = np.sum(rd * np.arange(rd.size) * np.arange(rd.size)) / np.sum(rd)
        mfl2 = np.sum(fd * np.arange(fd.size) * np.arange(fd.size)) / np.sum(fd)
        sdr = 100. * np.sqrt(mrl2 - mrl * mrl) / mrl
        sdf = 100. * np.sqrt(mfl2 - mfl * mfl) / mfl
        print(&#34;{:25}{:20.2f}{:20.2f}{:20.2f}{:20.2f}&#34;.format(i.filename, mrl, sdr, mfl, sdf), end=&#34;&#34;)
        for bs in bin_sizes:
            for flag in [FLAG_AUTO, FLAG_SEX, FLAG_MT]:
                if bs &lt;= 500 or not flag == FLAG_MT:
                    if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=flag):
                        stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=flag)
                        if stat[4] &gt; 0:
                            stat[5] /= stat[4] / 100.
                        print(&#34;{:20.2f}{:20.2f}&#34;.format(stat[4], stat[5]), end=&#34;&#34;)
                    else:
                        print(&#34;{:&gt;20}{:&gt;20}&#34;.format(&#34;-&#34;, &#34;-&#34;), end=&#34;&#34;)
                    if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=(flag | FLAG_GC_CORR)):
                        stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=(flag | FLAG_GC_CORR))
                        if stat[4] &gt; 0:
                            stat[5] /= stat[4] / 100.
                        print(&#34;{:20.2f}{:20.2f}&#34;.format(stat[4], stat[5]), end=&#34;&#34;)
                    else:
                        print(&#34;{:&gt;20}{:&gt;20}&#34;.format(&#34;-&#34;, &#34;-&#34;), end=&#34;&#34;)
        print()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Show.ls"><code class="name flex">
<span>def <span class="ident">ls</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ls(self):
    for i in self.io:
        i.ls()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Show.meta"><code class="name flex">
<span>def <span class="ident">meta</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def meta(self):
    for i in self.io:
        i.read_meta_attribute()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cnvpytor.viewer.Viewer"><code class="flex name class">
<span>class <span class="ident">Viewer</span></span>
<span>(</span><span>files, params)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Viewer(Show, ViewParams, HelpDescription):

    def __init__(self, files, params):
        _logger.debug(&#34;Viewer class init: files [%s], params %s.&#34; % (&#34;, &#34;.join(files), str(params)))
        ViewParams.__init__(self, params)
        Show.__init__(self, files)
        self.io_gc = self.io[0]
        self.io_mask = self.io[0]
        self.reference_genome = None
        self.interactive = False
        self.plot_files = list(range(len(files)))
        self.fig = None
        if self.io[0].signal_exists(None, None, &#34;reference genome&#34;):
            rg_name = np.array(self.io[0].get_signal(None, None, &#34;reference genome&#34;)).astype(&#34;str&#34;)[0]
            self.reference_genome = Genome.reference_genomes[rg_name]
            if &#34;mask_file&#34; in Genome.reference_genomes[rg_name]:
                self.io_mask = IO(Genome.reference_genomes[rg_name][&#34;mask_file&#34;], ro=True, buffer=True)
            if &#34;gc_file&#34; in Genome.reference_genomes[rg_name]:
                self.io_gc = IO(Genome.reference_genomes[rg_name][&#34;gc_file&#34;], ro=True, buffer=True)

    def parse(self, command):
        current = &#34;regions&#34;
        regions = []

        for p in command:
            if p.isdigit() and (int(p) % 100) == 0:
                if current == &#34;rd&#34;:
                    self.rd(int(p), self.rd_use_mask)
                if current == &#34;baf&#34;:
                    self.baf(int(p), self.rd_use_mask)
                if current == &#34;likelihood&#34;:
                    self.likelihood(int(p))
                elif current == &#34;manhattan&#34;:
                    self.manhattan(int(p), use_mask=self.rd_use_mask)
                elif current == &#34;calls&#34;:
                    self.manhattan(int(p), use_mask=self.rd_use_mask, plot_type=&#34;calls&#34;)
                elif current == &#34;stat&#34;:
                    self.stat(int(p))
                elif current == &#34;circular&#34;:
                    self.circular(int(p), self.chrom, self.rd_use_mask)
                elif current == &#34;regions&#34;:
                    self.multiple_regions(int(p), regions, panels=self.panels)
                    regions = []
            elif p == &#34;rdstat&#34;:
                self.stat()
            elif p == &#34;snp&#34;:
                self.snp()
            elif p in [&#34;rd&#34;, &#34;baf&#34;, &#34;manhattan&#34;, &#34;calls&#34;, &#34;stat&#34;, &#34;regions&#34;, &#34;likelihood&#34;, &#34;circular&#34;]:
                current = p
            elif current == &#34;regions&#34;:
                regions.append(p)
            else:
                current = p

    def plot(self, command):
        self.interactive = False
        self.parse(command)

    def prompt(self):
        self.interactive = True

        for p in self.params:
            self.command_tree[&#34;set&#34;][p] = None
            if type(self.params[p]) == type(True):
                self.command_tree[&#34;unset&#34;][p] = None
        for c in self.param_help:
            self.command_tree[&#34;help&#34;][c] = None
        chromosomes = set({})
        for f in self.io:
            chromosomes = chromosomes.union(set(f.rd_chromosomes()))
            chromosomes = chromosomes.union(set(f.snp_chromosomes()))
        for c in chromosomes:
            self.command_tree[c] = None
        self.command_tree[&#34;set&#34;][&#34;style&#34;] = dict(zip(plt.style.available, [None] * len(plt.style.available)))

        readline.parse_and_bind(&#34;tab: complete&#34;)
        completer = PromptCompleter(self.command_tree)
        readline.set_completer(completer.complete)
        quit = False
        try:
            while not quit:
                try:
                    line = raw_input(&#34;cnvpytor&gt; &#34;)
                except NameError:
                    line = input(&#34;cnvpytor&gt; &#34;)

                pre = line.split(&#34;&gt;&#34;)
                f = pre[0].strip().split(&#34; &#34;)
                n = len(f)
                if len(line) == 0:
                    continue
                elif f[0] == &#34;quit&#34;:
                    quit = True
                elif line[0] == &#34;|&#34;:
                    try:
                        eval(compile(line[1:], &#39;&lt;string&gt;&#39;, &#39;single&#39;))
                    except Exception as e:
                        print(traceback.format_exc())
                elif f[0] == &#34;save&#34; and n &gt; 1:
                    plt.savefig(f[1])
                elif f[0] in [&#34;draw&#34;, &#34;repaint&#34;, &#34;update&#34;] and n == 1:
                    self.fig.canvas.draw()
                elif f[0] == &#34;ls&#34;:
                    self.ls()
                elif f[0] == &#34;show&#34;:
                    if n == 1:
                        self.show()
                elif f[0] == &#34;set&#34; and n &gt; 1:
                    self.set(f[1], f[2:])
                elif f[0] == &#34;help&#34; and n &gt; 1:
                    self.help(f[1])
                elif f[0] == &#34;help&#34; and n == 1:
                    self.help(&#34;help&#34;)
                elif f[0] == &#34;unset&#34; and n &gt; 1:
                    self.unset(f[1])
                elif f[0] == &#34;genotype&#34; and n &gt; 1:
                    for ni in range(1, n):
                        self.genotype([self.bin_size], f[ni])
                elif f[0] == &#34;compare&#34; and n == 3:
                    self.compare(f[1], f[2], plot=True)
                elif f[0] == &#34;snv&#34; and n == 2:
                    self.snp(callset=f[1])
                elif f[0] == &#34;snv&#34; and n == 1:
                    self.snp(callset=&#34;default&#34;)
                elif f[0] == &#34;compare&#34; and n == 4:
                    self.compare(f[1], f[2], n_bins=int(f[3]), plot=True)
                elif f[0] == &#34;info&#34; and n &gt; 1:
                    self.info(list(map(binsize_type,f[1:])))
                else:
                    try:
                        if f[0] not in [&#34;rdstat&#34;, &#34;snp&#34;]:
                            self.parse(f + [str(self.bin_size)])
                        else:
                            self.parse(f)
                        if len(pre) &gt; 1:
                            fns = pre[1].strip().split(&#34; &#34;)
                            if fns[0] != &#34;&#34;:
                                plt.savefig(fns[0], dpi=200)
                    except Exception as e:
                        print(traceback.format_exc())
        except (EOFError, KeyboardInterrupt):
            print()
            return

    def help(self, param):
        if param in self.param_help:
            print(self.param_help[param])
        else:
            print(&#34;\nUnknown parameter !\n&#34;)

    @staticmethod
    def set_style(style):
        if style in plt.style.available:
            plt.style.use(&#34;default&#34;)
            plt.style.use(style)

    def image_filename(self, sufix):
        parts = self.output_filename.split(&#34;.&#34;)
        if parts[-1] != &#34;png&#34; and parts[-1] != &#34;pdf&#34; and parts[-1] != &#34;jpg&#34; and parts[-1] != &#34;eps&#34; and parts[
            -1] != &#34;svg&#34;:
            _logger.warning(&#34;File extension should be: .jpg, .png, .svg, .eps or .pdf&#34;)
            exit(0)
        parts[-1] = sufix + &#34;.&#34; + parts[-1]
        return &#34;.&#34;.join(parts)

    def show(self):
        print(&#34;\nParameters&#34;)
        for key in sorted(self.params.keys()):
            print(&#34;    * %s: %s&#34; % (key, str(self.params[key])))
            if key == &#34;plot_files&#34;:
                for i in range(len(self.io)):
                    print(&#34;            %d: %s&#34; % (i, self.io[i].filename))
        print()

    def stat(self, his_bin_size=100, return_image=False):
        plt.clf()
        auto = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_AUTO)
        sex = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_SEX)
        mt = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_MT) and (his_bin_size &lt; 1001)
        if not (auto or sex or mt):
            return
        cond = [auto, sex, mt]
        stat_list = []
        n_cols = sum(map(int, cond))
        ix = 1
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, figsize=(4 * n_cols, 8), dpi=90, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        for t, c, flag in zip([&#34;Autosomes&#34;, &#34;X/Y&#34;, &#34;Mitochondria&#34;], cond, [FLAG_AUTO, FLAG_SEX, FLAG_MT]):
            if c:
                stat = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD stat&#34;, flag)
                stat_list.append(stat)
                max_rd = int(stat[0])
                bin_size = int(stat[1])
                n_bins = int(stat[2])
                lim_rd = int(max(2 * stat[4], stat[4] + 3 * stat[5]))
                _logger.info(&#34;RD stat for %s: %.2f +- %.2f&#34; % (t, stat[4], stat[5]))
                if t == &#34;Mitochondria&#34; and auto:
                    _logger.info(&#34;RD stat for %s - number of miochondria per cell: %.2f +- %.2f&#34; % (
                        t, 2 * stat[4] / stat_list[0][4],
                        2 * stat[5] / stat_list[0][4] + stat_list[0][5] * stat[4] / (
                                stat_list[0][4] * stat_list[0][4])))
                his_p = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD p dist&#34;, flag)
                his_u = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD u dist&#34;, flag)
                his_rd_gc = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD GC dist&#34;, flag)
                gc_corr = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;GC corr&#34;, flag)
                ax = plt.subplot(2, n_cols, ix)
                ax.set_xlabel(&#34;RD&#34;)
                ax.set_ylabel(&#34;GC [%]&#34;)
                ax.xaxis.set_ticklabels([])
                ax.set_title(t)
                his_rd_gc[0][0] = 0
                ax.imshow(his_rd_gc[:lim_rd // bin_size, :].T, aspect=&#34;auto&#34;, interpolation=&#39;nearest&#39;, origin=&#39;lower&#39;)
                ax.plot(gc_corr * stat[4] / bin_size, range(101), &#34;w-&#34;)

                ax = plt.subplot(2, n_cols, ix + n_cols)
                ax.set_ylabel(&#34;Normalised distribution&#34;)
                ax.set_xlabel(&#34;RD&#34;)
                ax.set_xlim([0, lim_rd])
                # ax.set_ylim([0, 1.1])
                bins = range(0, max_rd, bin_size)
                x = np.arange(0, max_rd // bin_size * bin_size, 0.1 * bin_size)
                plt.plot(x, normal(x, 1, stat[4], stat[5]), &#34;g-&#34;)
                x = np.array(bins)
                plt.plot(x[:len(his_u)], his_u / stat[3], &#34;y*&#34;)
                plt.plot(x[:len(his_p)], his_p / stat[3], &#34;b*&#34;)
                ix += 1
        plt.subplots_adjust(bottom=0.08, top=0.95, wspace=0.25, hspace=0, left=0.05 * 3 / n_cols, right=0.95)
        if return_image:
            self.fig.canvas.draw()
            import PIL
            pil_image = PIL.Image.frombytes(&#39;RGB&#39;, self.fig.canvas.get_width_height(),
                                            self.fig.canvas.tostring_rgb())
            return pil_image
        elif self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;stat&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def rd(self, bin_size, use_mask):
        plt.clf()
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        plt.rcParams[&#34;font.size&#34;] = 8
        chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            rd_chr = self.io[self.plot_file].rd_chromosome_name(c)
            if self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                    self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                    (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append((rd_chr, l))
        sx, sy = self.panels_shape(len(chroms))
        self.fig = plt.figure(1, figsize=(sx, sy), dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(8)
            self.fig.set_figwidth(12)
        ix = 1
        for c, l in chroms:
            flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
            stat = self.io[self.plot_file].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
            if stat is None:
                _logger.error(
                    &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[self.plot_file].filename))
                exit(0)
            flag_rd = 0
            if use_mask:
                flag_rd = FLAG_USEMASK
            his_p = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
            his_p_corr = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            his_p_seg = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD partition&#34;, flag_rd | FLAG_GC_CORR)
            his_p_call = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
            his_p_mosaic_seg = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                                  flag_rd | FLAG_GC_CORR)
            his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
            his_p_mosaic_call = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                                   flag_rd | FLAG_GC_CORR)
            his_p_mosaic = np.zeros_like(his_p) * np.nan
            if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                    for segi in seg:
                        his_p_mosaic[segi] = lev
            ax = plt.subplot(sx, sy, ix)
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks(np.arange(0, 3, 0.5) * stat[4], [])
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // bin_size, 10e6 // bin_size), [])
            ax.set_ylim([0, max(3. * stat[4], stat[4] + 5. * stat[5])])
            n_bins = l // bin_size
            ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
            ax.grid()

            plt.step(his_p, &#34;grey&#34;)
            plt.step(his_p_corr, &#34;k&#34;)
            if his_p_seg is not None and len(his_p_seg) &gt; 0 and self.rd_partition:
                plt.step(his_p_seg, &#34;r&#34;)
            if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call:
                plt.step(his_p_call, &#34;g&#34;)
            if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                plt.step(his_p_mosaic, &#34;b&#34;)
            ix += 1
        plt.subplots_adjust(bottom=0., top=1., wspace=0, hspace=0, left=0., right=1.)
        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;gview&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def rd_diff(self, bin_size, use_mask, file1, file2):
        plt.clf()
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        plt.rcParams[&#34;font.size&#34;] = 8
        chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            rd_chr = self.io[self.plot_file].rd_chromosome_name(c)
            if self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                    self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                    (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append((rd_chr, l))
        sx, sy = self.panels_shape(len(chroms))
        self.fig = plt.figure(1, figsize=(sx, sy), dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(8)
            self.fig.set_figwidth(12)
        ix = 1
        for c, l in chroms:
            flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
            stat1 = self.io[file1].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
            stat2 = self.io[file2].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
            if stat1 is None:
                _logger.error(
                    &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[file1].filename))
                return
            if stat2 is None:
                _logger.error(
                    &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[file2].filename))
                return
            flag_rd = 0
            if use_mask:
                flag_rd = FLAG_USEMASK
            his_p_corr1 = self.io[file1].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            his_p_corr2 = self.io[file2].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
            ax = plt.subplot(sx, sy, ix)
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks(np.arange(0, 2, 0.25), [])
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // bin_size, 10e6 // bin_size), [])
            ax.set_ylim([0, 1])
            n_bins = l // bin_size
            ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
            ax.grid()

            plt.step(np.abs(his_p_corr1 / stat1[4] - his_p_corr2 / stat2[4]), &#34;k&#34;)
            ix += 1
        plt.subplots_adjust(bottom=0., top=1., wspace=0, hspace=0, left=0., right=1.)
        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;gview&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def likelihood(self, bin_size):
        plt.clf()
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        plt.rcParams[&#34;font.size&#34;] = 8
        chroms = []
        if self.reference_genome is None:
            chroms = self.io[self.plot_file].snp_chromosomes()
        else:
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
                if self.io[self.plot_file].signal_exists(snp_chr, bin_size, &#34;SNP likelihood&#34;, snp_flag) and (
                        Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                    chroms.append(snp_chr)
        sx, sy = self.panels_shape(len(chroms))
        self.fig = plt.figure(1, figsize=(sx, sy), dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(8)
            self.fig.set_figwidth(12)
        ix = 1
        for c in chroms:
            likelihood = self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
            img = np.array(likelihood).transpose()
            ax = plt.subplot(sx, sy, ix)
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.imshow(img, aspect=&#39;auto&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.xaxis.set_ticks(np.arange(0, likelihood.shape[0], 50), [])
            ix += 1
        plt.subplots_adjust(bottom=0., top=1., wspace=0, hspace=0, left=0., right=1.)
        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;gview&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def snp(self, size=10, plot_gt=None, plot_pmask=None, callset=None):
        if plot_pmask is None:
            plot_pmask = [0, 1]
        if plot_gt is None:
            plot_gt = [0, 1, 2, 3]
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, figsize=(12, 8), dpi=90, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(8)
            self.fig.set_figwidth(12)
        chroms = []
        if self.reference_genome is None:
            chroms = self.io[self.plot_file].snp_chromosomes()
        else:
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
                if callset is None:
                    if self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP pos&#34;, 0) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP desc&#34;, 0) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP counts&#34;, 0) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP qual&#34;, 0) and \
                            (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append(snp_chr)
                else:
                    if self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP pos&#34;, 0, name=callset) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP desc&#34;, 0, name=callset) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP counts&#34;, 0, name=callset) and \
                            self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP qual&#34;, 0, name=callset) and \
                            (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append(snp_chr)
        sx, sy = self.panels_shape(len(chroms))
        ix = 1
        for c in chroms:
            pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_file].read_snp(c, callset=callset)
            hpos = []
            baf = []
            color = []
            for i in range(len(pos)):
                if (nref[i] + nalt[i]) != 0:
                    if (gt[i] % 4 in plot_gt) and ((flag[i] &gt;&gt; 1) in plot_pmask):
                        hpos.append(pos[i])
                        if gt[i] % 4 != 2:
                            baf.append(1.0 * nalt[i] / (nref[i] + nalt[i]))
                        else:
                            baf.append(1.0 * nref[i] / (nref[i] + nalt[i]))
                        color.append(self.snp_colors[(gt[i] % 4) * 2 + (flag[i] &gt;&gt; 1)])

            ax = plt.subplot(sx, sy, ix)
            ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], [])
            l = max(pos)
            ax.xaxis.set_ticks(np.arange(0, (l + 10e6), 10e6), [])
            ax.set_ylim([0., 1.])
            ax.set_xlim([-0.05 * l, 1.05 * l])
            ax.grid()
            if self.markersize == &#34;auto&#34;:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=0.7)
            else:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=0.7)
            ix += 1
        plt.subplots_adjust(bottom=0., top=1., wspace=0, hspace=0, left=0., right=1.)
        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;gview&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()


    @staticmethod
    def panels_shape(n):
        sx, sy = 1, 1
        if n == 2:
            sx = 2
        elif n in [3, 4]:
            sx, sy = 2, 2
        elif n in [5, 6]:
            sx, sy = 3, 2
        elif n in [7, 8, 9]:
            sx, sy = 3, 3
        elif n in [10, 11, 12]:
            sx, sy = 4, 3
        elif n in [13, 14, 15, 16]:
            sx, sy = 4, 4
        elif n in [17, 18, 19, 20]:
            sx, sy = 5, 4
        elif n in [21, 22, 23, 24]:
            sx, sy = 6, 4
        else:
            while sx * sy &lt; n:
                sx += 1
                sy = int(2. * sx / 3 + 1.)
        return sx, sy

    def manhattan(self, bin_size, use_mask=False, plot_type=&#34;rd&#34;):
        plt.clf()
        if self.reference_genome is None:
            _logger.warning(&#34;Missing reference genome required for gview.&#34;)
            return
        n = len(self.plot_files)
        ix = self.plot_files

        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(1.5 * n)
            self.fig.set_figwidth(12)
        grid = gridspec.GridSpec(n, 1, wspace=0.2, hspace=0.2)
        for i in range(n):
            ax = self.fig.add_subplot(grid[i])
            io = self.io[ix[i]]
            ax.set_title(io.filename, position=(0.01, 1.07),
                         fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})

            if plot_type == &#34;rd&#34;:
                chroms = []
                for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                    rd_chr = io.rd_chromosome_name(c)
                    if len(self.chrom) == 0 or (rd_chr in self.chrom) or (c in self.chrom):
                        if io.signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                                io.signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                            chroms.append((rd_chr, l))

                apos = 0
                xticks = [0]

                max_m = 0
                for c, l in chroms:
                    flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
                    stat = io.get_signal(None, bin_size, &#34;RD stat&#34;, flag)
                    if stat[4] &gt; max_m:
                        max_m = stat[4]
                    flag_rd = 0
                    if use_mask:
                        flag_rd = FLAG_USEMASK
                    his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                    his_p_corr = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
                    if self.rd_manhattan_call:
                        his_p_call = io.get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
                        his_p_mosaic_seg = io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                         flag_rd | FLAG_GC_CORR)
                        his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
                        his_p_mosaic_call = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                          flag_rd | FLAG_GC_CORR)
                        his_p_mosaic = np.zeros_like(his_p) * np.nan
                        if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                            for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                                for segi in seg:
                                    his_p_mosaic[segi] = lev
                    pos = range(apos, apos + len(his_p))
                    ax.text(apos + len(his_p) // 2, stat[4] // 10, Genome.canonical_chrom_name(c),
                            fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                    if self.markersize == &#34;auto&#34;:
                        plt.plot(pos, his_p_corr, ls=&#39;&#39;, marker=&#39;.&#39;)
                    else:
                        plt.plot(pos, his_p_corr, ls=&#39;&#39;, marker=&#39;.&#39;, markersize=self.markersize)
                    if self.rd_manhattan_call:
                        if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call:
                            plt.step(pos, his_p_call, &#34;r&#34;)
                        if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                            plt.plot(pos, his_p_mosaic, &#34;k&#34;)
                    apos += len(his_p)
                    xticks.append(apos)
                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks(np.arange(0, 15, 0.5) * max_m, [])
                ax.xaxis.set_ticks(xticks, [])
                ax.set_ylim([self.rd_manhattan_range[0] * max_m, self.rd_manhattan_range[1] * max_m])
            else:
                chroms = []
                snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
                for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                    snp_chr = io.snp_chromosome_name(c)
                    if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                        if io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood call&#34;, snp_flag) and \
                                io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood segments&#34;, snp_flag) and \
                                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                            chroms.append((snp_chr, l))

                apos = 0
                xticks = [0]

                cix = 0
                cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
                for c, l in chroms:
                    flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO

                    likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                    segments = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
                    call_pos = []
                    call_baf = []
                    call_c = []
                    for s, lh in zip(segments, likelihood):
                        b, p = likelihood_baf_pval(lh)
                        if b &gt; 0 and len(s) &gt; self.min_segment_size:
                            alpha = -np.log(p + 1e-40) / self.contrast
                            if alpha &gt; 1:
                                alpha = 1
                            for pos in s:
                                call_pos.append(apos + pos)
                                call_baf.append(b)
                                color = cmap[cix % len(cmap)]
                                color = (color[0], color[1], color[2], alpha)
                                call_c.append(color)

                    ax.text(apos + l // bin_size // 2, 0.4, Genome.canonical_chrom_name(c),
                            fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                    plt.scatter(call_pos, call_baf, s=20, color=np.array(call_c), edgecolors=&#39;face&#39;, marker=&#39;|&#39;)
                    # plt.plot(call_pos, call_baf, color=np.array(call_c), ls=&#39;&#39;, marker=&#39;.&#39;)
                    apos += l // bin_size
                    xticks.append(apos)
                    cix += 1

                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks(np.arange(0, 0.5, 0.1), [])
                ax.xaxis.set_ticks(xticks, [])
                ax.set_ylim([0, 0.5])

            n_bins = apos
            ax.set_xlim([0, n_bins])
            ax.grid()
        plt.subplots_adjust(bottom=0.05, top=0.95, wspace=0, hspace=0, left=0.05, right=0.95)

        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;manhattan&#34; if plot_type == &#34;rd&#34; else &#34;snp_calls&#34;), dpi=200)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def multiple_regions(self, bin_size, regions, panels=[&#34;rd&#34;], sep_color=&#34;g&#34;):
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, figsize=(12, 8), facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        grid = gridspec.GridSpec(len(self.io), len(regions), wspace=0.2, hspace=0.2)
        ix = 0
        for i in self.io:
            for r in regions:
                self.regions(i, grid[ix], bin_size, r, panels=panels, sep_color=sep_color)
                ix += 1
        plt.subplots_adjust(bottom=0.05, top=0.95, wspace=0, hspace=0, left=0.05, right=0.95)

        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;regions&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def regions(self, io, element, bin_size, region, panels=[&#34;rd&#34;], sep_color=&#34;g&#34;):
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
        grid = gridspec.GridSpecFromSubplotSpec(len(panels), 1, subplot_spec=element, wspace=0, hspace=0.1)
        r = decode_region(region)
        for i in range(len(panels)):
            ax = self.fig.add_subplot(grid[i])
            if i == 0:
                ax.set_title(io.filename + &#34;: &#34; + region, position=(0.01, 0.9),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                             color=&#39;C0&#39;)

            if panels[i] == &#34;rd&#34;:
                g_p = []
                g_p_corr = []
                g_p_seg = []
                g_p_call = []
                g_p_call_mosaic = []
                mean, stdev = 0, 0
                borders = []
                for c, (pos1, pos2) in r:
                    flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
                    flag_rd = 0
                    if self.rd_use_mask:
                        flag_rd = FLAG_USEMASK
                    stat = io.get_signal(None, bin_size, &#34;RD stat&#34;, flag)
                    mean = stat[4]
                    stdev = stat[5]
                    his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                    his_p_corr = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_seg = io.get_signal(c, bin_size, &#34;RD partition&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_call = io.get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg = io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                     flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
                    his_p_mosaic_call = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                      flag_rd | FLAG_GC_CORR)
                    his_p_mosaic = np.zeros_like(his_p) * np.nan
                    if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                        for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                            for segi in seg:
                                his_p_mosaic[segi] = lev

                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    g_p.extend(list(his_p[start_bin:end_bin]))
                    g_p_corr.extend(list(his_p_corr[start_bin:end_bin]))
                    if his_p_seg is not None and len(his_p_seg) &gt; 0 and self.rd_partition:
                        g_p_seg.extend(list(his_p_seg[start_bin:end_bin]))
                    if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call:
                        g_p_call.extend(list(his_p_call[start_bin:end_bin]))
                    if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                        g_p_call_mosaic.extend(list(his_p_mosaic[start_bin:end_bin]))
                    borders.append(len(g_p) - 1)

                # ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                l = len(g_p)
                # ax.xaxis.set_ticks(np.arange(0, l, 10), [])
                ax.yaxis.set_ticks(np.arange(0, 3, 0.5) * mean, [])
                ax.set_ylim([0, max(3. * mean, mean + 5. * stdev)])
                ax.set_xlim([-l * 0.0, l * 1.0])

                ax.yaxis.grid()
                ax.step(g_p, &#34;grey&#34;)
                ax.step(g_p_corr, &#34;k&#34;)
                if len(g_p_seg) &gt; 0:
                    plt.step(g_p_seg, &#34;r&#34;)
                if len(g_p_call) &gt; 0:
                    plt.step(g_p_call, &#34;g&#34;)
                if len(g_p_call_mosaic) &gt; 0:
                    plt.step(g_p_call_mosaic, &#34;b&#34;)
                for i in borders[:-1]:
                    ax.axvline(i, color=sep_color, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;snp&#34;:
                borders = []
                hpos = []
                baf = []
                color = []
                start_pos = 0
                for c, (pos1, pos2) in r:
                    pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c)
                    ix = 0
                    mdp = 0
                    while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                        if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0:
                            hpos.append(start_pos + pos[ix] - pos1)
                            if pos[ix] - pos1 &gt; mdp:
                                mdp = pos[ix] - pos1
                            if gt[ix] % 4 != 2:
                                baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            else:
                                baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                            color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                        ix += 1
                    start_pos += mdp
                    borders.append(start_pos)

                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], [])
                l = max(hpos)
                # ax.xaxis.set_ticks(np.arange(0, (l + 10e6), 10e6), [])
                ax.set_ylim([0., 1.])
                ax.set_xlim([0, borders[-1]])
                ax.yaxis.grid()
                if self.markersize == &#34;auto&#34;:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=0.7)
                else:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=0.7)

                for i in borders[:-1]:
                    ax.axvline(i, color=sep_color, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;snv&#34; or panels[i][:4] == &#34;snv:&#34;:
                callset = &#34;default&#34;
                if panels[i][:4] == &#34;snv:&#34;:
                    callset=panels[i].split(&#34;:&#34;)[1]
                borders = []
                hpos = []
                baf = []
                color = []
                start_pos = 0
                for c, (pos1, pos2) in r:
                    pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c,callset=callset)
                    ix = 0
                    mdp = 0
                    while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                        if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0:
                            hpos.append(start_pos + pos[ix] - pos1)
                            if pos[ix] - pos1 &gt; mdp:
                                mdp = pos[ix] - pos1
                            if gt[ix] % 4 != 2:
                                baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                            else:
                                baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                            color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                        ix += 1
                    start_pos += mdp
                    borders.append(start_pos)

                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], [])
                l = max(hpos)
                # ax.xaxis.set_ticks(np.arange(0, (l + 10e6), 10e6), [])
                ax.set_ylim([0., 1.])
                ax.set_xlim([0, borders[-1]])
                ax.yaxis.grid()
                if self.markersize == &#34;auto&#34;:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=0.7)
                else:
                    ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=0.7)

                for i in borders[:-1]:
                    ax.axvline(i, color=sep_color, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;baf&#34;:
                g_baf, g_maf, g_i1, g_i2 = [], [], [], []
                borders = []
                for c, (pos1, pos2) in r:
                    flag_snp = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                        FLAG_USEHAP if self.snp_use_phase else 0)
                    baf = io.get_signal(c, bin_size, &#34;SNP baf&#34;, flag_snp)
                    maf = io.get_signal(c, bin_size, &#34;SNP maf&#34;, flag_snp)
                    i1 = io.get_signal(c, bin_size, &#34;SNP i1&#34;, flag_snp)
                    i2 = io.get_signal(c, bin_size, &#34;SNP i2&#34;, flag_snp)

                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    g_baf.extend(list(baf[start_bin:end_bin]))
                    g_maf.extend(list(maf[start_bin:end_bin]))
                    g_i1.extend(list(i1[start_bin:end_bin]))
                    g_i2.extend(list(i2[start_bin:end_bin]))
                    borders.append(len(g_baf) - 1)

                # ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                l = len(g_baf)
                # ax.xaxis.set_ticks(np.arange(0, l, 10), [])
                ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], [])
                ax.set_ylim([0, 1])
                ax.set_xlim([-l * 0.0, l * 1.0])

                ax.yaxis.grid()
                ax.step(g_baf, &#34;grey&#34;)
                ax.step(g_maf, &#34;k&#34;)
                ax.step(g_i1, &#34;r&#34;)
                for i in borders[:-1]:
                    ax.axvline(i, color=sep_color, lw=1)
                self.fig.add_subplot(ax)

            elif panels[i] == &#34;likelihood&#34;:
                borders = []
                gl = []
                for c, (pos1, pos2) in r:
                    likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
                    start_bin = (pos1 - 1) // bin_size
                    end_bin = pos2 // bin_size
                    gl.extend(list(likelihood[start_bin:end_bin]))
                    borders.append(len(gl) - 1)
                img = np.array(gl).transpose()
                ax.imshow(img, aspect=&#39;auto&#39;)
                ax.xaxis.set_ticklabels([])
                ax.yaxis.set_ticklabels([])
                ax.xaxis.set_ticks(np.arange(0, len(gl), 50), [])

                for i in borders[:-1]:
                    ax.axvline(i, color=sep_color, lw=1)
                self.fig.add_subplot(ax)

    def circular(self, bin_size, chroms=[], use_mask_rd=True):
        n = len(self.plot_files)
        ix = self.plot_files
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
        rd_flag = FLAG_GC_CORR | (FLAG_USEMASK if use_mask_rd else 0)
        if self.grid == &#34;auto&#34;:
            sx, sy = self.panels_shape(n)
        else:
            sx, sy = self.grid
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(sy * 8)
            self.fig.set_figwidth(sx * 8)
        grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        for i in range(n):
            ax = self.fig.add_subplot(grid[i], projection=&#39;polar&#39;)
            ax.set_theta_zero_location(&#34;N&#34;)
            ax.set_theta_direction(-1)
            io = self.io[ix[i]]
            plot_len = 0
            plot_chroms = []
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                rd_chr = io.rd_chromosome_name(c)
                if rd_chr is not None and (len(chroms) == 0 or (rd_chr in chroms) or (c in chroms)) and (
                        Genome.is_autosome(c) or Genome.is_sex_chrom(c)
                ) and io.signal_exists(rd_chr, bin_size, &#34;SNP maf&#34;, snp_flag) and io.signal_exists(
                    rd_chr, bin_size, &#34;RD&#34;, rd_flag):
                    plot_chroms.append((rd_chr, l))
                    plot_len += l // bin_size + 1
            rd_mean = io.get_signal(None, bin_size, &#34;RD stat&#34;, FLAG_AUTO)[4]
            tl = 0
            dt = 2.0 * np.pi / plot_len
            theta = np.arange(0, 2.0 * np.pi, dt)
            angles = []
            labels = []
            for j in range(len(plot_chroms)):
                c, l = plot_chroms[j]
                rd_color = self.palette1[j % len(self.palette1)]
                snp_color = self.palette2[j % len(self.palette2)]
                rd = io.get_signal(c, bin_size, &#34;RD&#34;, rd_flag)
                maf = io.get_signal(c, bin_size, &#34;SNP maf&#34;, snp_flag)
                plt.polar(theta[tl:tl + maf.size], 1 - maf, color=snp_color, linewidth=0.3)
                plt.fill_between(theta[tl:tl + maf.size], 1 - maf, np.ones_like(maf), color=snp_color, alpha=0.8)
                plt.polar(theta[tl:tl + rd.size], rd / (3. * rd_mean), color=rd_color, linewidth=0.3)
                plt.fill_between(theta[tl:tl + rd.size], np.ones_like(rd) / 10., rd / (3. * rd_mean), color=rd_color,
                                 alpha=0.8)
                # ax.text(theta[tl + maf.size // 3], 0.8, c, fontsize=8)
                labels.append(Genome.canonical_chrom_name(c))
                angles.append(180 * theta[tl + rd.size // 2] / np.pi)
                tl += l // bin_size + 1
            ax.set_rmax(0.9)
            ax.set_rticks([])
            ax.set_thetagrids(angles, labels=labels, fontsize=10, weight=&#34;bold&#34;, color=&#34;black&#34;)
            ax.set_title(io.filename.split(&#34;/&#34;)[-1], loc=&#34;left&#34;, fontsize=10, weight=&#34;bold&#34;, color=&#34;black&#34;)
            ax.grid(False)
        plt.subplots_adjust(bottom=0.05, top=0.95, wspace=0.2, hspace=0.2, left=0.05, right=0.95)
        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;circular&#34;), dpi=200)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def rd_baf(self, hist=True):
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, figsize=(12, 8), facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        n = len(self.plot_files)
        ix = self.plot_files
        if self.grid == &#34;auto&#34;:
            sx, sy = self.panels_shape(n)
        else:
            sx, sy = tuple(self.grid)
        grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        bin_size = self.bin_size
        for i in range(n):
            ax = self.fig.add_subplot(grid[i])
            io = self.io[ix[i]]


            chroms = []
            snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
            rd_flag = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = io.snp_chromosome_name(c)
                if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                    if io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood call&#34;, snp_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood segments&#34;, snp_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;RD mosaic call&#34;, rd_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;RD mosaic segments&#34;, rd_flag) and \
                            Genome.is_autosome(c):
                        chroms.append((snp_chr, l))
            x=[]
            y=[]
            for c, l in chroms:
                flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO

                likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                segments_baf = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
                rd = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;, rd_flag)
                segments_rd = segments_decode(io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;, rd_flag))

                mbaf={}
                mrd={}
                for s, lh in zip(segments_baf, likelihood):
                    b, p = likelihood_baf_pval(lh)
                    for pos in s:
                        mbaf[pos]=0.5-b
                for s, r in zip(segments_rd, rd[0]):
                    for pos in s:
                        mrd[pos]=r
                for p in mbaf:
                    if p in mrd:
                        x.append(mbaf[p])
                        y.append(mrd[p])

            if hist:
                from matplotlib.colors import LogNorm
                ax.hist2d(x,y,bins=[np.arange(0,0.51,0.01),np.arange(0,max(y),max(y)/100.)],norm=LogNorm())
            else:
                ax.scatter(x,y,marker=&#34;.&#34;,alpha=0.5)

        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;regions&#34;), dpi=150)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def dispersion(self, legend=True):
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        self.fig = plt.figure(1, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(8)
            self.fig.set_figwidth(12)
        grid = gridspec.GridSpec(1, 2, wspace=0.2, hspace=0.2)

        ax = self.fig.add_subplot(grid[0])
        for i in self.io:
            bin_sizes = sorted(set([int(x[1]) for x in i.chromosomes_bin_sizes_with_signal(&#34;RD&#34;)]))
            rd = []
            drd = []
            for bs in bin_sizes:
                if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO):
                    stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO)
                    rd.append(stat[4])
                    drd.append(stat[5])
            ax.set_yscale(&#34;log&#34;)
            ax.set_xscale(&#34;log&#34;)
            ax.grid(True)
            ax.set_xlabel(&#34;mean RD&#34;)
            ax.set_ylabel(&#34;stdev RD&#34;)
            if legend:
                ax.legend(loc=&#34;upper left&#34;)
            ax.plot(rd, drd, &#34;*-&#34;, label=i.filename)

        ax = self.fig.add_subplot(grid[1])
        for i in self.io:
            bin_sizes = sorted(set([int(x[1]) for x in i.chromosomes_bin_sizes_with_signal(&#34;RD&#34;)]))
            rd = []
            drd = []
            for bs in bin_sizes:
                if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO | FLAG_GC_CORR):
                    stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO | FLAG_GC_CORR)
                    rd.append(stat[4])
                    drd.append(stat[5])
            ax.set_yscale(&#34;log&#34;)
            ax.set_xscale(&#34;log&#34;)
            ax.grid(True)
            ax.set_xlabel(&#34;mean RD (GC corr)&#34;)
            ax.set_ylabel(&#34;stdev RD (GC corr)&#34;)
            if legend:
                ax.legend(loc=&#34;upper left&#34;)
            ax.plot(rd, drd, &#34;*-&#34;, label=i.filename)

        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;dispersion&#34;), dpi=200)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()

    def compare(self, region1, region2, n_bins=21, plot=False, legend=True):
        n = len(self.plot_files)
        ix = self.plot_files
        if plot:
            plt.clf()
            plt.rcParams[&#34;font.size&#34;] = 8
            if self.grid == &#34;auto&#34;:
                sx, sy = self.panels_shape(n)
            else:
                sx, sy = tuple(self.grid)
            self.fig = plt.figure(1, dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
            if self.output_filename != &#34;&#34;:
                self.fig.set_figheight(3 * sy)
                self.fig.set_figwidth(4 * sx)
            grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
        for i in range(n):
            io = self.io[ix[i]]
            if plot:
                ax = self.fig.add_subplot(grid[i])
                ax.set_title(io.filename, position=(0.01, 1.07),
                             fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
            stat = io.get_signal(None, self.bin_size, &#34;RD stat&#34;, FLAG_AUTO)
            regs1 = decode_region(region1)
            regs2 = decode_region(region2)
            data1 = []
            data2 = []
            for c, (pos1, pos2) in regs1:
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size
                data1 += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])
            for c, (pos1, pos2) in regs2:
                flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
                his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // self.bin_size
                bin2 = (pos2 - 1) // self.bin_size
                data2 += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])

            data1 = np.array(data1)
            p1_1 = np.percentile(data1, 1)
            p99_1 = np.percentile(data1, 99)
            data1 = data1[data1 &gt; p1_1]
            data1 = data1[data1 &lt; p99_1]
            mean1 = np.mean(data1)
            std1 = np.std(data1)

            data2 = np.array(data2)
            p1_2 = np.percentile(data2, 1)
            p99_2 = np.percentile(data2, 99)
            data2 = data2[data2 &gt; p1_2]
            data2 = data2[data2 &lt; p99_2]
            mean2 = np.mean(data2)
            std2 = np.std(data2)

            rd_min = min(mean1 - 5 * std1, mean2 - 5 * std2)
            rd_max = max(mean1 + 5 * std1, mean2 + 5 * std2)
            bins = np.linspace(rd_min, rd_max, n_bins)

            hist1, binsr = np.histogram(data1, bins=bins)
            hist2, binsr = np.histogram(data2, bins=bins)

            fitn1, fitm1, fits1 = fit_normal(bins[:-1], hist1)[0]
            fitn2, fitm2, fits2 = fit_normal(bins[:-1], hist2)[0]

            pval = t_test_2_samples(fitm1, fits1, sum(hist1), fitm2, fits2, sum(hist2))

            print(&#34;%s\t%s\t%s\t%.4f\t%.4f\t%.4f\t%.4f\t%e\t%.4f\t%.4f&#34; % (
                io.filename, region1, region2, fitm1, fits1, fitm2, fits2, pval, fitm1 / fitm2,
                fitm1 / fitm2 * (fits1 / fitm1 / np.sqrt(sum(hist1)) + fits2 / fitm2 / np.sqrt(sum(hist2)))))

            if plot:
                x = np.linspace(bins[0], bins[-1], 1001)
                plt.plot(x, normal(x, fitn1, fitm1, fits1), &#34;g-&#34;, label=region1)
                plt.plot(x, normal(x, fitn2, fitm2, fits2), &#34;b-&#34;, label=region2)
                plt.plot(bins[:-1], hist1, &#34;g*&#34;)
                plt.plot(bins[:-1], hist2, &#34;b*&#34;)
                if legend:
                    plt.legend()

        if plot:
            if self.output_filename != &#34;&#34;:
                plt.savefig(self.image_filename(&#34;comp&#34;), dpi=200)
                plt.close(self.fig)
            elif self.interactive:
                plt.show(block=False)
                plt.draw()
            else:
                plt.show()

    def genotype(self, bin_sizes, region):
        regs = decode_region(region)
        for c, (pos1, pos2) in regs:
            print(c + &#34;:&#34; + str(pos1) + &#34;:&#34; + str(pos2), end=&#34;&#34;)
            for bs in bin_sizes:
                flag_rd = FLAG_GC_CORR if self.rd_use_gc_corr else o
                stat = self.io[self.plot_file].get_signal(c, bs, &#34;RD stat&#34;, flag_rd)
                his_p = self.io[self.plot_file].get_signal(c, bs, &#34;RD&#34;, flag_rd)
                bin1 = (pos1 - 1) // bs
                bin2 = (pos2 - 1) // bs
                rc = 0
                if bin1 == bin2:
                    rc = (pos2 - pos1 + 1) * his_p[bin1] / bs
                else:
                    rc += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] / bs
                    rc += (pos2 - bin2 * bs) * his_p[bin1] / bs
                    for ix in range(bin1 + 1, bin2):
                        rc += his_p[ix]
                print(&#34;\t%f&#34; % rc * stat[4] * (pos2 - pos1 + 1) / bs, end=&#34;&#34;)
        print()

    def genotype_prompt(self, bin_sizes=[]):
        done = False
        while not done:
            try:
                try:
                    line = raw_input(&#34;&#34;)
                except NameError:
                    line = input(&#34;&#34;)
            except EOFError:
                return
            if line is None or line == &#34;&#34;:
                done = True
            else:
                self.genotype(bin_sizes, line)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cnvpytor.viewer.Show" href="#cnvpytor.viewer.Show">Show</a></li>
<li><a title="cnvpytor.viewer.Reader" href="#cnvpytor.viewer.Reader">Reader</a></li>
<li><a title="cnvpytor.viewparams.ViewParams" href="viewparams.html#cnvpytor.viewparams.ViewParams">ViewParams</a></li>
<li><a title="cnvpytor.viewparams.HelpDescription" href="viewparams.html#cnvpytor.viewparams.HelpDescription">HelpDescription</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cnvpytor.viewer.Viewer.panels_shape"><code class="name flex">
<span>def <span class="ident">panels_shape</span></span>(<span>n)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def panels_shape(n):
    sx, sy = 1, 1
    if n == 2:
        sx = 2
    elif n in [3, 4]:
        sx, sy = 2, 2
    elif n in [5, 6]:
        sx, sy = 3, 2
    elif n in [7, 8, 9]:
        sx, sy = 3, 3
    elif n in [10, 11, 12]:
        sx, sy = 4, 3
    elif n in [13, 14, 15, 16]:
        sx, sy = 4, 4
    elif n in [17, 18, 19, 20]:
        sx, sy = 5, 4
    elif n in [21, 22, 23, 24]:
        sx, sy = 6, 4
    else:
        while sx * sy &lt; n:
            sx += 1
            sy = int(2. * sx / 3 + 1.)
    return sx, sy</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.set_style"><code class="name flex">
<span>def <span class="ident">set_style</span></span>(<span>style)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def set_style(style):
    if style in plt.style.available:
        plt.style.use(&#34;default&#34;)
        plt.style.use(style)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cnvpytor.viewer.Viewer.circular"><code class="name flex">
<span>def <span class="ident">circular</span></span>(<span>self, bin_size, chroms=[], use_mask_rd=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def circular(self, bin_size, chroms=[], use_mask_rd=True):
    n = len(self.plot_files)
    ix = self.plot_files
    snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
    rd_flag = FLAG_GC_CORR | (FLAG_USEMASK if use_mask_rd else 0)
    if self.grid == &#34;auto&#34;:
        sx, sy = self.panels_shape(n)
    else:
        sx, sy = self.grid
    plt.clf()
    plt.rcParams[&#34;font.size&#34;] = 8
    self.fig = plt.figure(1, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    if self.output_filename != &#34;&#34;:
        self.fig.set_figheight(sy * 8)
        self.fig.set_figwidth(sx * 8)
    grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
    for i in range(n):
        ax = self.fig.add_subplot(grid[i], projection=&#39;polar&#39;)
        ax.set_theta_zero_location(&#34;N&#34;)
        ax.set_theta_direction(-1)
        io = self.io[ix[i]]
        plot_len = 0
        plot_chroms = []
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            rd_chr = io.rd_chromosome_name(c)
            if rd_chr is not None and (len(chroms) == 0 or (rd_chr in chroms) or (c in chroms)) and (
                    Genome.is_autosome(c) or Genome.is_sex_chrom(c)
            ) and io.signal_exists(rd_chr, bin_size, &#34;SNP maf&#34;, snp_flag) and io.signal_exists(
                rd_chr, bin_size, &#34;RD&#34;, rd_flag):
                plot_chroms.append((rd_chr, l))
                plot_len += l // bin_size + 1
        rd_mean = io.get_signal(None, bin_size, &#34;RD stat&#34;, FLAG_AUTO)[4]
        tl = 0
        dt = 2.0 * np.pi / plot_len
        theta = np.arange(0, 2.0 * np.pi, dt)
        angles = []
        labels = []
        for j in range(len(plot_chroms)):
            c, l = plot_chroms[j]
            rd_color = self.palette1[j % len(self.palette1)]
            snp_color = self.palette2[j % len(self.palette2)]
            rd = io.get_signal(c, bin_size, &#34;RD&#34;, rd_flag)
            maf = io.get_signal(c, bin_size, &#34;SNP maf&#34;, snp_flag)
            plt.polar(theta[tl:tl + maf.size], 1 - maf, color=snp_color, linewidth=0.3)
            plt.fill_between(theta[tl:tl + maf.size], 1 - maf, np.ones_like(maf), color=snp_color, alpha=0.8)
            plt.polar(theta[tl:tl + rd.size], rd / (3. * rd_mean), color=rd_color, linewidth=0.3)
            plt.fill_between(theta[tl:tl + rd.size], np.ones_like(rd) / 10., rd / (3. * rd_mean), color=rd_color,
                             alpha=0.8)
            # ax.text(theta[tl + maf.size // 3], 0.8, c, fontsize=8)
            labels.append(Genome.canonical_chrom_name(c))
            angles.append(180 * theta[tl + rd.size // 2] / np.pi)
            tl += l // bin_size + 1
        ax.set_rmax(0.9)
        ax.set_rticks([])
        ax.set_thetagrids(angles, labels=labels, fontsize=10, weight=&#34;bold&#34;, color=&#34;black&#34;)
        ax.set_title(io.filename.split(&#34;/&#34;)[-1], loc=&#34;left&#34;, fontsize=10, weight=&#34;bold&#34;, color=&#34;black&#34;)
        ax.grid(False)
    plt.subplots_adjust(bottom=0.05, top=0.95, wspace=0.2, hspace=0.2, left=0.05, right=0.95)
    if self.output_filename != &#34;&#34;:
        plt.savefig(self.image_filename(&#34;circular&#34;), dpi=200)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, region1, region2, n_bins=21, plot=False, legend=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def compare(self, region1, region2, n_bins=21, plot=False, legend=True):
    n = len(self.plot_files)
    ix = self.plot_files
    if plot:
        plt.clf()
        plt.rcParams[&#34;font.size&#34;] = 8
        if self.grid == &#34;auto&#34;:
            sx, sy = self.panels_shape(n)
        else:
            sx, sy = tuple(self.grid)
        self.fig = plt.figure(1, dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
        if self.output_filename != &#34;&#34;:
            self.fig.set_figheight(3 * sy)
            self.fig.set_figwidth(4 * sx)
        grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
    for i in range(n):
        io = self.io[ix[i]]
        if plot:
            ax = self.fig.add_subplot(grid[i])
            ax.set_title(io.filename, position=(0.01, 1.07),
                         fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})
        stat = io.get_signal(None, self.bin_size, &#34;RD stat&#34;, FLAG_AUTO)
        regs1 = decode_region(region1)
        regs2 = decode_region(region2)
        data1 = []
        data2 = []
        for c, (pos1, pos2) in regs1:
            flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
            his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
            bin1 = (pos1 - 1) // self.bin_size
            bin2 = (pos2 - 1) // self.bin_size
            data1 += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])
        for c, (pos1, pos2) in regs2:
            flag_rd = (FLAG_GC_CORR if self.rd_use_gc_corr else 0) | (FLAG_USEMASK if self.rd_use_mask else 0)
            his_p = io.get_signal(c, self.bin_size, &#34;RD&#34;, flag_rd)
            bin1 = (pos1 - 1) // self.bin_size
            bin2 = (pos2 - 1) // self.bin_size
            data2 += list(his_p[bin1:bin2 + 1][np.isfinite(his_p[bin1:bin2 + 1])])

        data1 = np.array(data1)
        p1_1 = np.percentile(data1, 1)
        p99_1 = np.percentile(data1, 99)
        data1 = data1[data1 &gt; p1_1]
        data1 = data1[data1 &lt; p99_1]
        mean1 = np.mean(data1)
        std1 = np.std(data1)

        data2 = np.array(data2)
        p1_2 = np.percentile(data2, 1)
        p99_2 = np.percentile(data2, 99)
        data2 = data2[data2 &gt; p1_2]
        data2 = data2[data2 &lt; p99_2]
        mean2 = np.mean(data2)
        std2 = np.std(data2)

        rd_min = min(mean1 - 5 * std1, mean2 - 5 * std2)
        rd_max = max(mean1 + 5 * std1, mean2 + 5 * std2)
        bins = np.linspace(rd_min, rd_max, n_bins)

        hist1, binsr = np.histogram(data1, bins=bins)
        hist2, binsr = np.histogram(data2, bins=bins)

        fitn1, fitm1, fits1 = fit_normal(bins[:-1], hist1)[0]
        fitn2, fitm2, fits2 = fit_normal(bins[:-1], hist2)[0]

        pval = t_test_2_samples(fitm1, fits1, sum(hist1), fitm2, fits2, sum(hist2))

        print(&#34;%s\t%s\t%s\t%.4f\t%.4f\t%.4f\t%.4f\t%e\t%.4f\t%.4f&#34; % (
            io.filename, region1, region2, fitm1, fits1, fitm2, fits2, pval, fitm1 / fitm2,
            fitm1 / fitm2 * (fits1 / fitm1 / np.sqrt(sum(hist1)) + fits2 / fitm2 / np.sqrt(sum(hist2)))))

        if plot:
            x = np.linspace(bins[0], bins[-1], 1001)
            plt.plot(x, normal(x, fitn1, fitm1, fits1), &#34;g-&#34;, label=region1)
            plt.plot(x, normal(x, fitn2, fitm2, fits2), &#34;b-&#34;, label=region2)
            plt.plot(bins[:-1], hist1, &#34;g*&#34;)
            plt.plot(bins[:-1], hist2, &#34;b*&#34;)
            if legend:
                plt.legend()

    if plot:
        if self.output_filename != &#34;&#34;:
            plt.savefig(self.image_filename(&#34;comp&#34;), dpi=200)
            plt.close(self.fig)
        elif self.interactive:
            plt.show(block=False)
            plt.draw()
        else:
            plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.dispersion"><code class="name flex">
<span>def <span class="ident">dispersion</span></span>(<span>self, legend=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def dispersion(self, legend=True):
    plt.clf()
    plt.rcParams[&#34;font.size&#34;] = 8
    self.fig = plt.figure(1, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    if self.output_filename != &#34;&#34;:
        self.fig.set_figheight(8)
        self.fig.set_figwidth(12)
    grid = gridspec.GridSpec(1, 2, wspace=0.2, hspace=0.2)

    ax = self.fig.add_subplot(grid[0])
    for i in self.io:
        bin_sizes = sorted(set([int(x[1]) for x in i.chromosomes_bin_sizes_with_signal(&#34;RD&#34;)]))
        rd = []
        drd = []
        for bs in bin_sizes:
            if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO):
                stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO)
                rd.append(stat[4])
                drd.append(stat[5])
        ax.set_yscale(&#34;log&#34;)
        ax.set_xscale(&#34;log&#34;)
        ax.grid(True)
        ax.set_xlabel(&#34;mean RD&#34;)
        ax.set_ylabel(&#34;stdev RD&#34;)
        if legend:
            ax.legend(loc=&#34;upper left&#34;)
        ax.plot(rd, drd, &#34;*-&#34;, label=i.filename)

    ax = self.fig.add_subplot(grid[1])
    for i in self.io:
        bin_sizes = sorted(set([int(x[1]) for x in i.chromosomes_bin_sizes_with_signal(&#34;RD&#34;)]))
        rd = []
        drd = []
        for bs in bin_sizes:
            if i.signal_exists(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO | FLAG_GC_CORR):
                stat = i.get_signal(None, bs, &#34;RD stat&#34;, flags=FLAG_AUTO | FLAG_GC_CORR)
                rd.append(stat[4])
                drd.append(stat[5])
        ax.set_yscale(&#34;log&#34;)
        ax.set_xscale(&#34;log&#34;)
        ax.grid(True)
        ax.set_xlabel(&#34;mean RD (GC corr)&#34;)
        ax.set_ylabel(&#34;stdev RD (GC corr)&#34;)
        if legend:
            ax.legend(loc=&#34;upper left&#34;)
        ax.plot(rd, drd, &#34;*-&#34;, label=i.filename)

    if self.output_filename != &#34;&#34;:
        plt.savefig(self.image_filename(&#34;dispersion&#34;), dpi=200)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.genotype"><code class="name flex">
<span>def <span class="ident">genotype</span></span>(<span>self, bin_sizes, region)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def genotype(self, bin_sizes, region):
    regs = decode_region(region)
    for c, (pos1, pos2) in regs:
        print(c + &#34;:&#34; + str(pos1) + &#34;:&#34; + str(pos2), end=&#34;&#34;)
        for bs in bin_sizes:
            flag_rd = FLAG_GC_CORR if self.rd_use_gc_corr else o
            stat = self.io[self.plot_file].get_signal(c, bs, &#34;RD stat&#34;, flag_rd)
            his_p = self.io[self.plot_file].get_signal(c, bs, &#34;RD&#34;, flag_rd)
            bin1 = (pos1 - 1) // bs
            bin2 = (pos2 - 1) // bs
            rc = 0
            if bin1 == bin2:
                rc = (pos2 - pos1 + 1) * his_p[bin1] / bs
            else:
                rc += (bin1 * bs - pos1 + 1 + bs) * his_p[bin1] / bs
                rc += (pos2 - bin2 * bs) * his_p[bin1] / bs
                for ix in range(bin1 + 1, bin2):
                    rc += his_p[ix]
            print(&#34;\t%f&#34; % rc * stat[4] * (pos2 - pos1 + 1) / bs, end=&#34;&#34;)
    print()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.genotype_prompt"><code class="name flex">
<span>def <span class="ident">genotype_prompt</span></span>(<span>self, bin_sizes=[])</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def genotype_prompt(self, bin_sizes=[]):
    done = False
    while not done:
        try:
            try:
                line = raw_input(&#34;&#34;)
            except NameError:
                line = input(&#34;&#34;)
        except EOFError:
            return
        if line is None or line == &#34;&#34;:
            done = True
        else:
            self.genotype(bin_sizes, line)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.help"><code class="name flex">
<span>def <span class="ident">help</span></span>(<span>self, param)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def help(self, param):
    if param in self.param_help:
        print(self.param_help[param])
    else:
        print(&#34;\nUnknown parameter !\n&#34;)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.image_filename"><code class="name flex">
<span>def <span class="ident">image_filename</span></span>(<span>self, sufix)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def image_filename(self, sufix):
    parts = self.output_filename.split(&#34;.&#34;)
    if parts[-1] != &#34;png&#34; and parts[-1] != &#34;pdf&#34; and parts[-1] != &#34;jpg&#34; and parts[-1] != &#34;eps&#34; and parts[
        -1] != &#34;svg&#34;:
        _logger.warning(&#34;File extension should be: .jpg, .png, .svg, .eps or .pdf&#34;)
        exit(0)
    parts[-1] = sufix + &#34;.&#34; + parts[-1]
    return &#34;.&#34;.join(parts)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.likelihood"><code class="name flex">
<span>def <span class="ident">likelihood</span></span>(<span>self, bin_size)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def likelihood(self, bin_size):
    plt.clf()
    snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
    if self.reference_genome is None:
        _logger.warning(&#34;Missing reference genome required for gview.&#34;)
        return
    plt.rcParams[&#34;font.size&#34;] = 8
    chroms = []
    if self.reference_genome is None:
        chroms = self.io[self.plot_file].snp_chromosomes()
    else:
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
            if self.io[self.plot_file].signal_exists(snp_chr, bin_size, &#34;SNP likelihood&#34;, snp_flag) and (
                    Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                chroms.append(snp_chr)
    sx, sy = self.panels_shape(len(chroms))
    self.fig = plt.figure(1, figsize=(sx, sy), dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    if self.output_filename != &#34;&#34;:
        self.fig.set_figheight(8)
        self.fig.set_figwidth(12)
    ix = 1
    for c in chroms:
        likelihood = self.io[self.plot_file].get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
        img = np.array(likelihood).transpose()
        ax = plt.subplot(sx, sy, ix)
        ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                     color=&#39;C0&#39;)
        ax.imshow(img, aspect=&#39;auto&#39;)
        ax.xaxis.set_ticklabels([])
        ax.yaxis.set_ticklabels([])
        ax.xaxis.set_ticks(np.arange(0, likelihood.shape[0], 50), [])
        ix += 1
    plt.subplots_adjust(bottom=0., top=1., wspace=0, hspace=0, left=0., right=1.)
    if self.output_filename != &#34;&#34;:
        plt.savefig(self.image_filename(&#34;gview&#34;), dpi=150)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.manhattan"><code class="name flex">
<span>def <span class="ident">manhattan</span></span>(<span>self, bin_size, use_mask=False, plot_type='rd')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def manhattan(self, bin_size, use_mask=False, plot_type=&#34;rd&#34;):
    plt.clf()
    if self.reference_genome is None:
        _logger.warning(&#34;Missing reference genome required for gview.&#34;)
        return
    n = len(self.plot_files)
    ix = self.plot_files

    plt.clf()
    plt.rcParams[&#34;font.size&#34;] = 8
    self.fig = plt.figure(1, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    if self.output_filename != &#34;&#34;:
        self.fig.set_figheight(1.5 * n)
        self.fig.set_figwidth(12)
    grid = gridspec.GridSpec(n, 1, wspace=0.2, hspace=0.2)
    for i in range(n):
        ax = self.fig.add_subplot(grid[i])
        io = self.io[ix[i]]
        ax.set_title(io.filename, position=(0.01, 1.07),
                     fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;})

        if plot_type == &#34;rd&#34;:
            chroms = []
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                rd_chr = io.rd_chromosome_name(c)
                if len(self.chrom) == 0 or (rd_chr in self.chrom) or (c in self.chrom):
                    if io.signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                            io.signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                            (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append((rd_chr, l))

            apos = 0
            xticks = [0]

            max_m = 0
            for c, l in chroms:
                flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
                stat = io.get_signal(None, bin_size, &#34;RD stat&#34;, flag)
                if stat[4] &gt; max_m:
                    max_m = stat[4]
                flag_rd = 0
                if use_mask:
                    flag_rd = FLAG_USEMASK
                his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                his_p_corr = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
                if self.rd_manhattan_call:
                    his_p_call = io.get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg = io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                     flag_rd | FLAG_GC_CORR)
                    his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
                    his_p_mosaic_call = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                      flag_rd | FLAG_GC_CORR)
                    his_p_mosaic = np.zeros_like(his_p) * np.nan
                    if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                        for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                            for segi in seg:
                                his_p_mosaic[segi] = lev
                pos = range(apos, apos + len(his_p))
                ax.text(apos + len(his_p) // 2, stat[4] // 10, Genome.canonical_chrom_name(c),
                        fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                if self.markersize == &#34;auto&#34;:
                    plt.plot(pos, his_p_corr, ls=&#39;&#39;, marker=&#39;.&#39;)
                else:
                    plt.plot(pos, his_p_corr, ls=&#39;&#39;, marker=&#39;.&#39;, markersize=self.markersize)
                if self.rd_manhattan_call:
                    if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call:
                        plt.step(pos, his_p_call, &#34;r&#34;)
                    if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                        plt.plot(pos, his_p_mosaic, &#34;k&#34;)
                apos += len(his_p)
                xticks.append(apos)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks(np.arange(0, 15, 0.5) * max_m, [])
            ax.xaxis.set_ticks(xticks, [])
            ax.set_ylim([self.rd_manhattan_range[0] * max_m, self.rd_manhattan_range[1] * max_m])
        else:
            chroms = []
            snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
            for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
                snp_chr = io.snp_chromosome_name(c)
                if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                    if io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood call&#34;, snp_flag) and \
                            io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood segments&#34;, snp_flag) and \
                            (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                        chroms.append((snp_chr, l))

            apos = 0
            xticks = [0]

            cix = 0
            cmap = list(map(colors.to_rgba, plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;]))
            for c, l in chroms:
                flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO

                likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
                segments = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
                call_pos = []
                call_baf = []
                call_c = []
                for s, lh in zip(segments, likelihood):
                    b, p = likelihood_baf_pval(lh)
                    if b &gt; 0 and len(s) &gt; self.min_segment_size:
                        alpha = -np.log(p + 1e-40) / self.contrast
                        if alpha &gt; 1:
                            alpha = 1
                        for pos in s:
                            call_pos.append(apos + pos)
                            call_baf.append(b)
                            color = cmap[cix % len(cmap)]
                            color = (color[0], color[1], color[2], alpha)
                            call_c.append(color)

                ax.text(apos + l // bin_size // 2, 0.4, Genome.canonical_chrom_name(c),
                        fontsize=8, verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;center&#39;, )
                plt.scatter(call_pos, call_baf, s=20, color=np.array(call_c), edgecolors=&#39;face&#39;, marker=&#39;|&#39;)
                # plt.plot(call_pos, call_baf, color=np.array(call_c), ls=&#39;&#39;, marker=&#39;.&#39;)
                apos += l // bin_size
                xticks.append(apos)
                cix += 1

            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks(np.arange(0, 0.5, 0.1), [])
            ax.xaxis.set_ticks(xticks, [])
            ax.set_ylim([0, 0.5])

        n_bins = apos
        ax.set_xlim([0, n_bins])
        ax.grid()
    plt.subplots_adjust(bottom=0.05, top=0.95, wspace=0, hspace=0, left=0.05, right=0.95)

    if self.output_filename != &#34;&#34;:
        plt.savefig(self.image_filename(&#34;manhattan&#34; if plot_type == &#34;rd&#34; else &#34;snp_calls&#34;), dpi=200)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.multiple_regions"><code class="name flex">
<span>def <span class="ident">multiple_regions</span></span>(<span>self, bin_size, regions, panels=['rd'], sep_color='g')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def multiple_regions(self, bin_size, regions, panels=[&#34;rd&#34;], sep_color=&#34;g&#34;):
    plt.clf()
    plt.rcParams[&#34;font.size&#34;] = 8
    self.fig = plt.figure(1, figsize=(12, 8), facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    grid = gridspec.GridSpec(len(self.io), len(regions), wspace=0.2, hspace=0.2)
    ix = 0
    for i in self.io:
        for r in regions:
            self.regions(i, grid[ix], bin_size, r, panels=panels, sep_color=sep_color)
            ix += 1
    plt.subplots_adjust(bottom=0.05, top=0.95, wspace=0, hspace=0, left=0.05, right=0.95)

    if self.output_filename != &#34;&#34;:
        plt.savefig(self.image_filename(&#34;regions&#34;), dpi=150)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, command)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def parse(self, command):
    current = &#34;regions&#34;
    regions = []

    for p in command:
        if p.isdigit() and (int(p) % 100) == 0:
            if current == &#34;rd&#34;:
                self.rd(int(p), self.rd_use_mask)
            if current == &#34;baf&#34;:
                self.baf(int(p), self.rd_use_mask)
            if current == &#34;likelihood&#34;:
                self.likelihood(int(p))
            elif current == &#34;manhattan&#34;:
                self.manhattan(int(p), use_mask=self.rd_use_mask)
            elif current == &#34;calls&#34;:
                self.manhattan(int(p), use_mask=self.rd_use_mask, plot_type=&#34;calls&#34;)
            elif current == &#34;stat&#34;:
                self.stat(int(p))
            elif current == &#34;circular&#34;:
                self.circular(int(p), self.chrom, self.rd_use_mask)
            elif current == &#34;regions&#34;:
                self.multiple_regions(int(p), regions, panels=self.panels)
                regions = []
        elif p == &#34;rdstat&#34;:
            self.stat()
        elif p == &#34;snp&#34;:
            self.snp()
        elif p in [&#34;rd&#34;, &#34;baf&#34;, &#34;manhattan&#34;, &#34;calls&#34;, &#34;stat&#34;, &#34;regions&#34;, &#34;likelihood&#34;, &#34;circular&#34;]:
            current = p
        elif current == &#34;regions&#34;:
            regions.append(p)
        else:
            current = p</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, command)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot(self, command):
    self.interactive = False
    self.parse(command)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.prompt"><code class="name flex">
<span>def <span class="ident">prompt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def prompt(self):
    self.interactive = True

    for p in self.params:
        self.command_tree[&#34;set&#34;][p] = None
        if type(self.params[p]) == type(True):
            self.command_tree[&#34;unset&#34;][p] = None
    for c in self.param_help:
        self.command_tree[&#34;help&#34;][c] = None
    chromosomes = set({})
    for f in self.io:
        chromosomes = chromosomes.union(set(f.rd_chromosomes()))
        chromosomes = chromosomes.union(set(f.snp_chromosomes()))
    for c in chromosomes:
        self.command_tree[c] = None
    self.command_tree[&#34;set&#34;][&#34;style&#34;] = dict(zip(plt.style.available, [None] * len(plt.style.available)))

    readline.parse_and_bind(&#34;tab: complete&#34;)
    completer = PromptCompleter(self.command_tree)
    readline.set_completer(completer.complete)
    quit = False
    try:
        while not quit:
            try:
                line = raw_input(&#34;cnvpytor&gt; &#34;)
            except NameError:
                line = input(&#34;cnvpytor&gt; &#34;)

            pre = line.split(&#34;&gt;&#34;)
            f = pre[0].strip().split(&#34; &#34;)
            n = len(f)
            if len(line) == 0:
                continue
            elif f[0] == &#34;quit&#34;:
                quit = True
            elif line[0] == &#34;|&#34;:
                try:
                    eval(compile(line[1:], &#39;&lt;string&gt;&#39;, &#39;single&#39;))
                except Exception as e:
                    print(traceback.format_exc())
            elif f[0] == &#34;save&#34; and n &gt; 1:
                plt.savefig(f[1])
            elif f[0] in [&#34;draw&#34;, &#34;repaint&#34;, &#34;update&#34;] and n == 1:
                self.fig.canvas.draw()
            elif f[0] == &#34;ls&#34;:
                self.ls()
            elif f[0] == &#34;show&#34;:
                if n == 1:
                    self.show()
            elif f[0] == &#34;set&#34; and n &gt; 1:
                self.set(f[1], f[2:])
            elif f[0] == &#34;help&#34; and n &gt; 1:
                self.help(f[1])
            elif f[0] == &#34;help&#34; and n == 1:
                self.help(&#34;help&#34;)
            elif f[0] == &#34;unset&#34; and n &gt; 1:
                self.unset(f[1])
            elif f[0] == &#34;genotype&#34; and n &gt; 1:
                for ni in range(1, n):
                    self.genotype([self.bin_size], f[ni])
            elif f[0] == &#34;compare&#34; and n == 3:
                self.compare(f[1], f[2], plot=True)
            elif f[0] == &#34;snv&#34; and n == 2:
                self.snp(callset=f[1])
            elif f[0] == &#34;snv&#34; and n == 1:
                self.snp(callset=&#34;default&#34;)
            elif f[0] == &#34;compare&#34; and n == 4:
                self.compare(f[1], f[2], n_bins=int(f[3]), plot=True)
            elif f[0] == &#34;info&#34; and n &gt; 1:
                self.info(list(map(binsize_type,f[1:])))
            else:
                try:
                    if f[0] not in [&#34;rdstat&#34;, &#34;snp&#34;]:
                        self.parse(f + [str(self.bin_size)])
                    else:
                        self.parse(f)
                    if len(pre) &gt; 1:
                        fns = pre[1].strip().split(&#34; &#34;)
                        if fns[0] != &#34;&#34;:
                            plt.savefig(fns[0], dpi=200)
                except Exception as e:
                    print(traceback.format_exc())
    except (EOFError, KeyboardInterrupt):
        print()
        return</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.rd"><code class="name flex">
<span>def <span class="ident">rd</span></span>(<span>self, bin_size, use_mask)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rd(self, bin_size, use_mask):
    plt.clf()
    if self.reference_genome is None:
        _logger.warning(&#34;Missing reference genome required for gview.&#34;)
        return
    plt.rcParams[&#34;font.size&#34;] = 8
    chroms = []
    for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
        rd_chr = self.io[self.plot_file].rd_chromosome_name(c)
        if self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
            chroms.append((rd_chr, l))
    sx, sy = self.panels_shape(len(chroms))
    self.fig = plt.figure(1, figsize=(sx, sy), dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    if self.output_filename != &#34;&#34;:
        self.fig.set_figheight(8)
        self.fig.set_figwidth(12)
    ix = 1
    for c, l in chroms:
        flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
        stat = self.io[self.plot_file].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
        if stat is None:
            _logger.error(
                &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[self.plot_file].filename))
            exit(0)
        flag_rd = 0
        if use_mask:
            flag_rd = FLAG_USEMASK
        his_p = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
        his_p_corr = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
        his_p_seg = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD partition&#34;, flag_rd | FLAG_GC_CORR)
        his_p_call = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
        his_p_mosaic_seg = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                              flag_rd | FLAG_GC_CORR)
        his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
        his_p_mosaic_call = self.io[self.plot_file].get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                               flag_rd | FLAG_GC_CORR)
        his_p_mosaic = np.zeros_like(his_p) * np.nan
        if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
            for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                for segi in seg:
                    his_p_mosaic[segi] = lev
        ax = plt.subplot(sx, sy, ix)
        ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                     color=&#39;C0&#39;)
        ax.xaxis.set_ticklabels([])
        ax.yaxis.set_ticklabels([])
        ax.yaxis.set_ticks(np.arange(0, 3, 0.5) * stat[4], [])
        ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // bin_size, 10e6 // bin_size), [])
        ax.set_ylim([0, max(3. * stat[4], stat[4] + 5. * stat[5])])
        n_bins = l // bin_size
        ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
        ax.grid()

        plt.step(his_p, &#34;grey&#34;)
        plt.step(his_p_corr, &#34;k&#34;)
        if his_p_seg is not None and len(his_p_seg) &gt; 0 and self.rd_partition:
            plt.step(his_p_seg, &#34;r&#34;)
        if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call:
            plt.step(his_p_call, &#34;g&#34;)
        if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
            plt.step(his_p_mosaic, &#34;b&#34;)
        ix += 1
    plt.subplots_adjust(bottom=0., top=1., wspace=0, hspace=0, left=0., right=1.)
    if self.output_filename != &#34;&#34;:
        plt.savefig(self.image_filename(&#34;gview&#34;), dpi=150)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.rd_baf"><code class="name flex">
<span>def <span class="ident">rd_baf</span></span>(<span>self, hist=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rd_baf(self, hist=True):
    plt.clf()
    plt.rcParams[&#34;font.size&#34;] = 8
    self.fig = plt.figure(1, figsize=(12, 8), facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    n = len(self.plot_files)
    ix = self.plot_files
    if self.grid == &#34;auto&#34;:
        sx, sy = self.panels_shape(n)
    else:
        sx, sy = tuple(self.grid)
    grid = gridspec.GridSpec(sy, sx, wspace=0.2, hspace=0.2)
    bin_size = self.bin_size
    for i in range(n):
        ax = self.fig.add_subplot(grid[i])
        io = self.io[ix[i]]


        chroms = []
        snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
        rd_flag = FLAG_GC_CORR | (FLAG_USEMASK if self.rd_use_mask else 0)
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            snp_chr = io.snp_chromosome_name(c)
            if len(self.chrom) == 0 or (snp_chr in self.chrom) or (c in self.chrom):
                if io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood call&#34;, snp_flag) and \
                        io.signal_exists(snp_chr, bin_size, &#34;SNP likelihood segments&#34;, snp_flag) and \
                        io.signal_exists(snp_chr, bin_size, &#34;RD mosaic call&#34;, rd_flag) and \
                        io.signal_exists(snp_chr, bin_size, &#34;RD mosaic segments&#34;, rd_flag) and \
                        Genome.is_autosome(c):
                    chroms.append((snp_chr, l))
        x=[]
        y=[]
        for c, l in chroms:
            flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO

            likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood call&#34;, snp_flag)
            segments_baf = segments_decode(io.get_signal(c, bin_size, &#34;SNP likelihood segments&#34;, snp_flag))
            rd = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;, rd_flag)
            segments_rd = segments_decode(io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;, rd_flag))

            mbaf={}
            mrd={}
            for s, lh in zip(segments_baf, likelihood):
                b, p = likelihood_baf_pval(lh)
                for pos in s:
                    mbaf[pos]=0.5-b
            for s, r in zip(segments_rd, rd[0]):
                for pos in s:
                    mrd[pos]=r
            for p in mbaf:
                if p in mrd:
                    x.append(mbaf[p])
                    y.append(mrd[p])

        if hist:
            from matplotlib.colors import LogNorm
            ax.hist2d(x,y,bins=[np.arange(0,0.51,0.01),np.arange(0,max(y),max(y)/100.)],norm=LogNorm())
        else:
            ax.scatter(x,y,marker=&#34;.&#34;,alpha=0.5)

    if self.output_filename != &#34;&#34;:
        plt.savefig(self.image_filename(&#34;regions&#34;), dpi=150)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.rd_diff"><code class="name flex">
<span>def <span class="ident">rd_diff</span></span>(<span>self, bin_size, use_mask, file1, file2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rd_diff(self, bin_size, use_mask, file1, file2):
    plt.clf()
    if self.reference_genome is None:
        _logger.warning(&#34;Missing reference genome required for gview.&#34;)
        return
    plt.rcParams[&#34;font.size&#34;] = 8
    chroms = []
    for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
        rd_chr = self.io[self.plot_file].rd_chromosome_name(c)
        if self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, 0) and \
                self.io[self.plot_file].signal_exists(rd_chr, bin_size, &#34;RD&#34;, FLAG_GC_CORR) and \
                (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
            chroms.append((rd_chr, l))
    sx, sy = self.panels_shape(len(chroms))
    self.fig = plt.figure(1, figsize=(sx, sy), dpi=200, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    if self.output_filename != &#34;&#34;:
        self.fig.set_figheight(8)
        self.fig.set_figwidth(12)
    ix = 1
    for c, l in chroms:
        flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
        stat1 = self.io[file1].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
        stat2 = self.io[file2].get_signal(None, bin_size, &#34;RD stat&#34;, flag)
        if stat1 is None:
            _logger.error(
                &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[file1].filename))
            return
        if stat2 is None:
            _logger.error(
                &#34;Data for bin size %d is missing in file &#39;%s&#39;!&#34; % (bin_size, self.io[file2].filename))
            return
        flag_rd = 0
        if use_mask:
            flag_rd = FLAG_USEMASK
        his_p_corr1 = self.io[file1].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
        his_p_corr2 = self.io[file2].get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
        ax = plt.subplot(sx, sy, ix)
        ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                     color=&#39;C0&#39;)
        ax.xaxis.set_ticklabels([])
        ax.yaxis.set_ticklabels([])
        ax.yaxis.set_ticks(np.arange(0, 2, 0.25), [])
        ax.xaxis.set_ticks(np.arange(0, (l + 10e6) // bin_size, 10e6 // bin_size), [])
        ax.set_ylim([0, 1])
        n_bins = l // bin_size
        ax.set_xlim([-n_bins * 0.05, n_bins * 1.05])
        ax.grid()

        plt.step(np.abs(his_p_corr1 / stat1[4] - his_p_corr2 / stat2[4]), &#34;k&#34;)
        ix += 1
    plt.subplots_adjust(bottom=0., top=1., wspace=0, hspace=0, left=0., right=1.)
    if self.output_filename != &#34;&#34;:
        plt.savefig(self.image_filename(&#34;gview&#34;), dpi=150)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.regions"><code class="name flex">
<span>def <span class="ident">regions</span></span>(<span>self, io, element, bin_size, region, panels=['rd'], sep_color='g')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def regions(self, io, element, bin_size, region, panels=[&#34;rd&#34;], sep_color=&#34;g&#34;):
    snp_flag = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0)
    grid = gridspec.GridSpecFromSubplotSpec(len(panels), 1, subplot_spec=element, wspace=0, hspace=0.1)
    r = decode_region(region)
    for i in range(len(panels)):
        ax = self.fig.add_subplot(grid[i])
        if i == 0:
            ax.set_title(io.filename + &#34;: &#34; + region, position=(0.01, 0.9),
                         fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                         color=&#39;C0&#39;)

        if panels[i] == &#34;rd&#34;:
            g_p = []
            g_p_corr = []
            g_p_seg = []
            g_p_call = []
            g_p_call_mosaic = []
            mean, stdev = 0, 0
            borders = []
            for c, (pos1, pos2) in r:
                flag = FLAG_MT if Genome.is_mt_chrom(c) else FLAG_SEX if Genome.is_sex_chrom(c) else FLAG_AUTO
                flag_rd = 0
                if self.rd_use_mask:
                    flag_rd = FLAG_USEMASK
                stat = io.get_signal(None, bin_size, &#34;RD stat&#34;, flag)
                mean = stat[4]
                stdev = stat[5]
                his_p = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd)
                his_p_corr = io.get_signal(c, bin_size, &#34;RD&#34;, flag_rd | FLAG_GC_CORR)
                his_p_seg = io.get_signal(c, bin_size, &#34;RD partition&#34;, flag_rd | FLAG_GC_CORR)
                his_p_call = io.get_signal(c, bin_size, &#34;RD call&#34;, flag_rd | FLAG_GC_CORR)
                his_p_mosaic_seg = io.get_signal(c, bin_size, &#34;RD mosaic segments&#34;,
                                                 flag_rd | FLAG_GC_CORR)
                his_p_mosaic_seg = segments_decode(his_p_mosaic_seg)
                his_p_mosaic_call = io.get_signal(c, bin_size, &#34;RD mosaic call&#34;,
                                                  flag_rd | FLAG_GC_CORR)
                his_p_mosaic = np.zeros_like(his_p) * np.nan
                if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                    for seg, lev in zip(list(his_p_mosaic_seg), list(his_p_mosaic_call[0])):
                        for segi in seg:
                            his_p_mosaic[segi] = lev

                start_bin = (pos1 - 1) // bin_size
                end_bin = pos2 // bin_size
                g_p.extend(list(his_p[start_bin:end_bin]))
                g_p_corr.extend(list(his_p_corr[start_bin:end_bin]))
                if his_p_seg is not None and len(his_p_seg) &gt; 0 and self.rd_partition:
                    g_p_seg.extend(list(his_p_seg[start_bin:end_bin]))
                if his_p_call is not None and len(his_p_call) &gt; 0 and self.rd_call:
                    g_p_call.extend(list(his_p_call[start_bin:end_bin]))
                if his_p_mosaic_call is not None and len(his_p_mosaic_call) &gt; 0 and self.rd_call_mosaic:
                    g_p_call_mosaic.extend(list(his_p_mosaic[start_bin:end_bin]))
                borders.append(len(g_p) - 1)

            # ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            l = len(g_p)
            # ax.xaxis.set_ticks(np.arange(0, l, 10), [])
            ax.yaxis.set_ticks(np.arange(0, 3, 0.5) * mean, [])
            ax.set_ylim([0, max(3. * mean, mean + 5. * stdev)])
            ax.set_xlim([-l * 0.0, l * 1.0])

            ax.yaxis.grid()
            ax.step(g_p, &#34;grey&#34;)
            ax.step(g_p_corr, &#34;k&#34;)
            if len(g_p_seg) &gt; 0:
                plt.step(g_p_seg, &#34;r&#34;)
            if len(g_p_call) &gt; 0:
                plt.step(g_p_call, &#34;g&#34;)
            if len(g_p_call_mosaic) &gt; 0:
                plt.step(g_p_call_mosaic, &#34;b&#34;)
            for i in borders[:-1]:
                ax.axvline(i, color=sep_color, lw=1)
            self.fig.add_subplot(ax)

        elif panels[i] == &#34;snp&#34;:
            borders = []
            hpos = []
            baf = []
            color = []
            start_pos = 0
            for c, (pos1, pos2) in r:
                pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c)
                ix = 0
                mdp = 0
                while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                    if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0:
                        hpos.append(start_pos + pos[ix] - pos1)
                        if pos[ix] - pos1 &gt; mdp:
                            mdp = pos[ix] - pos1
                        if gt[ix] % 4 != 2:
                            baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                        else:
                            baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                        color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                    ix += 1
                start_pos += mdp
                borders.append(start_pos)

            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], [])
            l = max(hpos)
            # ax.xaxis.set_ticks(np.arange(0, (l + 10e6), 10e6), [])
            ax.set_ylim([0., 1.])
            ax.set_xlim([0, borders[-1]])
            ax.yaxis.grid()
            if self.markersize == &#34;auto&#34;:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=0.7)
            else:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=0.7)

            for i in borders[:-1]:
                ax.axvline(i, color=sep_color, lw=1)
            self.fig.add_subplot(ax)

        elif panels[i] == &#34;snv&#34; or panels[i][:4] == &#34;snv:&#34;:
            callset = &#34;default&#34;
            if panels[i][:4] == &#34;snv:&#34;:
                callset=panels[i].split(&#34;:&#34;)[1]
            borders = []
            hpos = []
            baf = []
            color = []
            start_pos = 0
            for c, (pos1, pos2) in r:
                pos, ref, alt, nref, nalt, gt, flag, qual = io.read_snp(c,callset=callset)
                ix = 0
                mdp = 0
                while ix &lt; len(pos) and pos[ix] &lt;= pos2:
                    if pos[ix] &gt;= pos1 and (nref[ix] + nalt[ix]) != 0:
                        hpos.append(start_pos + pos[ix] - pos1)
                        if pos[ix] - pos1 &gt; mdp:
                            mdp = pos[ix] - pos1
                        if gt[ix] % 4 != 2:
                            baf.append(1.0 * nalt[ix] / (nref[ix] + nalt[ix]))
                        else:
                            baf.append(1.0 * nref[ix] / (nref[ix] + nalt[ix]))
                        color.append(self.snp_colors[(gt[ix] % 4) * 2 + (flag[ix] &gt;&gt; 1)])
                    ix += 1
                start_pos += mdp
                borders.append(start_pos)

            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], [])
            l = max(hpos)
            # ax.xaxis.set_ticks(np.arange(0, (l + 10e6), 10e6), [])
            ax.set_ylim([0., 1.])
            ax.set_xlim([0, borders[-1]])
            ax.yaxis.grid()
            if self.markersize == &#34;auto&#34;:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=0.7)
            else:
                ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=0.7)

            for i in borders[:-1]:
                ax.axvline(i, color=sep_color, lw=1)
            self.fig.add_subplot(ax)

        elif panels[i] == &#34;baf&#34;:
            g_baf, g_maf, g_i1, g_i2 = [], [], [], []
            borders = []
            for c, (pos1, pos2) in r:
                flag_snp = (FLAG_USEMASK if self.snp_use_mask else 0) | (FLAG_USEID if self.snp_use_id else 0) | (
                    FLAG_USEHAP if self.snp_use_phase else 0)
                baf = io.get_signal(c, bin_size, &#34;SNP baf&#34;, flag_snp)
                maf = io.get_signal(c, bin_size, &#34;SNP maf&#34;, flag_snp)
                i1 = io.get_signal(c, bin_size, &#34;SNP i1&#34;, flag_snp)
                i2 = io.get_signal(c, bin_size, &#34;SNP i2&#34;, flag_snp)

                start_bin = (pos1 - 1) // bin_size
                end_bin = pos2 // bin_size
                g_baf.extend(list(baf[start_bin:end_bin]))
                g_maf.extend(list(maf[start_bin:end_bin]))
                g_i1.extend(list(i1[start_bin:end_bin]))
                g_i2.extend(list(i2[start_bin:end_bin]))
                borders.append(len(g_baf) - 1)

            # ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            l = len(g_baf)
            # ax.xaxis.set_ticks(np.arange(0, l, 10), [])
            ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], [])
            ax.set_ylim([0, 1])
            ax.set_xlim([-l * 0.0, l * 1.0])

            ax.yaxis.grid()
            ax.step(g_baf, &#34;grey&#34;)
            ax.step(g_maf, &#34;k&#34;)
            ax.step(g_i1, &#34;r&#34;)
            for i in borders[:-1]:
                ax.axvline(i, color=sep_color, lw=1)
            self.fig.add_subplot(ax)

        elif panels[i] == &#34;likelihood&#34;:
            borders = []
            gl = []
            for c, (pos1, pos2) in r:
                likelihood = io.get_signal(c, bin_size, &#34;SNP likelihood&#34;, snp_flag)
                start_bin = (pos1 - 1) // bin_size
                end_bin = pos2 // bin_size
                gl.extend(list(likelihood[start_bin:end_bin]))
                borders.append(len(gl) - 1)
            img = np.array(gl).transpose()
            ax.imshow(img, aspect=&#39;auto&#39;)
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.xaxis.set_ticks(np.arange(0, len(gl), 50), [])

            for i in borders[:-1]:
                ax.axvline(i, color=sep_color, lw=1)
            self.fig.add_subplot(ax)</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show(self):
    print(&#34;\nParameters&#34;)
    for key in sorted(self.params.keys()):
        print(&#34;    * %s: %s&#34; % (key, str(self.params[key])))
        if key == &#34;plot_files&#34;:
            for i in range(len(self.io)):
                print(&#34;            %d: %s&#34; % (i, self.io[i].filename))
    print()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.snp"><code class="name flex">
<span>def <span class="ident">snp</span></span>(<span>self, size=10, plot_gt=None, plot_pmask=None, callset=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def snp(self, size=10, plot_gt=None, plot_pmask=None, callset=None):
    if plot_pmask is None:
        plot_pmask = [0, 1]
    if plot_gt is None:
        plot_gt = [0, 1, 2, 3]
    plt.clf()
    plt.rcParams[&#34;font.size&#34;] = 8
    self.fig = plt.figure(1, figsize=(12, 8), dpi=90, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    if self.output_filename != &#34;&#34;:
        self.fig.set_figheight(8)
        self.fig.set_figwidth(12)
    chroms = []
    if self.reference_genome is None:
        chroms = self.io[self.plot_file].snp_chromosomes()
    else:
        for c, (l, t) in self.reference_genome[&#34;chromosomes&#34;].items():
            snp_chr = self.io[self.plot_file].snp_chromosome_name(c)
            if callset is None:
                if self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP pos&#34;, 0) and \
                        self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP desc&#34;, 0) and \
                        self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP counts&#34;, 0) and \
                        self.io[self.plot_file].signal_exists(snp_chr, None, &#34;SNP qual&#34;, 0) and \
                        (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                    chroms.append(snp_chr)
            else:
                if self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP pos&#34;, 0, name=callset) and \
                        self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP desc&#34;, 0, name=callset) and \
                        self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP counts&#34;, 0, name=callset) and \
                        self.io[self.plot_file].signal_exists(snp_chr, None, &#34;somatic SNP qual&#34;, 0, name=callset) and \
                        (Genome.is_autosome(c) or Genome.is_sex_chrom(c)):
                    chroms.append(snp_chr)
    sx, sy = self.panels_shape(len(chroms))
    ix = 1
    for c in chroms:
        pos, ref, alt, nref, nalt, gt, flag, qual = self.io[self.plot_file].read_snp(c, callset=callset)
        hpos = []
        baf = []
        color = []
        for i in range(len(pos)):
            if (nref[i] + nalt[i]) != 0:
                if (gt[i] % 4 in plot_gt) and ((flag[i] &gt;&gt; 1) in plot_pmask):
                    hpos.append(pos[i])
                    if gt[i] % 4 != 2:
                        baf.append(1.0 * nalt[i] / (nref[i] + nalt[i]))
                    else:
                        baf.append(1.0 * nref[i] / (nref[i] + nalt[i]))
                    color.append(self.snp_colors[(gt[i] % 4) * 2 + (flag[i] &gt;&gt; 1)])

        ax = plt.subplot(sx, sy, ix)
        ax.set_title(c, position=(0.01, 0.9), fontdict={&#39;verticalalignment&#39;: &#39;top&#39;, &#39;horizontalalignment&#39;: &#39;left&#39;},
                     color=&#39;C0&#39;)
        ax.xaxis.set_ticklabels([])
        ax.yaxis.set_ticklabels([])
        ax.yaxis.set_ticks([0, 0.25, 0.5, 0.75, 1.0], [])
        l = max(pos)
        ax.xaxis.set_ticks(np.arange(0, (l + 10e6), 10e6), [])
        ax.set_ylim([0., 1.])
        ax.set_xlim([-0.05 * l, 1.05 * l])
        ax.grid()
        if self.markersize == &#34;auto&#34;:
            ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=10, alpha=0.7)
        else:
            ax.scatter(hpos, baf, marker=&#39;.&#39;, edgecolor=color, c=color, s=self.markersize, alpha=0.7)
        ix += 1
    plt.subplots_adjust(bottom=0., top=1., wspace=0, hspace=0, left=0., right=1.)
    if self.output_filename != &#34;&#34;:
        plt.savefig(self.image_filename(&#34;gview&#34;), dpi=150)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="cnvpytor.viewer.Viewer.stat"><code class="name flex">
<span>def <span class="ident">stat</span></span>(<span>self, his_bin_size=100, return_image=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def stat(self, his_bin_size=100, return_image=False):
    plt.clf()
    auto = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_AUTO)
    sex = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_SEX)
    mt = self.io[self.plot_file].signal_exists(None, his_bin_size, &#34;RD stat&#34;, FLAG_MT) and (his_bin_size &lt; 1001)
    if not (auto or sex or mt):
        return
    cond = [auto, sex, mt]
    stat_list = []
    n_cols = sum(map(int, cond))
    ix = 1
    plt.rcParams[&#34;font.size&#34;] = 8
    self.fig = plt.figure(1, figsize=(4 * n_cols, 8), dpi=90, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    for t, c, flag in zip([&#34;Autosomes&#34;, &#34;X/Y&#34;, &#34;Mitochondria&#34;], cond, [FLAG_AUTO, FLAG_SEX, FLAG_MT]):
        if c:
            stat = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD stat&#34;, flag)
            stat_list.append(stat)
            max_rd = int(stat[0])
            bin_size = int(stat[1])
            n_bins = int(stat[2])
            lim_rd = int(max(2 * stat[4], stat[4] + 3 * stat[5]))
            _logger.info(&#34;RD stat for %s: %.2f +- %.2f&#34; % (t, stat[4], stat[5]))
            if t == &#34;Mitochondria&#34; and auto:
                _logger.info(&#34;RD stat for %s - number of miochondria per cell: %.2f +- %.2f&#34; % (
                    t, 2 * stat[4] / stat_list[0][4],
                    2 * stat[5] / stat_list[0][4] + stat_list[0][5] * stat[4] / (
                            stat_list[0][4] * stat_list[0][4])))
            his_p = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD p dist&#34;, flag)
            his_u = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD u dist&#34;, flag)
            his_rd_gc = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;RD GC dist&#34;, flag)
            gc_corr = self.io[self.plot_file].get_signal(None, his_bin_size, &#34;GC corr&#34;, flag)
            ax = plt.subplot(2, n_cols, ix)
            ax.set_xlabel(&#34;RD&#34;)
            ax.set_ylabel(&#34;GC [%]&#34;)
            ax.xaxis.set_ticklabels([])
            ax.set_title(t)
            his_rd_gc[0][0] = 0
            ax.imshow(his_rd_gc[:lim_rd // bin_size, :].T, aspect=&#34;auto&#34;, interpolation=&#39;nearest&#39;, origin=&#39;lower&#39;)
            ax.plot(gc_corr * stat[4] / bin_size, range(101), &#34;w-&#34;)

            ax = plt.subplot(2, n_cols, ix + n_cols)
            ax.set_ylabel(&#34;Normalised distribution&#34;)
            ax.set_xlabel(&#34;RD&#34;)
            ax.set_xlim([0, lim_rd])
            # ax.set_ylim([0, 1.1])
            bins = range(0, max_rd, bin_size)
            x = np.arange(0, max_rd // bin_size * bin_size, 0.1 * bin_size)
            plt.plot(x, normal(x, 1, stat[4], stat[5]), &#34;g-&#34;)
            x = np.array(bins)
            plt.plot(x[:len(his_u)], his_u / stat[3], &#34;y*&#34;)
            plt.plot(x[:len(his_p)], his_p / stat[3], &#34;b*&#34;)
            ix += 1
    plt.subplots_adjust(bottom=0.08, top=0.95, wspace=0.25, hspace=0, left=0.05 * 3 / n_cols, right=0.95)
    if return_image:
        self.fig.canvas.draw()
        import PIL
        pil_image = PIL.Image.frombytes(&#39;RGB&#39;, self.fig.canvas.get_width_height(),
                                        self.fig.canvas.tostring_rgb())
        return pil_image
    elif self.output_filename != &#34;&#34;:
        plt.savefig(self.image_filename(&#34;stat&#34;), dpi=150)
        plt.close(self.fig)
    elif self.interactive:
        plt.show(block=False)
        plt.draw()
    else:
        plt.show()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cnvpytor.viewparams.ViewParams" href="viewparams.html#cnvpytor.viewparams.ViewParams">ViewParams</a></b></code>:
<ul class="hlist">
<li><code><a title="cnvpytor.viewparams.ViewParams.bin_size_f" href="viewparams.html#cnvpytor.viewparams.ViewParams.bin_size_f">bin_size_f</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cnvpytor" href="index.html">cnvpytor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cnvpytor.viewer.anim_plot_likelihood" href="#cnvpytor.viewer.anim_plot_likelihood">anim_plot_likelihood</a></code></li>
<li><code><a title="cnvpytor.viewer.anim_plot_rd" href="#cnvpytor.viewer.anim_plot_rd">anim_plot_rd</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cnvpytor.viewer.Export" href="#cnvpytor.viewer.Export">Export</a></code></h4>
<ul class="">
<li><code><a title="cnvpytor.viewer.Export.cnvnator" href="#cnvpytor.viewer.Export.cnvnator">cnvnator</a></code></li>
<li><code><a title="cnvpytor.viewer.Export.jbrowse" href="#cnvpytor.viewer.Export.jbrowse">jbrowse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cnvpytor.viewer.Reader" href="#cnvpytor.viewer.Reader">Reader</a></code></h4>
</li>
<li>
<h4><code><a title="cnvpytor.viewer.Show" href="#cnvpytor.viewer.Show">Show</a></code></h4>
<ul class="">
<li><code><a title="cnvpytor.viewer.Show.info" href="#cnvpytor.viewer.Show.info">info</a></code></li>
<li><code><a title="cnvpytor.viewer.Show.ls" href="#cnvpytor.viewer.Show.ls">ls</a></code></li>
<li><code><a title="cnvpytor.viewer.Show.meta" href="#cnvpytor.viewer.Show.meta">meta</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cnvpytor.viewer.Viewer" href="#cnvpytor.viewer.Viewer">Viewer</a></code></h4>
<ul class="two-column">
<li><code><a title="cnvpytor.viewer.Viewer.circular" href="#cnvpytor.viewer.Viewer.circular">circular</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.compare" href="#cnvpytor.viewer.Viewer.compare">compare</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.dispersion" href="#cnvpytor.viewer.Viewer.dispersion">dispersion</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.genotype" href="#cnvpytor.viewer.Viewer.genotype">genotype</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.genotype_prompt" href="#cnvpytor.viewer.Viewer.genotype_prompt">genotype_prompt</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.help" href="#cnvpytor.viewer.Viewer.help">help</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.image_filename" href="#cnvpytor.viewer.Viewer.image_filename">image_filename</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.likelihood" href="#cnvpytor.viewer.Viewer.likelihood">likelihood</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.manhattan" href="#cnvpytor.viewer.Viewer.manhattan">manhattan</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.multiple_regions" href="#cnvpytor.viewer.Viewer.multiple_regions">multiple_regions</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.panels_shape" href="#cnvpytor.viewer.Viewer.panels_shape">panels_shape</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.parse" href="#cnvpytor.viewer.Viewer.parse">parse</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.plot" href="#cnvpytor.viewer.Viewer.plot">plot</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.prompt" href="#cnvpytor.viewer.Viewer.prompt">prompt</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.rd" href="#cnvpytor.viewer.Viewer.rd">rd</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.rd_baf" href="#cnvpytor.viewer.Viewer.rd_baf">rd_baf</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.rd_diff" href="#cnvpytor.viewer.Viewer.rd_diff">rd_diff</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.regions" href="#cnvpytor.viewer.Viewer.regions">regions</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.set_style" href="#cnvpytor.viewer.Viewer.set_style">set_style</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.show" href="#cnvpytor.viewer.Viewer.show">show</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.snp" href="#cnvpytor.viewer.Viewer.snp">snp</a></code></li>
<li><code><a title="cnvpytor.viewer.Viewer.stat" href="#cnvpytor.viewer.Viewer.stat">stat</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>